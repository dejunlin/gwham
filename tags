!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A note on floating point precision required by the WHAM kernel	doc/tex/implement.tex	/^\\subsection{A note on floating point precision required by the WHAM kernel}\\label{sec:prec}$/;"	b
AM	ran2.c	/^#define AM /;"	d	file:
AM	ran2.c	/^#undef AM$/;"	d	file:
About this document	doc/tex/about.tex	/^\\section{About this document}$/;"	s
Akey	gmxmdp.hpp	/^  const string Akey = "$1" + Aid + "$2";$/;"	l
Akeystr	gmxmdp.hpp	/^    const string Akeystr = regex_replace(key, Bkey, Akey);$/;"	l
ArithmeticSeq	metaprog_snippets.hpp	/^struct ArithmeticSeq<I<>, I<> > {$/;"	s
ArithmeticSeq	metaprog_snippets.hpp	/^struct ArithmeticSeq<I<indices...>, I<Ni, dN> > {$/;"	s
ArithmeticSeq	metaprog_snippets.hpp	/^template < class T, class Arg > struct ArithmeticSeq{};$/;"	s
ArithmeticSeq::seed	metaprog_snippets.hpp	/^  typedef I<1, 1> seed;$/;"	t	struct:ArithmeticSeq	access:public
ArithmeticSeq::seed	metaprog_snippets.hpp	/^  typedef I<Ni+dN, dN> seed;$/;"	t	struct:ArithmeticSeq	access:public
ArithmeticSeq::type	metaprog_snippets.hpp	/^  typedef I<0> type;$/;"	t	struct:ArithmeticSeq	access:public
ArithmeticSeq::type	metaprog_snippets.hpp	/^  typedef I<indices..., Ni+dN> type;$/;"	t	struct:ArithmeticSeq	access:public
BoltzmannkJ	typedefs.hpp	/^const valtype BoltzmannkJ = 0.0083144621; $/;"	v
Boltzmannkcal	typedefs.hpp	/^const valtype Boltzmannkcal = 0.0019872041;$/;"	v
BondLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
Bool	minimizer/cg.hpp	/^typedef bool Bool;$/;"	t
Bracketmethod	minimizer/cg.hpp	/^struct Bracketmethod {$/;"	s
Bracketmethod::GLIMIT	minimizer/cg.hpp	/^		const Doub GOLD=1.618034,GLIMIT=100.0,TINY=1.0e-8;$/;"	l
Bracketmethod::GOLD	minimizer/cg.hpp	/^		const Doub GOLD=1.618034,GLIMIT=100.0,TINY=1.0e-8;$/;"	l
Bracketmethod::TINY	minimizer/cg.hpp	/^		const Doub GOLD=1.618034,GLIMIT=100.0,TINY=1.0e-8;$/;"	l
Bracketmethod::ax	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
Bracketmethod::bracket	minimizer/cg.hpp	/^	void bracket(const Doub a, const Doub b, T &func)$/;"	f	struct:Bracketmethod	access:public
Bracketmethod::bx	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
Bracketmethod::cx	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
Bracketmethod::fa	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
Bracketmethod::fb	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
Bracketmethod::fc	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
Bracketmethod::fu	minimizer/cg.hpp	/^		Doub fu;$/;"	l
Bracketmethod::mov3	minimizer/cg.hpp	/^	inline void mov3(Doub &a, Doub &b, Doub &c, const Doub d, const Doub e,$/;"	f	struct:Bracketmethod	access:public
Bracketmethod::q	minimizer/cg.hpp	/^			Doub q=(bx-cx)*(fb-fa);$/;"	l
Bracketmethod::r	minimizer/cg.hpp	/^			Doub r=(bx-ax)*(fb-fc);$/;"	l
Bracketmethod::shft2	minimizer/cg.hpp	/^	inline void shft2(Doub &a, Doub &b, const Doub c)$/;"	f	struct:Bracketmethod	access:public
Bracketmethod::shft3	minimizer/cg.hpp	/^	inline void shft3(Doub &a, Doub &b, Doub &c, const Doub d)$/;"	f	struct:Bracketmethod	access:public
Bracketmethod::u	minimizer/cg.hpp	/^			Doub u=bx-((bx-cx)*q-(bx-ax)*r)\/$/;"	l
Bracketmethod::ulim	minimizer/cg.hpp	/^			Doub ulim=bx+GLIMIT*(cx-bx);$/;"	l
C	gwham.hpp	/^  NARRAY C;$/;"	l
C	likelihoodfunc.hpp	/^    const NARRAY& C;$/;"	m	class:LikeliHoodFunc	access:private
CG_HPP	minimizer/cg.hpp	/^#define CG_HPP$/;"	d
CTZ	metaprog_snippets.hpp	/^    b >>= CTZ(b);$/;"	p
CTZ	metaprog_snippets.hpp	/^  a >>= CTZ(a);$/;"	p
CTZ	metaprog_snippets.hpp	/^#define CTZ(/;"	d
ConstantForce	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
Constraint	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
Contact	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
ContainerCopier	metaprog_snippets.hpp	/^  ContainerCopier(Src src) : value({src[indices]...,}) {$/;"	f	struct:ContainerCopier	access:public
ContainerCopier	metaprog_snippets.hpp	/^struct ContainerCopier<Src, Des, I<indices...> > {$/;"	s
ContainerCopier	metaprog_snippets.hpp	/^template < class Src, class Des, class ... Sub > struct ContainerCopier{};$/;"	s
ContainerCopier::ContainerCopier	metaprog_snippets.hpp	/^  ContainerCopier(Src src) : value({src[indices]...,}) {$/;"	f	struct:ContainerCopier	access:public
ContainerCopier::value	metaprog_snippets.hpp	/^  Des value;$/;"	m	struct:ContainerCopier	access:public
CoulLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
CreateMDP	gmxmdp.hpp	/^    static pMDP CreateMDP(const string& fname) {$/;"	f	class:GMXMDP	access:public
CreateMDPs	mdp_factory.hpp	/^CreateMDPs(const vector<string>& MDPprefixes,$/;"	f
CreateTimeSeries	gmxmdp.cpp	/^vector<TimeSeries<valtype>> GMXMDP::CreateTimeSeries(const bool& requirepot) const {$/;"	f	class:GMXMDP
CreateTimeSeries	gmxmdp.hpp	/^    virtual vector<TimeSeries<valtype>> CreateTimeSeries(const bool& requirepot) const;$/;"	p	class:GMXMDP	access:public
CreateTimeSeries	mdp.hpp	/^    virtual vector<TimeSeries<valtype>> CreateTimeSeries(const bool& requirepot) const = 0;$/;"	p	class:MDP	access:public
Cylinder	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
DHamiltonian	ensemble.hpp	/^    enum Qt {DHamiltonian, DTemperature, DPressure};$/;"	e	enum:Ensemble::Qt
DOS	densityofstate.hpp	/^    narray DOS;$/;"	m	class:DensityOfState	access:private
DOS	gwham.hpp	/^     DOStype DOS;$/;"	m	class:WHAM	access:private
DOSptr	gwham.hpp	/^  typedef DOStype* DOSptr;$/;"	t	class:WHAM	access:private
DOStype	gwham.hpp	/^  typedef DensityOfState<PENSEMBLE,HISTOGRAM,NARRAY> DOStype;$/;"	t	class:WHAM	access:private
DPressure	ensemble.hpp	/^    enum Qt {DHamiltonian, DTemperature, DPressure};$/;"	e	enum:Ensemble::Qt
DTemperature	ensemble.hpp	/^    enum Qt {DHamiltonian, DTemperature, DPressure};$/;"	e	enum:Ensemble::Qt
Data	likelihoodfunc.hpp	/^    typedef V Data;$/;"	t	class:ftree	access:public
Dbrent	minimizer/cg.hpp	/^	Dbrent(const Doub toll=3.0e-8) : tol(toll) {}$/;"	f	struct:Dbrent	access:public
Dbrent	minimizer/cg.hpp	/^struct Dbrent : Bracketmethod {$/;"	s	inherits:Bracketmethod
Dbrent::Dbrent	minimizer/cg.hpp	/^	Dbrent(const Doub toll=3.0e-8) : tol(toll) {}$/;"	f	struct:Dbrent	access:public
Dbrent::ITMAX	minimizer/cg.hpp	/^		const Int ITMAX=100;$/;"	l
Dbrent::ZEPS	minimizer/cg.hpp	/^		const Doub ZEPS=numeric_limits<Doub>::epsilon()*1.0e-3;$/;"	l
Dbrent::a	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::b	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::d	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::d1	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::d2	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::du	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::dv	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::dw	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::dx	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::e	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
Dbrent::fmin	minimizer/cg.hpp	/^	Doub xmin,fmin;$/;"	m	struct:Dbrent	access:public
Dbrent::fu	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::fv	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::fw	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::fx	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::minimize	minimizer/cg.hpp	/^	Doub minimize(T &funcd)$/;"	f	struct:Dbrent	access:public
Dbrent::ok1	minimizer/cg.hpp	/^		Bool ok1,ok2;$/;"	l
Dbrent::ok2	minimizer/cg.hpp	/^		Bool ok1,ok2;$/;"	l
Dbrent::olde	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::tol	minimizer/cg.hpp	/^	const Doub tol;$/;"	m	struct:Dbrent	access:public
Dbrent::tol1	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::tol2	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::u	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::u1	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::u2	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::v	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::w	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::x	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::xm	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
Dbrent::xmin	minimizer/cg.hpp	/^	Doub xmin,fmin;$/;"	m	struct:Dbrent	access:public
DensityOfState	densityofstate.hpp	/^    DensityOfState();$/;"	p	class:DensityOfState	access:public
DensityOfState	densityofstate.hpp	/^    DensityOfState(const histogram& hist);$/;"	p	class:DensityOfState	access:public
DensityOfState	densityofstate.hpp	/^DensityOfState<ensemble,histogram,narray>::DensityOfState():$/;"	f	class:DensityOfState
DensityOfState	densityofstate.hpp	/^DensityOfState<ensemble,histogram,narray>::DensityOfState(const histogram& hist)$/;"	f	class:DensityOfState
DensityOfState	densityofstate.hpp	/^class DensityOfState {$/;"	c
DensityOfState::DOS	densityofstate.hpp	/^    narray DOS;$/;"	m	class:DensityOfState	access:private
DensityOfState::DensityOfState	densityofstate.hpp	/^    DensityOfState();$/;"	p	class:DensityOfState	access:public
DensityOfState::DensityOfState	densityofstate.hpp	/^    DensityOfState(const histogram& hist);$/;"	p	class:DensityOfState	access:public
DensityOfState::DensityOfState	densityofstate.hpp	/^DensityOfState<ensemble,histogram,narray>::DensityOfState():$/;"	f	class:DensityOfState
DensityOfState::DensityOfState	densityofstate.hpp	/^DensityOfState<ensemble,histogram,narray>::DensityOfState(const histogram& hist)$/;"	f	class:DensityOfState
DensityOfState::assign	densityofstate.hpp	/^      newexpf.assign(newexpf.size(), 0.0);$/;"	p
DensityOfState::begin	densityofstate.hpp	/^    const_iterator begin() const { return DOS.begin(); }$/;"	f	class:DensityOfState	access:public
DensityOfState::begin	densityofstate.hpp	/^    iterator begin() { return DOS.begin(); }$/;"	f	class:DensityOfState	access:public
DensityOfState::const_iterator	densityofstate.hpp	/^    typedef typename narray::const_iterator const_iterator;$/;"	t	class:DensityOfState	access:public
DensityOfState::denum	densityofstate.hpp	/^      valtype denum = 0.0;$/;"	v
DensityOfState::dos	densityofstate.hpp	/^	const auto dos = this->operator()(itC, itsNgexpmH, expf);$/;"	l
DensityOfState::end	densityofstate.hpp	/^    const_iterator end() const { return DOS.end(); }$/;"	f	class:DensityOfState	access:public
DensityOfState::end	densityofstate.hpp	/^    iterator end() { return DOS.end(); }$/;"	f	class:DensityOfState	access:public
DensityOfState::getdosarr	densityofstate.hpp	/^    const narray& getdosarr() const { return DOS;}$/;"	f	class:DensityOfState	access:public
DensityOfState::iterator	densityofstate.hpp	/^    typedef typename narray::iterator iterator;$/;"	t	class:DensityOfState	access:public
DensityOfState::num	densityofstate.hpp	/^      const auto& num = itC->second;$/;"	v
DensityOfState::operator ()	densityofstate.hpp	/^    void operator() ($/;"	f	class:DensityOfState	access:public
DensityOfState::operator []	densityofstate.hpp	/^    valtype operator[](const coordtype& coord) const { return DOS[coord]; };$/;"	f	class:DensityOfState	access:public
DensityOfState::operator []	densityofstate.hpp	/^    valtype& operator[](const coordtype& coord) { return DOS[coord]; };$/;"	f	class:DensityOfState	access:public
DensityOfState::print	densityofstate.hpp	/^    void print() const { DOS.print(); }$/;"	f	class:DensityOfState	access:public
DensityOfState::print	densityofstate.hpp	/^    void print() const { DOS.print(); }$/;"	p
Df1dim	minimizer/cg.hpp	/^	Df1dim(VecDoub_I &pp, VecDoub_I &xii, T &funcdd) : p(pp),$/;"	f	struct:Df1dim	access:public
Df1dim	minimizer/cg.hpp	/^struct Df1dim {$/;"	s
Df1dim::Df1dim	minimizer/cg.hpp	/^	Df1dim(VecDoub_I &pp, VecDoub_I &xii, T &funcdd) : p(pp),$/;"	f	struct:Df1dim	access:public
Df1dim::df	minimizer/cg.hpp	/^		funcd.df(xt,dft);$/;"	p
Df1dim::df	minimizer/cg.hpp	/^	Doub df(const Doub x)$/;"	f	struct:Df1dim	access:public
Df1dim::df1	minimizer/cg.hpp	/^		Doub df1=0.0;$/;"	l
Df1dim::dft	minimizer/cg.hpp	/^	VecDoub dft;$/;"	m	struct:Df1dim	access:public
Df1dim::funcd	minimizer/cg.hpp	/^	T &funcd;$/;"	m	struct:Df1dim	access:public
Df1dim::n	minimizer/cg.hpp	/^	Int n;$/;"	m	struct:Df1dim	access:public
Df1dim::operator ()	minimizer/cg.hpp	/^	Doub operator()(const Doub x)$/;"	f	struct:Df1dim	access:public
Df1dim::p	minimizer/cg.hpp	/^	const VecDoub &p;$/;"	m	struct:Df1dim	access:public
Df1dim::xi	minimizer/cg.hpp	/^	const VecDoub &xi;$/;"	m	struct:Df1dim	access:public
Df1dim::xt	minimizer/cg.hpp	/^	VecDoub xt;$/;"	m	struct:Df1dim	access:public
Direction	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
DirectionPeriodic	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
Distance	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
Dlinemethod	minimizer/cg.hpp	/^	Dlinemethod(T &funcc, const Doub& _ftol) : func(funcc), ftol(_ftol) {}$/;"	f	struct:Dlinemethod	access:public
Dlinemethod	minimizer/cg.hpp	/^struct Dlinemethod {$/;"	s
Dlinemethod::Dlinemethod	minimizer/cg.hpp	/^	Dlinemethod(T &funcc, const Doub& _ftol) : func(funcc), ftol(_ftol) {}$/;"	f	struct:Dlinemethod	access:public
Dlinemethod::ax	minimizer/cg.hpp	/^		Doub ax,xx,xmin;$/;"	l
Dlinemethod::bracket	minimizer/cg.hpp	/^		dbrent.bracket(ax,xx,df1dim);$/;"	p
Dlinemethod::dbrent	minimizer/cg.hpp	/^		Dbrent dbrent(ftol);$/;"	p
Dlinemethod::df1dim	minimizer/cg.hpp	/^		Df1dim<T> df1dim(p,xi,func);$/;"	p
Dlinemethod::ftol	minimizer/cg.hpp	/^	const Doub ftol;$/;"	m	struct:Dlinemethod	access:public
Dlinemethod::func	minimizer/cg.hpp	/^	T &func;$/;"	m	struct:Dlinemethod	access:public
Dlinemethod::linmin	minimizer/cg.hpp	/^	Doub linmin()$/;"	f	struct:Dlinemethod	access:public
Dlinemethod::n	minimizer/cg.hpp	/^	Int n;$/;"	m	struct:Dlinemethod	access:public
Dlinemethod::p	minimizer/cg.hpp	/^	VecDoub p;$/;"	m	struct:Dlinemethod	access:public
Dlinemethod::xi	minimizer/cg.hpp	/^	VecDoub xi;$/;"	m	struct:Dlinemethod	access:public
Dlinemethod::xmin	minimizer/cg.hpp	/^		Doub ax,xx,xmin;$/;"	l
Dlinemethod::xx	minimizer/cg.hpp	/^		Doub ax,xx,xmin;$/;"	l
Doub	minimizer/cg.hpp	/^typedef valtype Doub; \/\/ default floating type$/;"	t
E	mc.hpp	/^	const valtype E = U(coord) + V(coord);$/;"	l
ENSEMBLE_FACTORY_HPP	ensemble_factory.hpp	/^#define ENSEMBLE_FACTORY_HPP$/;"	d
ENSEMBLE_HPP	ensemble.hpp	/^#define ENSEMBLE_HPP$/;"	d
EPS	minimizer/cg.hpp	/^		const Doub EPS=numeric_limits<Doub>::epsilon();$/;"	l
EPS	ran2.c	/^#define EPS /;"	d	file:
EPS	ran2.c	/^#undef EPS$/;"	d	file:
EXCEPTION_HPP	exception.hpp	/^#define EXCEPTION_HPP$/;"	d
Edge	likelihoodfunc.hpp	/^    typedef array<Node, 2> Edge;$/;"	t	class:ftree	access:public
Edges	likelihoodfunc.hpp	/^    typedef vector<Edge> Edges;$/;"	t	class:ftree	access:private
Ensemble	ensemble.cpp	/^Ensemble::Ensemble():$/;"	f	class:Ensemble
Ensemble	ensemble.cpp	/^Ensemble::Ensemble(const Ensemble& src) :$/;"	f	class:Ensemble
Ensemble	ensemble.cpp	/^Ensemble::Ensemble(const valtype _kB):$/;"	f	class:Ensemble
Ensemble	ensemble.hpp	/^    Ensemble();$/;"	p	class:Ensemble	access:public
Ensemble	ensemble.hpp	/^    Ensemble(const Ensemble& src);$/;"	p	class:Ensemble	access:public
Ensemble	ensemble.hpp	/^    Ensemble(const valtype _kB);$/;"	p	class:Ensemble	access:public
Ensemble	ensemble.hpp	/^class Ensemble {$/;"	c
Ensemble	typedefs.hpp	/^class Ensemble;$/;"	x
Ensemble::DHamiltonian	ensemble.hpp	/^    enum Qt {DHamiltonian, DTemperature, DPressure};$/;"	e	enum:Ensemble::Qt
Ensemble::DPressure	ensemble.hpp	/^    enum Qt {DHamiltonian, DTemperature, DPressure};$/;"	e	enum:Ensemble::Qt
Ensemble::DTemperature	ensemble.hpp	/^    enum Qt {DHamiltonian, DTemperature, DPressure};$/;"	e	enum:Ensemble::Qt
Ensemble::Ensemble	ensemble.cpp	/^Ensemble::Ensemble():$/;"	f	class:Ensemble
Ensemble::Ensemble	ensemble.cpp	/^Ensemble::Ensemble(const Ensemble& src) :$/;"	f	class:Ensemble
Ensemble::Ensemble	ensemble.cpp	/^Ensemble::Ensemble(const valtype _kB):$/;"	f	class:Ensemble
Ensemble::Ensemble	ensemble.hpp	/^    Ensemble();$/;"	p	class:Ensemble	access:public
Ensemble::Ensemble	ensemble.hpp	/^    Ensemble(const Ensemble& src);$/;"	p	class:Ensemble	access:public
Ensemble::Ensemble	ensemble.hpp	/^    Ensemble(const valtype _kB);$/;"	p	class:Ensemble	access:public
Ensemble::Qt	ensemble.hpp	/^    enum Qt {DHamiltonian, DTemperature, DPressure};$/;"	g	class:Ensemble	access:public
Ensemble::cmp	ensemble.hpp	/^    virtual uint cmp(const Ensemble& src) const = 0;$/;"	p	class:Ensemble	access:public
Ensemble::ener	ensemble.hpp	/^    virtual valtype ener(const vector<valtype>& vals) const = 0;$/;"	p	class:Ensemble	access:public
Ensemble::getkB	ensemble.hpp	/^    const valtype& getkB() const { return kB; };$/;"	f	class:Ensemble	access:public
Ensemble::kB	ensemble.hpp	/^    const valtype kB; $/;"	m	class:Ensemble	access:protected
Ensemble::operator !=	ensemble.cpp	/^bool Ensemble::operator!=(const Ensemble& src) const {$/;"	f	class:Ensemble
Ensemble::operator !=	ensemble.hpp	/^    virtual bool operator!=(const Ensemble& src) const;$/;"	p	class:Ensemble	access:public
Ensemble::operator ==	ensemble.cpp	/^bool Ensemble::operator==(const Ensemble& src) const {$/;"	f	class:Ensemble
Ensemble::operator ==	ensemble.hpp	/^    virtual bool operator==(const Ensemble& src) const;$/;"	p	class:Ensemble	access:public
Ensemble::~Ensemble	ensemble.hpp	/^    virtual ~Ensemble() {};$/;"	f	class:Ensemble	access:public
Ensemble_Factory_Exception	exception.hpp	/^    Ensemble_Factory_Exception(const string& _msg) : General_Exception("Ensemble Factory exception: " + _msg) {};$/;"	f	class:Ensemble_Factory_Exception	access:public
Ensemble_Factory_Exception	exception.hpp	/^class Ensemble_Factory_Exception : public General_Exception {$/;"	c	inherits:General_Exception
Ensemble_Factory_Exception::Ensemble_Factory_Exception	exception.hpp	/^    Ensemble_Factory_Exception(const string& _msg) : General_Exception("Ensemble Factory exception: " + _msg) {};$/;"	f	class:Ensemble_Factory_Exception	access:public
Expanded	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	e	enum:GMXMDP::FEPType
Extract_Indices	metaprog_snippets.hpp	/^struct Extract_Indices< I<indices...>, I<>, I<output...> >  {$/;"	s
Extract_Indices	metaprog_snippets.hpp	/^struct Extract_Indices< I<indices...>, I<id1, subsetids...>, I<output...> >  {$/;"	s
Extract_Indices	metaprog_snippets.hpp	/^template < class Superset, class SubsetIDs, class Output  > struct Extract_Indices{};$/;"	s
Extract_Indices::Superset	metaprog_snippets.hpp	/^  typedef I<indices...> Superset;$/;"	t	struct:Extract_Indices	access:public
Extract_Indices::newelement	metaprog_snippets.hpp	/^  constexpr static size_t newelement = Extract_One_Index<Superset, id1>::value;$/;"	m	struct:Extract_Indices	access:public
Extract_Indices::type	metaprog_snippets.hpp	/^  typedef I<output...> type;  $/;"	t	struct:Extract_Indices	access:public
Extract_Indices::type	metaprog_snippets.hpp	/^  typedef typename Extract_Indices<Superset, I<subsetids...>, I<output..., newelement> >::type type;  $/;"	t	struct:Extract_Indices	access:public
Extract_One_Index	metaprog_snippets.hpp	/^struct Extract_One_Index<I<n, indices...>, 1> {$/;"	s
Extract_One_Index	metaprog_snippets.hpp	/^struct Extract_One_Index<I<n, indices...>, N> {$/;"	s
Extract_One_Index	metaprog_snippets.hpp	/^template < class Superset, size_t N > struct Extract_One_Index{};$/;"	s
Extract_One_Index::value	metaprog_snippets.hpp	/^  constexpr static size_t value = Extract_One_Index<I<indices...>, N-1>::value;$/;"	m	struct:Extract_One_Index	access:public
Extract_One_Index::value	metaprog_snippets.hpp	/^  constexpr static size_t value = n;$/;"	m	struct:Extract_One_Index	access:public
Extract_One_Type	metaprog_snippets.hpp	/^struct Extract_One_Type<1, T1, T...> {$/;"	s
Extract_One_Type	metaprog_snippets.hpp	/^struct Extract_One_Type<1> {$/;"	s
Extract_One_Type	metaprog_snippets.hpp	/^struct Extract_One_Type<N, T1, T...> {$/;"	s
Extract_One_Type	metaprog_snippets.hpp	/^template < size_t N, class ... T > struct Extract_One_Type {$/;"	s
Extract_One_Type::NextIteration	metaprog_snippets.hpp	/^  typedef Extract_One_Type<N-1, T...> NextIteration;$/;"	t	struct:Extract_One_Type	access:public
Extract_One_Type::get	metaprog_snippets.hpp	/^  static inline const type& get(const T1& a, const T&...) {$/;"	f	struct:Extract_One_Type	access:public
Extract_One_Type::get	metaprog_snippets.hpp	/^  static inline const type& get(const T1&, const T&...args) {$/;"	f	struct:Extract_One_Type	access:public
Extract_One_Type::get	metaprog_snippets.hpp	/^  static inline type get() {$/;"	f	struct:Extract_One_Type	access:public
Extract_One_Type::static_assert	metaprog_snippets.hpp	/^  static_assert(N <= sizeof...(T), "Extract_One_Type<T..., N> index out of bound");$/;"	p	struct:Extract_One_Type	access:public
Extract_One_Type::type	metaprog_snippets.hpp	/^  typedef T1 type;$/;"	t	struct:Extract_One_Type	access:public
Extract_One_Type::type	metaprog_snippets.hpp	/^  typedef typename NextIteration::type type;$/;"	t	struct:Extract_One_Type	access:public
Extract_One_Type::type	metaprog_snippets.hpp	/^  typedef void type;$/;"	t	struct:Extract_One_Type	access:public
FEPLambdas	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	g	class:MDP	access:protected
FEPType	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	g	class:GMXMDP	access:public
FILEIO_Exception	exception.hpp	/^    FILEIO_Exception(const string& _msg) : General_Exception("FILEIO exception: " + _msg) {};$/;"	f	class:FILEIO_Exception	access:public
FILEIO_Exception	exception.hpp	/^class FILEIO_Exception : public General_Exception {$/;"	c	inherits:General_Exception
FILEIO_Exception::FILEIO_Exception	exception.hpp	/^    FILEIO_Exception(const string& _msg) : General_Exception("FILEIO exception: " + _msg) {};$/;"	f	class:FILEIO_Exception	access:public
FILEIO_HPP	fileio.hpp	/^#define FILEIO_HPP$/;"	d
FILEIO_UTILS_HPP	fileio_utils.hpp	/^#define FILEIO_UTILS_HPP$/;"	d
FUNC	gwham.hpp	/^    typedef LikeliHoodFunc<DOStype, NARRAY, ftree<valtype>> FUNC;$/;"	t
FUNCTOR_HPP	functor.hpp	/^#define FUNCTOR_HPP$/;"	d
Fibonacci	metaprog_snippets.hpp	/^struct Fibonacci<I<1>, I<> > {$/;"	s
Fibonacci	metaprog_snippets.hpp	/^struct Fibonacci<I<>, I<> > {$/;"	s
Fibonacci	metaprog_snippets.hpp	/^struct Fibonacci<I<indices...>, I<Ni,Nj> > {$/;"	s
Fibonacci	metaprog_snippets.hpp	/^template < class T, class Arg > struct Fibonacci{};$/;"	s
Fibonacci::Indices	metaprog_snippets.hpp	/^  typedef I<indices...> Indices;$/;"	t	struct:Fibonacci	access:public
Fibonacci::seed	metaprog_snippets.hpp	/^  typedef I<1, 2> seed;$/;"	t	struct:Fibonacci	access:public
Fibonacci::seed	metaprog_snippets.hpp	/^  typedef I<Nj, Ni+Nj> seed; $/;"	t	struct:Fibonacci	access:public
Fibonacci::type	metaprog_snippets.hpp	/^  typedef I<indices..., Ni+Nj> type;$/;"	t	struct:Fibonacci	access:public
Fibonacci::type	metaprog_snippets.hpp	/^  typedef typename Fibonacci<I<1, 1>, I<1,1> >::type type;$/;"	t	struct:Fibonacci	access:public
File naming convention	doc/tex/usage.tex	/^\\subsubsection{File naming convention}\\label{sec:fname}$/;"	b
FormatStream	metaprog_snippets.hpp	/^    FormatStream(S& _stream) : FormatStream(_stream, 0, 6) {};$/;"	f	class:FormatStream	access:public
FormatStream	metaprog_snippets.hpp	/^    FormatStream(S& _stream, const uint& _width, const uint& _precision) :$/;"	f	class:FormatStream	access:public
FormatStream	metaprog_snippets.hpp	/^class FormatStream {$/;"	c
FormatStream::FormatStream	metaprog_snippets.hpp	/^    FormatStream(S& _stream) : FormatStream(_stream, 0, 6) {};$/;"	f	class:FormatStream	access:public
FormatStream::FormatStream	metaprog_snippets.hpp	/^    FormatStream(S& _stream, const uint& _width, const uint& _precision) :$/;"	f	class:FormatStream	access:public
FormatStream::f	metaprog_snippets.hpp	/^    ThisType& operator<< (S& (*f)(S&)) {$/;"	f	class:FormatStream	access:public
FormatStream::flags	metaprog_snippets.hpp	/^    void flags(const F& flags) { stream.flags(flags); }$/;"	f	class:FormatStream	access:public
FormatStream::flags	metaprog_snippets.hpp	/^    void flags(const F& flags) { stream.flags(flags); }$/;"	p
FormatStream::get	metaprog_snippets.hpp	/^      *this << input.get();$/;"	p
FormatStream::input	metaprog_snippets.hpp	/^      stream << input;$/;"	l
FormatStream::operator <<	metaprog_snippets.hpp	/^    ThisType& operator<< (const std::string& input) {$/;"	f	class:FormatStream	access:public
FormatStream::operator <<	metaprog_snippets.hpp	/^    operator<< (const T& input) {$/;"	f	class:FormatStream	access:public
FormatStream::prec	metaprog_snippets.hpp	/^    uint prec;$/;"	m	class:FormatStream	access:private
FormatStream::precision	metaprog_snippets.hpp	/^      stream.precision(prec);$/;"	p
FormatStream::precision	metaprog_snippets.hpp	/^    void precision(const uint _precision) { prec = _precision; }$/;"	f	class:FormatStream	access:public
FormatStream::stream	metaprog_snippets.hpp	/^    S& stream;$/;"	m	class:FormatStream	access:private
FormatStream::w	metaprog_snippets.hpp	/^    uint w;$/;"	m	class:FormatStream	access:private
FormatStream::width	metaprog_snippets.hpp	/^      stream.width(w);$/;"	p
FormatStream::width	metaprog_snippets.hpp	/^    void width(const uint _width) { w = _width; }$/;"	f	class:FormatStream	access:public
Frprmn	minimizer/cg.hpp	/^	Frprmn(T &funcd, const Doub ftoll=3.0e-8) : Dlinemethod<T>(funcd, ftoll) {};$/;"	f	struct:Frprmn	access:public
Frprmn	minimizer/cg.hpp	/^struct Frprmn : Dlinemethod<T> {$/;"	s	inherits:Dlinemethod
Frprmn::EPS	minimizer/cg.hpp	/^		const Doub EPS=numeric_limits<Doub>::epsilon();$/;"	l
Frprmn::Frprmn	minimizer/cg.hpp	/^	Frprmn(T &funcd, const Doub ftoll=3.0e-8) : Dlinemethod<T>(funcd, ftoll) {};$/;"	f	struct:Frprmn	access:public
Frprmn::GTOL	minimizer/cg.hpp	/^		const Doub GTOL=ftol;$/;"	l
Frprmn::ITMAX	minimizer/cg.hpp	/^		const Int ITMAX=2000000000;$/;"	l
Frprmn::den	minimizer/cg.hpp	/^			Doub den=MAX(fp, Doub{1.0});$/;"	l
Frprmn::df	minimizer/cg.hpp	/^			func.df(p,xi);$/;"	p
Frprmn::df	minimizer/cg.hpp	/^		func.df(p,xi);$/;"	p
Frprmn::dgg	minimizer/cg.hpp	/^		Doub gg,dgg;$/;"	l
Frprmn::endl	minimizer/cg.hpp	/^			  cout << "#Convergence met at iteration " << its << " because gradient is smaller than " << GTOL << endl;$/;"	l
Frprmn::endl	minimizer/cg.hpp	/^			  cout << "#Convergence met at iteration " << its << " because the relative difference in F(p) between 2 consecutive iteration is smaller than " << scientific << ftol << endl;$/;"	l
Frprmn::endl	minimizer/cg.hpp	/^			  cout << "#Convergence met at iteration " << its << " because the search direction vector is exactly zero" << endl;$/;"	l
Frprmn::endl	minimizer/cg.hpp	/^			  for(uint i = 0; i < p.size(); ++i) cout << "#\\t" << i << "\\t" << p[i] << endl;$/;"	l
Frprmn::flush	minimizer/cg.hpp	/^			  cout.flush();$/;"	p
Frprmn::fp	minimizer/cg.hpp	/^		Doub fp=func(p);$/;"	l
Frprmn::fret	minimizer/cg.hpp	/^	Doub fret;$/;"	m	struct:Frprmn	access:public
Frprmn::g	minimizer/cg.hpp	/^		VecDoub g(n),h(n);$/;"	p
Frprmn::gam	minimizer/cg.hpp	/^			Doub gam=dgg\/gg;$/;"	l
Frprmn::gg	minimizer/cg.hpp	/^		Doub gg,dgg;$/;"	l
Frprmn::h	minimizer/cg.hpp	/^		VecDoub g(n),h(n);$/;"	p
Frprmn::iter	minimizer/cg.hpp	/^	Int iter;$/;"	m	struct:Frprmn	access:public
Frprmn::its	minimizer/cg.hpp	/^			  cout << "#At iteration: " << its << " states are:\\n";$/;"	l
Frprmn::minimize	minimizer/cg.hpp	/^	VecDoub minimize(VecDoub_I &pp)$/;"	f	struct:Frprmn	access:public
Frprmn::n	minimizer/cg.hpp	/^		Int n=pp.size();$/;"	l
Frprmn::precision	minimizer/cg.hpp	/^			  cout.precision(VALMAXDIGITS10); $/;"	p
Frprmn::precision	minimizer/cg.hpp	/^			  cout.precision(VALMAXDIGITS10);$/;"	p
Frprmn::resize	minimizer/cg.hpp	/^		xi.resize(n);$/;"	p
Frprmn::temp	minimizer/cg.hpp	/^				Doub temp=abs(xi[j])*MAX(abs(p[j]),Doub{1.0})\/den;$/;"	l
Frprmn::test	minimizer/cg.hpp	/^			Doub test=0.0;$/;"	l
FunctVV	typedefs.hpp	/^typedef Functor<const function<valtype(const valtype&)>, const vector<valtype>, const void> FunctVV;$/;"	t
Functor	functor.hpp	/^    Functor (Tf _funct, Params... params, cpTo _pobj=nullptr) : Functor(forward<Tf>(_funct), Tp{forward<Params>(params)...}, _pobj) {};$/;"	f	class:Functor	access:public
Functor	functor.hpp	/^    Functor (Tf _funct, Tp _params, cpTo _pobj=nullptr) : $/;"	f	class:Functor	access:public
Functor	functor.hpp	/^    Functor (Tf _funct, initializer_list<ParamsContained> lparam, cpTo _pobj=nullptr) : Functor(forward<Tf>(_funct), Tp{lparam}, _pobj) {};$/;"	f	class:Functor	access:public
Functor	functor.hpp	/^    Functor (const ThisType& src) : Functor(src.funct, src.getParams(), src.getpobj()) {};$/;"	f	class:Functor	access:public
Functor	functor.hpp	/^    Functor() : Functor(Tf{}, Tp{}) {};$/;"	f	class:Functor	access:public
Functor	functor.hpp	/^class Functor < $/;"	c
Functor	functor.hpp	/^template < class ... T > class Functor; $/;"	x
Functor::Functor	functor.hpp	/^    Functor (Tf _funct, Params... params, cpTo _pobj=nullptr) : Functor(forward<Tf>(_funct), Tp{forward<Params>(params)...}, _pobj) {};$/;"	f	class:Functor	access:public
Functor::Functor	functor.hpp	/^    Functor (Tf _funct, Tp _params, cpTo _pobj=nullptr) : $/;"	f	class:Functor	access:public
Functor::Functor	functor.hpp	/^    Functor (Tf _funct, initializer_list<ParamsContained> lparam, cpTo _pobj=nullptr) : Functor(forward<Tf>(_funct), Tp{lparam}, _pobj) {};$/;"	f	class:Functor	access:public
Functor::Functor	functor.hpp	/^    Functor (const ThisType& src) : Functor(src.funct, src.getParams(), src.getpobj()) {};$/;"	f	class:Functor	access:public
Functor::Functor	functor.hpp	/^    Functor() : Functor(Tf{}, Tp{}) {};$/;"	f	class:Functor	access:public
Functor::Tf	functor.hpp	/^    typedef const Funct<Output(Arg...)> Tf;$/;"	t	class:Functor	access:public
Functor::ThisType	functor.hpp	/^    typedef Functor<Tf, Tp, To, Params...> ThisType;$/;"	t	class:Functor	access:public
Functor::To	functor.hpp	/^    typedef const Tobj To;$/;"	t	class:Functor	access:public
Functor::Tp	functor.hpp	/^    typedef const ParamsContainer<ParamsContained, ParamsContainerOther...> Tp;$/;"	t	class:Functor	access:public
Functor::cpTo	functor.hpp	/^    typedef const To* const cpTo;$/;"	t	class:Functor	access:public
Functor::funct	functor.hpp	/^    Tf funct;$/;"	m	class:Functor	access:protected
Functor::getParams	functor.hpp	/^    Tp& getParams() const { return params; };$/;"	f	class:Functor	access:public
Functor::getpobj	functor.hpp	/^    cpTo& getpobj() const { return pobj; };$/;"	f	class:Functor	access:public
Functor::operator !=	functor.hpp	/^    bool operator!=(const ThisType& rhs) const { return !((*this)==rhs); }$/;"	f	class:Functor	access:public
Functor::operator ()	functor.hpp	/^    Output operator()(Arg... arg) const { return funct(forward<Arg...>(arg...)); };$/;"	f	class:Functor	access:public
Functor::operator ==	functor.hpp	/^    bool operator==(const ThisType& rhs) const { return this == &rhs || (this->params == rhs.getParams() && this->pobj == rhs.getpobj()); }$/;"	f	class:Functor	access:public
Functor::params	functor.hpp	/^    Tp params;$/;"	m	class:Functor	access:protected
Functor::pobj	functor.hpp	/^    cpTo pobj;$/;"	m	class:Functor	access:protected
Functor_Exception	exception.hpp	/^    Functor_Exception(const string& _msg) : General_Exception("Functor exception: " + _msg) {};  $/;"	f	class:Functor_Exception	access:public
Functor_Exception	exception.hpp	/^class Functor_Exception: public General_Exception {$/;"	c	inherits:General_Exception
Functor_Exception::Functor_Exception	exception.hpp	/^    Functor_Exception(const string& _msg) : General_Exception("Functor exception: " + _msg) {};  $/;"	f	class:Functor_Exception	access:public
GCD	metaprog_snippets.hpp	/^GCD ( T a, T b )$/;"	f
GLIMIT	minimizer/cg.hpp	/^		const Doub GOLD=1.618034,GLIMIT=100.0,TINY=1.0e-8;$/;"	l
GMXMDP	gmxmdp.cpp	/^GMXMDP::GMXMDP(const string& fname) : MDP(fname, 0, BoltzmannkJ), ifinit(this->initopts()) {$/;"	f	class:GMXMDP
GMXMDP	gmxmdp.hpp	/^    GMXMDP (const string& fname);    \/* constructor *\/$/;"	p	class:GMXMDP	access:public
GMXMDP	gmxmdp.hpp	/^class GMXMDP : public MDP$/;"	c	inherits:MDP
GMXMDP::ConstantForce	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
GMXMDP::Constraint	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
GMXMDP::Contact	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
GMXMDP::CreateMDP	gmxmdp.hpp	/^    static pMDP CreateMDP(const string& fname) {$/;"	f	class:GMXMDP	access:public
GMXMDP::CreateTimeSeries	gmxmdp.cpp	/^vector<TimeSeries<valtype>> GMXMDP::CreateTimeSeries(const bool& requirepot) const {$/;"	f	class:GMXMDP
GMXMDP::CreateTimeSeries	gmxmdp.hpp	/^    virtual vector<TimeSeries<valtype>> CreateTimeSeries(const bool& requirepot) const;$/;"	p	class:GMXMDP	access:public
GMXMDP::Cylinder	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
GMXMDP::Direction	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
GMXMDP::DirectionPeriodic	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
GMXMDP::Distance	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
GMXMDP::Expanded	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	e	enum:GMXMDP::FEPType
GMXMDP::FEPType	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	g	class:GMXMDP	access:public
GMXMDP::GMXMDP	gmxmdp.cpp	/^GMXMDP::GMXMDP(const string& fname) : MDP(fname, 0, BoltzmannkJ), ifinit(this->initopts()) {$/;"	f	class:GMXMDP
GMXMDP::GMXMDP	gmxmdp.hpp	/^    GMXMDP (const string& fname);    \/* constructor *\/$/;"	p	class:GMXMDP	access:public
GMXMDP::GMXPGRP	gmxmdp.hpp	/^    class GMXPGRP;$/;"	x
GMXMDP::GMXPGRP	gmxmdp.hpp	/^class GMXMDP::GMXPGRP {$/;"	c	class:GMXMDP
GMXMDP::GMXPGRP::GMXPGRP	gmxmdp.hpp	/^  GMXPGRP(const GMXPGRP& src) :$/;"	f	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::GMXPGRP	gmxmdp.hpp	/^  GMXPGRP(const uint& _gid) : $/;"	f	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::Lrst	gmxmdp.hpp	/^  vector<valtype> Lrst;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::NRestraintTypes	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	e	enum:GMXMDP::GMXPGRP::RestraintType
GMXMDP::GMXPGRP::Quad	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	e	enum:GMXMDP::GMXPGRP::RestraintType
GMXMDP::GMXPGRP::QuadFlat	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	e	enum:GMXMDP::GMXPGRP::RestraintType
GMXMDP::GMXPGRP::RestraintType	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	g	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::clear	gmxmdp.hpp	/^    rstfuncts.clear();$/;"	p
GMXMDP::GMXPGRP::emplace_back	gmxmdp.hpp	/^      rstfuncts.emplace_back(rstfunct);$/;"	p
GMXMDP::GMXPGRP::gid	gmxmdp.hpp	/^  uint gid;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::gidstr	gmxmdp.hpp	/^  string gidstr;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::ifinit	gmxmdp.hpp	/^  const bool ifinit;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::initopts	gmxmdp.hpp	/^  bool initopts() {$/;"	f	class:GMXMDP::GMXPGRP	access:private
GMXMDP::GMXPGRP::k	gmxmdp.hpp	/^  valtype k = NaN, kB = k;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::k0	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::k0B	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::k1	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::k1B	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::kB	gmxmdp.hpp	/^  valtype k = NaN, kB = k;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::key2val	gmxmdp.hpp	/^  dblopts key2val; $/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::key2vvec	gmxmdp.hpp	/^  vecopts key2vvec;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::nc0	gmxmdp.hpp	/^  valtype nc0 = NaN, nc0B = NaN;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::nc0B	gmxmdp.hpp	/^  valtype nc0 = NaN, nc0B = NaN;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::operator =	gmxmdp.hpp	/^  GMXPGRP& operator=(const GMXPGRP& src) {$/;"	f	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::r0	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::r0B	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::r1	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::r1B	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::rstT	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	m	class:GMXMDP::GMXPGRP	typeref:enum:GMXMDP::GMXPGRP::RestraintType	access:public
GMXMDP::GMXPGRP::rstfuncts	gmxmdp.hpp	/^  vFunctVV rstfuncts; $/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::GMXPGRP::vec	gmxmdp.hpp	/^  vector<valtype> vec;$/;"	m	class:GMXMDP::GMXPGRP	access:public
GMXMDP::Lcnt1	gmxmdp.hpp	/^    vector<valtype> Lcnt1, Lcnt2, Lcnt3;$/;"	m	class:GMXMDP	access:public
GMXMDP::Lcnt2	gmxmdp.hpp	/^    vector<valtype> Lcnt1, Lcnt2, Lcnt3;$/;"	m	class:GMXMDP	access:public
GMXMDP::Lcnt3	gmxmdp.hpp	/^    vector<valtype> Lcnt1, Lcnt2, Lcnt3;$/;"	m	class:GMXMDP	access:public
GMXMDP::Linit	gmxmdp.hpp	/^    int Linit = -1;$/;"	m	class:GMXMDP	access:public
GMXMDP::NFEPTypes	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	e	enum:GMXMDP::FEPType
GMXMDP::NGeomTypes	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
GMXMDP::NPTypes	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	e	enum:GMXMDP::PType
GMXMDP::NPullTypes	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
GMXMDP::NTTypes	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	e	enum:GMXMDP::TType
GMXMDP::NoFEP	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	e	enum:GMXMDP::FEPType
GMXMDP::NoP	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	e	enum:GMXMDP::PType
GMXMDP::NoPull	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
GMXMDP::NoT	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	e	enum:GMXMDP::TType
GMXMDP::P	gmxmdp.hpp	/^    valtype P = NaN;$/;"	m	class:GMXMDP	access:public
GMXMDP::PT	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::PType	access:public
GMXMDP::PTstr	gmxmdp.hpp	/^    string PTstr = "PTstr";$/;"	m	class:GMXMDP	access:public
GMXMDP::PType	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	g	class:GMXMDP	access:public
GMXMDP::Pmax	gmxmdp.hpp	/^    valtype Pmax = P, Pmin = P;$/;"	m	class:GMXMDP	access:public
GMXMDP::Pmin	gmxmdp.hpp	/^    valtype Pmax = P, Pmin = P;$/;"	m	class:GMXMDP	access:public
GMXMDP::Position	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
GMXMDP::PullGeom	gmxmdp.hpp	/^    enum PullGeom {$/;"	g	class:GMXMDP	access:public
GMXMDP::PullType	gmxmdp.hpp	/^    enum PullType {$/;"	g	class:GMXMDP	access:public
GMXMDP::T	gmxmdp.hpp	/^    valtype T = NaN;$/;"	m	class:GMXMDP	access:public
GMXMDP::TT	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::TType	access:public
GMXMDP::TTstr	gmxmdp.hpp	/^    string TTstr = "TTstr";$/;"	m	class:GMXMDP	access:public
GMXMDP::TType	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	g	class:GMXMDP	access:public
GMXMDP::Tmax	gmxmdp.hpp	/^    valtype Tmax = T, Tmin = T;$/;"	m	class:GMXMDP	access:public
GMXMDP::Tmc	gmxmdp.hpp	/^    valtype Tmc = T;$/;"	m	class:GMXMDP	access:public
GMXMDP::Tmin	gmxmdp.hpp	/^    valtype Tmax = T, Tmin = T;$/;"	m	class:GMXMDP	access:public
GMXMDP::Umbrella	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
GMXMDP::UmbrellaFlatBottom	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
GMXMDP::Yes	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	e	enum:GMXMDP::FEPType
GMXMDP::YesP	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	e	enum:GMXMDP::PType
GMXMDP::YesT	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	e	enum:GMXMDP::TType
GMXMDP::checkfep	gmxmdp.cpp	/^void GMXMDP::checkfep() {$/;"	f	class:GMXMDP
GMXMDP::checkfep	gmxmdp.hpp	/^    void checkfep();$/;"	p	class:GMXMDP	access:private
GMXMDP::checkgeneric	gmxmdp.cpp	/^void GMXMDP::checkgeneric() {$/;"	f	class:GMXMDP
GMXMDP::checkgeneric	gmxmdp.hpp	/^    void checkgeneric();$/;"	p	class:GMXMDP	access:private
GMXMDP::checkpull	gmxmdp.cpp	/^void GMXMDP::checkpull() {$/;"	f	class:GMXMDP
GMXMDP::checkpull	gmxmdp.hpp	/^    void checkpull();$/;"	p	class:GMXMDP	access:private
GMXMDP::dblopts	gmxmdp.hpp	/^    typedef map<string, valref> dblopts;$/;"	t	class:GMXMDP	access:public
GMXMDP::dim	gmxmdp.hpp	/^    int dim = 0;$/;"	m	class:GMXMDP	access:public
GMXMDP::dimstr	gmxmdp.hpp	/^    vector<string> dimstr;$/;"	m	class:GMXMDP	access:public
GMXMDP::doublechk	gmxmdp.cpp	/^void GMXMDP::doublechk() {$/;"	f	class:GMXMDP
GMXMDP::doublechk	gmxmdp.hpp	/^    virtual void doublechk();$/;"	p	class:GMXMDP	access:private
GMXMDP::expandpgrps	gmxmdp.cpp	/^void GMXMDP::expandpgrps() {$/;"	f	class:GMXMDP
GMXMDP::expandpgrps	gmxmdp.hpp	/^    void expandpgrps();$/;"	p	class:GMXMDP	access:private
GMXMDP::fepT	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::FEPType	access:public
GMXMDP::fepTstr	gmxmdp.hpp	/^    string fepTstr = "fepTstr";$/;"	m	class:GMXMDP	access:public
GMXMDP::geomT	gmxmdp.hpp	/^    } geomT = NGeomTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::PullGeom	access:public
GMXMDP::geomTstr	gmxmdp.hpp	/^    string geomTstr = "geomTstr";$/;"	m	class:GMXMDP	access:public
GMXMDP::getlambdas	gmxmdp.cpp	/^vector<valtype> GMXMDP::getlambdas() const {$/;"	f	class:GMXMDP
GMXMDP::getlambdas	gmxmdp.hpp	/^    virtual vector<valtype> getlambdas() const;$/;"	p	class:GMXMDP	access:public
GMXMDP::ifinit	gmxmdp.hpp	/^    const bool ifinit;$/;"	m	class:GMXMDP	access:public
GMXMDP::initopts	gmxmdp.hpp	/^    bool initopts() {$/;"	f	class:GMXMDP	access:private
GMXMDP::intopts	gmxmdp.hpp	/^    typedef map<string, intref> intopts;$/;"	t	class:GMXMDP	access:public
GMXMDP::intref	gmxmdp.hpp	/^    typedef rw<int> intref;$/;"	t	class:GMXMDP	access:public
GMXMDP::key2int	gmxmdp.hpp	/^    intopts key2int;$/;"	m	class:GMXMDP	access:public
GMXMDP::key2str	gmxmdp.hpp	/^    stropts key2str; $/;"	m	class:GMXMDP	access:public
GMXMDP::key2val	gmxmdp.hpp	/^    dblopts key2val;  $/;"	m	class:GMXMDP	access:public
GMXMDP::key2vecstr	gmxmdp.hpp	/^    vecstropts key2vecstr;$/;"	m	class:GMXMDP	access:public
GMXMDP::key2vvec	gmxmdp.hpp	/^    vecopts key2vvec;$/;"	m	class:GMXMDP	access:public
GMXMDP::ncntgrps	gmxmdp.hpp	/^    int ncntgrps = -1;$/;"	m	class:GMXMDP	access:public
GMXMDP::npgrps	gmxmdp.hpp	/^    int npgrps = -1;$/;"	m	class:GMXMDP	access:public
GMXMDP::nstdhdl	gmxmdp.hpp	/^    int nstdhdl = 100;$/;"	m	class:GMXMDP	access:public
GMXMDP::nstenergy	gmxmdp.hpp	/^    int nstenergy = 1000;$/;"	m	class:GMXMDP	access:public
GMXMDP::nstexpanded	gmxmdp.hpp	/^    int nstexpanded = -1;$/;"	m	class:GMXMDP	access:public
GMXMDP::nstf	gmxmdp.hpp	/^    int nstf = 1;$/;"	m	class:GMXMDP	access:public
GMXMDP::nstx	gmxmdp.hpp	/^    int nstx = 10;$/;"	m	class:GMXMDP	access:public
GMXMDP::pgrps	gmxmdp.hpp	/^    vector<GMXPGRP> pgrps;$/;"	m	class:GMXMDP	access:public
GMXMDP::print	gmxmdp.cpp	/^void GMXMDP::print() const {$/;"	f	class:GMXMDP
GMXMDP::print	gmxmdp.hpp	/^    virtual void print() const; $/;"	p	class:GMXMDP	access:public
GMXMDP::pullT	gmxmdp.hpp	/^    } pullT = NPullTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::PullType	access:public
GMXMDP::pullTstr	gmxmdp.hpp	/^    string pullTstr = "pullTstr";$/;"	m	class:GMXMDP	access:public
GMXMDP::setAB	gmxmdp.cpp	/^void GMXMDP::setAB() {$/;"	f	class:GMXMDP
GMXMDP::setAB	gmxmdp.hpp	/^    void setAB();$/;"	p	class:GMXMDP	access:private
GMXMDP::setLs	gmxmdp.cpp	/^void GMXMDP::setLs() {$/;"	f	class:GMXMDP
GMXMDP::setLs	gmxmdp.hpp	/^    virtual void setLs();$/;"	p	class:GMXMDP	access:private
GMXMDP::setcntgrp	gmxmdp.hpp	/^    void setcntgrp();$/;"	p	class:GMXMDP	access:private
GMXMDP::setenum	gmxmdp.cpp	/^void GMXMDP::setenum() {$/;"	f	class:GMXMDP
GMXMDP::setenum	gmxmdp.hpp	/^    void setenum();$/;"	p	class:GMXMDP	access:private
GMXMDP::setexpand	gmxmdp.cpp	/^void GMXMDP::setexpand() {$/;"	f	class:GMXMDP
GMXMDP::setexpand	gmxmdp.hpp	/^    virtual void setexpand();$/;"	p	class:GMXMDP	access:private
GMXMDP::setmask	gmxmdp.cpp	/^void GMXMDP::setmask() {$/;"	f	class:GMXMDP
GMXMDP::setmask	gmxmdp.hpp	/^    void setmask();$/;"	p	class:GMXMDP	access:private
GMXMDP::setpgrpLrst	gmxmdp.cpp	/^void GMXMDP::setpgrpLrst() {$/;"	f	class:GMXMDP
GMXMDP::setpgrpLrst	gmxmdp.hpp	/^    void setpgrpLrst();$/;"	p	class:GMXMDP	access:private
GMXMDP::setpgrprstfuncts	gmxmdp.cpp	/^void GMXMDP::setpgrprstfuncts() {$/;"	f	class:GMXMDP
GMXMDP::setpgrprstfuncts	gmxmdp.hpp	/^    void setpgrprstfuncts();$/;"	p	class:GMXMDP	access:private
GMXMDP::setpgrps	gmxmdp.cpp	/^void GMXMDP::setpgrps() {$/;"	f	class:GMXMDP
GMXMDP::setpgrps	gmxmdp.hpp	/^    void setpgrps();$/;"	p	class:GMXMDP	access:private
GMXMDP::str2PT	gmxmdp.cpp	/^const map<string, GMXMDP::PType> GMXMDP::str2PT =$/;"	m	class:GMXMDP	file:
GMXMDP::str2PT	gmxmdp.hpp	/^    static const map<string, PType> str2PT; $/;"	m	class:GMXMDP	access:public
GMXMDP::str2TT	gmxmdp.cpp	/^const map<string, GMXMDP::TType> GMXMDP::str2TT =$/;"	m	class:GMXMDP	file:
GMXMDP::str2TT	gmxmdp.hpp	/^    static const map<string, TType> str2TT; $/;"	m	class:GMXMDP	access:public
GMXMDP::str2dim	gmxmdp.cpp	/^const map<string, bool> GMXMDP::str2dim = $/;"	m	class:GMXMDP	file:
GMXMDP::str2dim	gmxmdp.hpp	/^    static const map<string, bool> str2dim;$/;"	m	class:GMXMDP	access:public
GMXMDP::str2fepT	gmxmdp.cpp	/^const map<string, GMXMDP::FEPType> GMXMDP::str2fepT = $/;"	m	class:GMXMDP	file:
GMXMDP::str2fepT	gmxmdp.hpp	/^    static const map<string, FEPType> str2fepT; $/;"	m	class:GMXMDP	access:public
GMXMDP::str2geomT	gmxmdp.cpp	/^const map<string, GMXMDP::PullGeom> GMXMDP::str2geomT = $/;"	m	class:GMXMDP	file:
GMXMDP::str2geomT	gmxmdp.hpp	/^    static const map<string, PullGeom> str2geomT;$/;"	m	class:GMXMDP	access:public
GMXMDP::str2pullT	gmxmdp.cpp	/^const map<string, GMXMDP::PullType> GMXMDP::str2pullT = $/;"	m	class:GMXMDP	file:
GMXMDP::str2pullT	gmxmdp.hpp	/^    static const map<string, PullType> str2pullT; $/;"	m	class:GMXMDP	access:public
GMXMDP::stropts	gmxmdp.hpp	/^    typedef map<string, strref> stropts;$/;"	t	class:GMXMDP	access:public
GMXMDP::strref	gmxmdp.hpp	/^    typedef rw<string> strref;$/;"	t	class:GMXMDP	access:public
GMXMDP::valref	gmxmdp.hpp	/^    typedef rw<valtype> valref;$/;"	t	class:GMXMDP	access:public
GMXMDP::vecopts	gmxmdp.hpp	/^    typedef map<string, vvref> vecopts;$/;"	t	class:GMXMDP	access:public
GMXMDP::vecstropts	gmxmdp.hpp	/^    typedef map<string, vsref> vecstropts;$/;"	t	class:GMXMDP	access:public
GMXMDP::vsref	gmxmdp.hpp	/^    typedef rw<vector<string> > vsref;$/;"	t	class:GMXMDP	access:public
GMXMDP::vvref	gmxmdp.hpp	/^    typedef rw<vector<valtype> > vvref;$/;"	t	class:GMXMDP	access:public
GMXMDP_HPP	gmxmdp.hpp	/^#define GMXMDP_HPP$/;"	d
GMXPGRP	gmxmdp.hpp	/^    class GMXPGRP;$/;"	x
GMXPGRP	gmxmdp.hpp	/^  GMXPGRP(const GMXPGRP& src) :$/;"	f	class:GMXMDP::GMXPGRP	access:public
GMXPGRP	gmxmdp.hpp	/^  GMXPGRP(const uint& _gid) : $/;"	f	class:GMXMDP::GMXPGRP	access:public
GMXPGRP	gmxmdp.hpp	/^class GMXMDP::GMXPGRP {$/;"	c	class:GMXMDP
GNARRAY_HPP	gnarray.hpp	/^#define GNARRAY_HPP$/;"	d
GOLD	minimizer/cg.hpp	/^		const Doub GOLD=1.618034,GLIMIT=100.0,TINY=1.0e-8;$/;"	l
GTOL	minimizer/cg.hpp	/^		const Doub GTOL=ftol;$/;"	l
GWHAM_Exception	exception.hpp	/^    GWHAM_Exception(const string& _msg) : General_Exception("GWHAM exception: " + _msg) {};$/;"	f	class:GWHAM_Exception	access:public
GWHAM_Exception	exception.hpp	/^class GWHAM_Exception : public General_Exception {$/;"	c	inherits:General_Exception
GWHAM_Exception::GWHAM_Exception	exception.hpp	/^    GWHAM_Exception(const string& _msg) : General_Exception("GWHAM exception: " + _msg) {};$/;"	f	class:GWHAM_Exception	access:public
GWHAM_HPP	gwham.hpp	/^#define GWHAM_HPP$/;"	d
General_Exception	exception.hpp	/^    explicit General_Exception() : msg("genearl execption") {};$/;"	f	class:General_Exception	access:public
General_Exception	exception.hpp	/^    explicit General_Exception(const int& _errno) : msg("general exception " + string(strerror(_errno))) {};$/;"	f	class:General_Exception	access:public
General_Exception	exception.hpp	/^    explicit General_Exception(const string& _msg) : msg(_msg) {};$/;"	f	class:General_Exception	access:public
General_Exception	exception.hpp	/^    explicit General_Exception(const string& _msg, const int& _errno) : msg(_msg + " " + string(strerror(_errno))) {};$/;"	f	class:General_Exception	access:public
General_Exception	exception.hpp	/^class General_Exception : public std::exception {$/;"	c	inherits:std::exception
General_Exception::General_Exception	exception.hpp	/^    explicit General_Exception() : msg("genearl execption") {};$/;"	f	class:General_Exception	access:public
General_Exception::General_Exception	exception.hpp	/^    explicit General_Exception(const int& _errno) : msg("general exception " + string(strerror(_errno))) {};$/;"	f	class:General_Exception	access:public
General_Exception::General_Exception	exception.hpp	/^    explicit General_Exception(const string& _msg) : msg(_msg) {};$/;"	f	class:General_Exception	access:public
General_Exception::General_Exception	exception.hpp	/^    explicit General_Exception(const string& _msg, const int& _errno) : msg(_msg + " " + string(strerror(_errno))) {};$/;"	f	class:General_Exception	access:public
General_Exception::append	exception.hpp	/^    void append(const string& addmsg) { msg += addmsg; }$/;"	f	class:General_Exception	access:public
General_Exception::msg	exception.hpp	/^    string msg;$/;"	m	class:General_Exception	access:protected
General_Exception::prepend	exception.hpp	/^    void prepend(const string& addmsg) { msg = addmsg + msg; }$/;"	f	class:General_Exception	access:public
General_Exception::what	exception.hpp	/^    virtual const char* what() const throw() { return msg.c_str(); }$/;"	f	class:General_Exception	access:public
General_Exception::~General_Exception	exception.hpp	/^    virtual ~General_Exception() throw() {};$/;"	f	class:General_Exception	access:public
H	ensemble.hpp	/^    Hamiltonian H; $/;"	m	class:NVE	access:protected
HAMILTONIAN_HPP	hamiltonian.hpp	/^#define HAMILTONIAN_HPP$/;"	d
Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian() :$/;"	f	class:Hamiltonian
Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian(Hamiltonian&& _H) :$/;"	f	class:Hamiltonian
Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian(const Hamiltonian& _H) :$/;"	f	class:Hamiltonian
Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian(const vFunctVV& _potentials) : $/;"	f	class:Hamiltonian
Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian(vFunctVV&& _potentials) :$/;"	f	class:Hamiltonian
Hamiltonian	hamiltonian.hpp	/^    Hamiltonian();$/;"	p	class:Hamiltonian	access:public
Hamiltonian	hamiltonian.hpp	/^    Hamiltonian(Hamiltonian&& _H);$/;"	p	class:Hamiltonian	access:public
Hamiltonian	hamiltonian.hpp	/^    Hamiltonian(const Hamiltonian& _H);$/;"	p	class:Hamiltonian	access:public
Hamiltonian	hamiltonian.hpp	/^    Hamiltonian(const vFunctVV& _potentials);$/;"	p	class:Hamiltonian	access:public
Hamiltonian	hamiltonian.hpp	/^    Hamiltonian(vFunctVV&& _potentials);$/;"	p	class:Hamiltonian	access:public
Hamiltonian	hamiltonian.hpp	/^class Hamiltonian {$/;"	c
Hamiltonian::Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian() :$/;"	f	class:Hamiltonian
Hamiltonian::Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian(Hamiltonian&& _H) :$/;"	f	class:Hamiltonian
Hamiltonian::Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian(const Hamiltonian& _H) :$/;"	f	class:Hamiltonian
Hamiltonian::Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian(const vFunctVV& _potentials) : $/;"	f	class:Hamiltonian
Hamiltonian::Hamiltonian	hamiltonian.cpp	/^Hamiltonian::Hamiltonian(vFunctVV&& _potentials) :$/;"	f	class:Hamiltonian
Hamiltonian::Hamiltonian	hamiltonian.hpp	/^    Hamiltonian();$/;"	p	class:Hamiltonian	access:public
Hamiltonian::Hamiltonian	hamiltonian.hpp	/^    Hamiltonian(Hamiltonian&& _H);$/;"	p	class:Hamiltonian	access:public
Hamiltonian::Hamiltonian	hamiltonian.hpp	/^    Hamiltonian(const Hamiltonian& _H);$/;"	p	class:Hamiltonian	access:public
Hamiltonian::Hamiltonian	hamiltonian.hpp	/^    Hamiltonian(const vFunctVV& _potentials);$/;"	p	class:Hamiltonian	access:public
Hamiltonian::Hamiltonian	hamiltonian.hpp	/^    Hamiltonian(vFunctVV&& _potentials);$/;"	p	class:Hamiltonian	access:public
Hamiltonian::Npot	hamiltonian.hpp	/^    uint Npot = 0;$/;"	m	class:Hamiltonian	access:private
Hamiltonian::ener	hamiltonian.cpp	/^valtype Hamiltonian::ener(const vector<valtype>& vals) const {$/;"	f	class:Hamiltonian
Hamiltonian::ener	hamiltonian.hpp	/^    valtype ener(const vector<valtype>& vals) const;$/;"	p	class:Hamiltonian	access:public
Hamiltonian::getPotentialFuncts	hamiltonian.cpp	/^const vFunctVV& Hamiltonian::getPotentialFuncts() const {return potentials; }$/;"	f	class:Hamiltonian
Hamiltonian::getPotentialFuncts	hamiltonian.cpp	/^vFunctVV& Hamiltonian::getPotentialFuncts() {return potentials; }$/;"	f	class:Hamiltonian
Hamiltonian::getPotentialFuncts	hamiltonian.hpp	/^    const vFunctVV& getPotentialFuncts() const;$/;"	p	class:Hamiltonian	access:public
Hamiltonian::getPotentialFuncts	hamiltonian.hpp	/^    vFunctVV& getPotentialFuncts();$/;"	p	class:Hamiltonian	access:public
Hamiltonian::operator !=	hamiltonian.cpp	/^bool Hamiltonian::operator!=(const Hamiltonian& src) const {$/;"	f	class:Hamiltonian
Hamiltonian::operator !=	hamiltonian.hpp	/^    bool operator!=(const Hamiltonian& src) const;$/;"	p	class:Hamiltonian	access:public
Hamiltonian::operator =	hamiltonian.cpp	/^Hamiltonian& Hamiltonian::operator=(const Hamiltonian& src) {$/;"	f	class:Hamiltonian
Hamiltonian::operator =	hamiltonian.hpp	/^    Hamiltonian& operator=(const Hamiltonian& src);$/;"	p	class:Hamiltonian	access:public
Hamiltonian::operator ==	hamiltonian.cpp	/^bool Hamiltonian::operator==(const Hamiltonian& src) const {$/;"	f	class:Hamiltonian
Hamiltonian::operator ==	hamiltonian.hpp	/^    bool operator==(const Hamiltonian& src) const;$/;"	p	class:Hamiltonian	access:public
Hamiltonian::potentials	hamiltonian.hpp	/^    vFunctVV potentials;$/;"	m	class:Hamiltonian	access:private
HistogramCV	gwham.cpp	/^void HistogramCV(histogram& hist, histcounter& N, const vector<valtype>& input) {$/;"	f
HistogramECV	gwham.cpp	/^void HistogramECV(histogram& hist, histcounter& N, vector<valtype>::const_iterator& itpot, const vector<valtype>& input) {$/;"	f
HistogramExpCV	gwham.cpp	/^void HistogramExpCV(vector<histogram>& hists, vector<histcounter>& Ns, vector<uint>::const_iterator& itstate, const linecounter nststates, linecounter& count, const vector<valtype>& input) {$/;"	f
HistogramExpECV	gwham.cpp	/^void HistogramExpECV(vector<histogram>& hists, vector<histcounter>& Ns, vector<uint>::const_iterator& itstate, const linecounter nststates, linecounter& count, vector<valtype>::const_iterator& itpot, const vector<valtype>& input) {$/;"	f
How to prepare input files for gwham	doc/tex/usage.tex	/^\\subsubsection{How to prepare input files for ``gwham''}\\label{sec:fformat}$/;"	b
Hs	ensemble_factory.hpp	/^  const vector<Hamiltonian>& Hs = pmdp->getHs();$/;"	l
Hs	mdp.hpp	/^    vector<Hamiltonian> Hs;$/;"	m	class:MDP	access:protected
IA1	ran2.c	/^#define IA1 /;"	d	file:
IA1	ran2.c	/^#undef IA1$/;"	d	file:
IA2	ran2.c	/^#define IA2 /;"	d	file:
IA2	ran2.c	/^#undef IA2$/;"	d	file:
IM1	ran2.c	/^#define IM1 /;"	d	file:
IM1	ran2.c	/^#undef IM1$/;"	d	file:
IM2	ran2.c	/^#define IM2 /;"	d	file:
IM2	ran2.c	/^#undef IM2$/;"	d	file:
IMM1	ran2.c	/^#define IMM1 /;"	d	file:
IMM1	ran2.c	/^#undef IMM1$/;"	d	file:
IQ1	ran2.c	/^#define IQ1 /;"	d	file:
IQ1	ran2.c	/^#undef IQ1$/;"	d	file:
IQ2	ran2.c	/^#define IQ2 /;"	d	file:
IQ2	ran2.c	/^#undef IQ2$/;"	d	file:
IR1	ran2.c	/^#define IR1 /;"	d	file:
IR1	ran2.c	/^#undef IR1$/;"	d	file:
IR2	ran2.c	/^#define IR2 /;"	d	file:
IR2	ran2.c	/^#undef IR2$/;"	d	file:
ITMAX	minimizer/cg.hpp	/^		const Int ITMAX=100;$/;"	l
ITMAX	minimizer/cg.hpp	/^		const Int ITMAX=2000000000;$/;"	l
Implementation	doc/tex/implement.tex	/^\\section{Implementation}\\label{sec:impl}$/;"	s
IndexSeq	metaprog_snippets.hpp	/^template < size_t ... N > struct IndexSeq {};$/;"	s
Indices	metaprog_snippets.hpp	/^  typedef I<indices...> Indices;$/;"	t	struct:Fibonacci	access:public
Int	minimizer/cg.hpp	/^typedef int Int; \/\/ 32 bit integer$/;"	t
Introduction	doc/tex/intro.tex	/^\\section{Introduction}\\label{sec:intro}$/;"	s
IsInf	mpfrc++/mpreal.h	/^    #define IsInf(/;"	d
K	gwham.hpp	/^  const uint K = (*hists).size();$/;"	l
L	gmxmdp.cpp	/^        auto& L = _L.get();$/;"	l
L	gmxmdp.cpp	/^      auto& L = _L.get();$/;"	l
LCM	metaprog_snippets.hpp	/^LCM ( T a, T b )$/;"	f
LIKELIHOODFUNC_HPP	likelihoodfunc.hpp	/^#define LIKELIHOODFUNC_HPP$/;"	d
LOG10_2	mpfrc++/mpreal.h	/^    const double LOG10_2 = 0.30102999566398119;$/;"	l
LOG2_10	mpfrc++/mpreal.h	/^    const double LOG2_10 = 3.3219280948873624;$/;"	l
Last_Index	metaprog_snippets.hpp	/^template < size_t ... i > struct Last_Index{};$/;"	s
Last_Index	metaprog_snippets.hpp	/^template < size_t a, size_t ... rest > struct Last_Index<a, rest...> {$/;"	s
Last_Index	metaprog_snippets.hpp	/^template < size_t z > struct Last_Index<z> {$/;"	s
Last_Index::value	metaprog_snippets.hpp	/^  constexpr static size_t value = Last_Index<rest...>::value;$/;"	m	struct:Last_Index	access:public
Last_Index::value	metaprog_snippets.hpp	/^  constexpr static size_t value = z;$/;"	m	struct:Last_Index	access:public
Lbond	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
Lcnt1	gmxmdp.hpp	/^    vector<valtype> Lcnt1, Lcnt2, Lcnt3;$/;"	m	class:GMXMDP	access:public
Lcnt2	gmxmdp.hpp	/^    vector<valtype> Lcnt1, Lcnt2, Lcnt3;$/;"	m	class:GMXMDP	access:public
Lcnt3	gmxmdp.hpp	/^    vector<valtype> Lcnt1, Lcnt2, Lcnt3;$/;"	m	class:GMXMDP	access:public
Lcoul	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
LikeliHoodFunc	likelihoodfunc.hpp	/^    LikeliHoodFunc(DOS& _dos, $/;"	f	class:LikeliHoodFunc	access:public
LikeliHoodFunc	likelihoodfunc.hpp	/^class LikeliHoodFunc {$/;"	c
LikeliHoodFunc::C	likelihoodfunc.hpp	/^    const NARRAY& C;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::LikeliHoodFunc	likelihoodfunc.hpp	/^    LikeliHoodFunc(DOS& _dos, $/;"	f	class:LikeliHoodFunc	access:public
LikeliHoodFunc::N	likelihoodfunc.hpp	/^    const vector<ulong>& N;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::NgexpmH	likelihoodfunc.hpp	/^    const vector<NARRAY>& NgexpmH;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::assign	likelihoodfunc.hpp	/^        graddf.assign(gradf.size(), 0.0);$/;"	p
LikeliHoodFunc::c	likelihoodfunc.hpp	/^          const auto& c = itC->second;$/;"	l
LikeliHoodFunc::d	likelihoodfunc.hpp	/^          const auto d = dos(itC, itsNgexpmH, expf);$/;"	l
LikeliHoodFunc::df	likelihoodfunc.hpp	/^    void df (const vector<valtype>& deltaf, vector<valtype>& _graddf) {$/;"	f	class:LikeliHoodFunc	access:public
LikeliHoodFunc::dos	likelihoodfunc.hpp	/^    DOS& dos;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::doscit	likelihoodfunc.hpp	/^  typedef typename DOS::const_iterator doscit;$/;"	t	class:LikeliHoodFunc	access:private
LikeliHoodFunc::dosit	likelihoodfunc.hpp	/^  typedef typename DOS::iterator dosit;$/;"	t	class:LikeliHoodFunc	access:private
LikeliHoodFunc::e	likelihoodfunc.hpp	/^  	  const auto e = exp(fi);$/;"	l
LikeliHoodFunc::edge	likelihoodfunc.hpp	/^	  const auto& edge = edges[i];$/;"	l
LikeliHoodFunc::edges	likelihoodfunc.hpp	/^	const auto& edges = tree.getedges();$/;"	l
LikeliHoodFunc::expf	likelihoodfunc.hpp	/^    vector<valtype>& expf;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::f	likelihoodfunc.hpp	/^    vector<valtype>& f;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::fi	likelihoodfunc.hpp	/^	  const auto& fi = *itfi;$/;"	l
LikeliHoodFunc::fret	likelihoodfunc.hpp	/^    valtype fret;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::gdf	likelihoodfunc.hpp	/^          auto& gdf = graddf[i];$/;"	l
LikeliHoodFunc::graddf	likelihoodfunc.hpp	/^    vector<valtype> graddf;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::gradf	likelihoodfunc.hpp	/^    vector<valtype> gradf;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::headnode	likelihoodfunc.hpp	/^	const auto headnode = f.begin();$/;"	l
LikeliHoodFunc::id	likelihoodfunc.hpp	/^	  const uint id = itfi-headnode;$/;"	l
LikeliHoodFunc::id	likelihoodfunc.hpp	/^            const auto id = node - headnode; $/;"	l
LikeliHoodFunc::itC	likelihoodfunc.hpp	/^      narrcit itC = C.begin();$/;"	l
LikeliHoodFunc::itfi	likelihoodfunc.hpp	/^	  const auto& itfi = edge[1];$/;"	l
LikeliHoodFunc::itfj	likelihoodfunc.hpp	/^	  const auto& itfj = edge[0];$/;"	l
LikeliHoodFunc::itsNgexpmH	likelihoodfunc.hpp	/^        vector<narrcit> itsNgexpmH;$/;"	l
LikeliHoodFunc::narrcit	likelihoodfunc.hpp	/^  typedef typename NARRAY::const_iterator narrcit;$/;"	t	class:LikeliHoodFunc	access:private
LikeliHoodFunc::narrit	likelihoodfunc.hpp	/^  typedef typename NARRAY::iterator narrit;$/;"	t	class:LikeliHoodFunc	access:private
LikeliHoodFunc::operator ()	likelihoodfunc.hpp	/^    valtype operator() (const vector<valtype>& deltaf) {$/;"	f	class:LikeliHoodFunc	access:public
LikeliHoodFunc::port	likelihoodfunc.hpp	/^          const auto& port = ports[i];$/;"	l
LikeliHoodFunc::ports	likelihoodfunc.hpp	/^        const auto& ports = tree.getports();$/;"	l
LikeliHoodFunc::tree	likelihoodfunc.hpp	/^    FTree& tree;$/;"	m	class:LikeliHoodFunc	access:private
LikeliHoodFunc::uint	likelihoodfunc.hpp	/^  typedef unsigned int uint;$/;"	t	class:LikeliHoodFunc	access:private
LikeliHoodFunc::ulong	likelihoodfunc.hpp	/^  typedef unsigned long ulong;$/;"	t	class:LikeliHoodFunc	access:private
LikeliHoodFunc::update	likelihoodfunc.hpp	/^      const bool update = (deltaf != x);$/;"	l
LikeliHoodFunc::valtype	likelihoodfunc.hpp	/^  typedef decltype( declval<narrit>()->second ) valtype; $/;"	t	class:LikeliHoodFunc	access:private
LikeliHoodFunc::x	likelihoodfunc.hpp	/^    vector<valtype> x;$/;"	m	class:LikeliHoodFunc	access:private
Linear	functor.hpp	/^T Linear ( const T a, const T b, const T& r )$/;"	f
Linit	gmxmdp.hpp	/^    int Linit = -1;$/;"	m	class:GMXMDP	access:public
Lk	gmxmdp.cpp	/^	  const valtype Lk = ((1-L)*pgrp.k0 + L*pgrp.k0B)\/2;$/;"	l
Lmass	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
Lpress	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
Lr	gmxmdp.cpp	/^	  const valtype Lr = (1-L)*pgrp.r0 + L*pgrp.r0B;$/;"	l
Lrst	gmxmdp.hpp	/^  vector<valtype> Lrst;$/;"	m	class:GMXMDP::GMXPGRP	access:public
Lrst	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
Ls	mdp.hpp	/^    array<vector<valtype>, NFEPLambdas> Ls;$/;"	m	class:MDP	access:protected
Ltemp	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
Lvdw	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MAX	minimizer/utils.hpp	/^inline const T &MAX(const T &a, const T &b) {return b > a ? (b) : (a);}$/;"	f
MAX	minimizer/utils.hpp	/^inline float MAX(const double &a, const float &b)$/;"	f
MAX	minimizer/utils.hpp	/^inline float MAX(const float &a, const double &b)$/;"	f
MAXEXPARG	typedefs.hpp	/^static const valtype MAXEXPARG = log(numeric_limits<valtype>::max()); \/\/max of the arguments to std::exp() call$/;"	v
MAXIT	gwham.hpp	/^     static const ulong MAXIT = 1000000;$/;"	m	class:WHAM	access:private
MAXIT	gwham.hpp	/^    cerr << "Max number of iteration " << MAXIT << " is reached. Quit\\n";$/;"	l
MAXNDIGRUN	typedefs.hpp	/^static const uint MAXNDIGRUN = 50;$/;"	v
MAXNDIGWIN	typedefs.hpp	/^static const uint MAXNDIGWIN = 50;$/;"	v
MAXNLINE	typedefs.hpp	/^static const ulong MAXNLINE = ULONG_MAX; \/\/maximum number of lines that can be counted $/;"	v
MAXNRST	typedefs.hpp	/^static const uint MAXNRST = 1000;$/;"	v
MC	mc.hpp	/^    MC(const valtype& _kB, const valtype& _T, const potener& _U, const bias& _V, const ulong& _nsteps, const valtype& _stepsize) :$/;"	f	class:MC	access:public
MC	mc.hpp	/^class MC {$/;"	c
MC::E	mc.hpp	/^	const valtype E = U(coord) + V(coord);$/;"	l
MC::MC	mc.hpp	/^    MC(const valtype& _kB, const valtype& _T, const potener& _U, const bias& _V, const ulong& _nsteps, const valtype& _stepsize) :$/;"	f	class:MC	access:public
MC::T	mc.hpp	/^    const valtype T; $/;"	m	class:MC	access:private
MC::U	mc.hpp	/^    const potener U;$/;"	m	class:MC	access:private
MC::V	mc.hpp	/^    const bias V;$/;"	m	class:MC	access:private
MC::beta	mc.hpp	/^    const valtype beta;$/;"	m	class:MC	access:private
MC::bin	mc.hpp	/^	hist.bin(coord);$/;"	p
MC::coord	mc.hpp	/^      vector<valtype> coord  = init_coord;$/;"	l
MC::dE	mc.hpp	/^	const valtype dE = newE - E;$/;"	l
MC::dim	mc.hpp	/^      const uint dim = coord.size();$/;"	l
MC::idum	mc.hpp	/^      long idum = -random();$/;"	l
MC::kB	mc.hpp	/^    const valtype kB;$/;"	m	class:MC	access:private
MC::naccept	mc.hpp	/^      ulong naccept = 0;$/;"	l
MC::newE	mc.hpp	/^	const valtype newE = U(newcoord) + V(newcoord);$/;"	l
MC::newcoord	mc.hpp	/^	vector<valtype> newcoord = coord;$/;"	l
MC::nsteps	mc.hpp	/^    const ulong nsteps;$/;"	m	class:MC	access:private
MC::operator ()	mc.hpp	/^    valtype operator() (const vector <valtype>& init_coord, histogram& hist) const {$/;"	f	class:MC	access:public
MC::stephalf	mc.hpp	/^      const valtype stephalf = stepsize\/2;$/;"	l
MC::stepsize	mc.hpp	/^    const valtype stepsize;$/;"	m	class:MC	access:private
MC::time	mc.hpp	/^      srandom(time(NULL));$/;"	p
MDP	mdp.hpp	/^    MDP (const MDP& src) : $/;"	f	class:MDP	access:public
MDP	mdp.hpp	/^    MDP (const string& _fname) : $/;"	f	class:MDP	access:public
MDP	mdp.hpp	/^    MDP (const string& _fname, const valtype& _dt, const valtype& _kB) : $/;"	f	class:MDP	access:public
MDP	mdp.hpp	/^class MDP$/;"	c
MDP	typedefs.hpp	/^class MDP;$/;"	x
MDP2Ensemble	ensemble_factory.hpp	/^MDP2Ensemble (const vector<PMDP>& pmdps, multimap<PMDP, uint>& pmdp2ipens, const bool combinestates)$/;"	f
MDP::BondLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::CoulLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::CreateTimeSeries	mdp.hpp	/^    virtual vector<TimeSeries<valtype>> CreateTimeSeries(const bool& requirepot) const = 0;$/;"	p	class:MDP	access:public
MDP::FEPLambdas	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	g	class:MDP	access:protected
MDP::Hs	mdp.hpp	/^    vector<Hamiltonian> Hs;$/;"	m	class:MDP	access:protected
MDP::Lbond	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MDP::Lcoul	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MDP::Lmass	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MDP::Lpress	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MDP::Lrst	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MDP::Ls	mdp.hpp	/^    array<vector<valtype>, NFEPLambdas> Ls;$/;"	m	class:MDP	access:protected
MDP::Ltemp	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MDP::Lvdw	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MDP::MDP	mdp.hpp	/^    MDP (const MDP& src) : $/;"	f	class:MDP	access:public
MDP::MDP	mdp.hpp	/^    MDP (const string& _fname) : $/;"	f	class:MDP	access:public
MDP::MDP	mdp.hpp	/^    MDP (const string& _fname, const valtype& _dt, const valtype& _kB) : $/;"	f	class:MDP	access:public
MDP::MassLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::NFEPLambdas	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
MDP::Nstates	mdp.hpp	/^    uint Nstates = 0;$/;"	m	class:MDP	access:protected
MDP::Pressure	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::Ps	mdp.hpp	/^    vector<valtype> Ps;$/;"	m	class:MDP	access:protected
MDP::Qt	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	g	class:MDP	access:public
MDP::RestraintLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::Restraints	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::Temperature	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::TemperatureLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::Ts	mdp.hpp	/^    vector<valtype> Ts;$/;"	m	class:MDP	access:protected
MDP::VdwLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
MDP::ans	mdp.hpp	/^      vector<valtype> ans;$/;"	l
MDP::clear	mdp.hpp	/^      rstfuncts.clear();$/;"	p
MDP::doublechk	mdp.hpp	/^    virtual void doublechk() = 0;$/;"	p	class:MDP	access:private
MDP::dt	mdp.hpp	/^    valtype dt = 0;$/;"	m	class:MDP	access:protected
MDP::emplace_back	mdp.hpp	/^	rstfuncts.emplace_back(rstfunct);$/;"	p
MDP::fname	mdp.hpp	/^    const string fname;$/;"	m	class:MDP	access:public
MDP::getHs	mdp.hpp	/^    const vector<Hamiltonian>& getHs() const { return Hs; }$/;"	f	class:MDP	access:public
MDP::getHs	mdp.hpp	/^    vector<Hamiltonian>& getHs() { return Hs; }$/;"	f	class:MDP	access:public
MDP::getLbond	mdp.hpp	/^    const vector<valtype>& getLbond() const { return Ls[Lbond]; }$/;"	f	class:MDP	access:public
MDP::getLcoul	mdp.hpp	/^    const vector<valtype>& getLcoul() const { return Ls[Lcoul]; }$/;"	f	class:MDP	access:public
MDP::getLmass	mdp.hpp	/^    const vector<valtype>& getLmass() const { return Ls[Lmass]; }$/;"	f	class:MDP	access:public
MDP::getLrst	mdp.hpp	/^    const vector<valtype>& getLrst() const { return Ls[Lrst]; }$/;"	f	class:MDP	access:public
MDP::getLs	mdp.hpp	/^    const array<vector<valtype>, NFEPLambdas>& getLs() const { return Ls; }$/;"	f	class:MDP	access:public
MDP::getLtemp	mdp.hpp	/^    const vector<valtype>& getLtemp() const { return Ls[Ltemp]; }$/;"	f	class:MDP	access:public
MDP::getLvdw	mdp.hpp	/^    const vector<valtype>& getLvdw() const { return Ls[Lvdw]; }$/;"	f	class:MDP	access:public
MDP::getNstates	mdp.hpp	/^    const uint& getNstates() const { return Nstates; };$/;"	f	class:MDP	access:public
MDP::getPs	mdp.hpp	/^    const vector<valtype>& getPs() const { return Ps; }$/;"	f	class:MDP	access:public
MDP::getTs	mdp.hpp	/^    const vector<valtype>& getTs() const { return Ts; }$/;"	f	class:MDP	access:public
MDP::getdt	mdp.hpp	/^    const valtype& getdt() const { return dt; };$/;"	f	class:MDP	access:public
MDP::getkB	mdp.hpp	/^    const valtype& getkB() const { return kB; };$/;"	f	class:MDP	access:public
MDP::getlambdas	mdp.hpp	/^    virtual vector<valtype> getlambdas() const {$/;"	f	class:MDP	access:public
MDP::getrstfuncts	mdp.hpp	/^    const vector<vFunctVV>& getrstfuncts() const { return rstfuncts; }$/;"	f	class:MDP	access:public
MDP::hasFEPLambda	mdp.hpp	/^    bool hasFEPLambda() const { return getlambdas().size() != 0; }; $/;"	f	class:MDP	access:public
MDP::hasLbond	mdp.hpp	/^    bool hasLbond() const { return !iszero(Ls[Lbond]); }$/;"	f	class:MDP	access:public
MDP::hasLcoul	mdp.hpp	/^    bool hasLcoul() const { return !iszero(Ls[Lcoul]); }$/;"	f	class:MDP	access:public
MDP::hasLmass	mdp.hpp	/^    bool hasLmass() const { return !iszero(Ls[Lmass]); }$/;"	f	class:MDP	access:public
MDP::hasLpress	mdp.hpp	/^    bool hasLpress() const { return !iszero(Ls[Lpress]); }$/;"	f	class:MDP	access:public
MDP::hasLrst	mdp.hpp	/^    bool hasLrst() const { return !iszero(Ls[Lrst]); }$/;"	f	class:MDP	access:public
MDP::hasLtemp	mdp.hpp	/^    bool hasLtemp() const { return !iszero(Ls[Ltemp]); }$/;"	f	class:MDP	access:public
MDP::hasLvdw	mdp.hpp	/^    bool hasLvdw() const { return !iszero(Ls[Lvdw]); }$/;"	f	class:MDP	access:public
MDP::hasPressure	mdp.hpp	/^    bool hasPressure() const { return !iszero(Ps); }; $/;"	f	class:MDP	access:public
MDP::hasRestraint	mdp.hpp	/^    bool hasRestraint() const { return rstfuncts.size() != 0; };$/;"	f	class:MDP	access:public
MDP::hasTemperature	mdp.hpp	/^    bool hasTemperature() const { return Ts.size() != 0; }; $/;"	f	class:MDP	access:public
MDP::insert	mdp.hpp	/^      for(const auto& L : Ls) ans.insert(ans.end(), L.begin(), L.end());$/;"	p
MDP::isExpandedEnsemble	mdp.hpp	/^    bool isExpandedEnsemble() const { return Nstates > 1; };$/;"	f	class:MDP	access:public
MDP::kB	mdp.hpp	/^    valtype kB = Boltzmannkcal;$/;"	m	class:MDP	access:protected
MDP::operator =	mdp.hpp	/^    MDP& operator=(const MDP& src) {$/;"	f	class:MDP	access:public
MDP::print	mdp.hpp	/^    virtual void print() const = 0; $/;"	p	class:MDP	access:public
MDP::rstfuncts	mdp.hpp	/^    vector<vFunctVV> rstfuncts;$/;"	m	class:MDP	access:protected
MDP::setLs	mdp.hpp	/^    virtual void setLs() = 0;$/;"	p	class:MDP	access:private
MDP::setexpand	mdp.hpp	/^    virtual void setexpand() = 0;$/;"	p	class:MDP	access:private
MDP_Exception	exception.hpp	/^    MDP_Exception(const string& _msg) : General_Exception("GMXMDP exception: " + _msg) {}; $/;"	f	class:MDP_Exception	access:public
MDP_Exception	exception.hpp	/^class MDP_Exception : public General_Exception {$/;"	c	inherits:General_Exception
MDP_Exception::MDP_Exception	exception.hpp	/^    MDP_Exception(const string& _msg) : General_Exception("GMXMDP exception: " + _msg) {}; $/;"	f	class:MDP_Exception	access:public
MDP_FACTORY_HPP	mdp_factory.hpp	/^#define MDP_FACTORY_HPP$/;"	d
MDP_Factory_Exception	exception.hpp	/^    MDP_Factory_Exception(const string& _msg) : General_Exception("MDP Factory exception: " + _msg) {};$/;"	f	class:MDP_Factory_Exception	access:public
MDP_Factory_Exception	exception.hpp	/^class MDP_Factory_Exception : public General_Exception {$/;"	c	inherits:General_Exception
MDP_Factory_Exception::MDP_Factory_Exception	exception.hpp	/^    MDP_Factory_Exception(const string& _msg) : General_Exception("MDP Factory exception: " + _msg) {};$/;"	f	class:MDP_Factory_Exception	access:public
MDP_HPP	mdp.hpp	/^#define MDP_HPP$/;"	d
METAPROG_SNIPPETS_HPP	metaprog_snippets.hpp	/^#define METAPROG_SNIPPETS_HPP$/;"	d
MINEXPARG	typedefs.hpp	/^static const valtype MINEXPARG = log(numeric_limits<valtype>::min()); \/\/min of the arguments to std::exp() call$/;"	v
MPFR_USE_INTMAX_T	mpfrc++/mpreal.h	/^#define MPFR_USE_INTMAX_T /;"	d
MPREAL_DOUBLE_BITS_OVERFLOW	mpfrc++/mpreal.h	/^#define MPREAL_DOUBLE_BITS_OVERFLOW /;"	d
MPREAL_HAVE_DYNAMIC_STD_NUMERIC_LIMITS	mpfrc++/mpreal.h	/^#define MPREAL_HAVE_DYNAMIC_STD_NUMERIC_LIMITS /;"	d
MPREAL_HAVE_EXPLICIT_CONVERTERS	mpfrc++/mpreal.h	/^    #define MPREAL_HAVE_EXPLICIT_CONVERTERS$/;"	d
MPREAL_HAVE_MOVE_SUPPORT	mpfrc++/mpreal.h	/^    #define MPREAL_HAVE_MOVE_SUPPORT$/;"	d
MPREAL_HAVE_MSVC_DEBUGVIEW	mpfrc++/mpreal.h	/^#define MPREAL_HAVE_MSVC_DEBUGVIEW /;"	d
MPREAL_MSVC_DEBUGVIEW_CODE	mpfrc++/mpreal.h	/^    #define MPREAL_MSVC_DEBUGVIEW_CODE /;"	d
MPREAL_MSVC_DEBUGVIEW_DATA	mpfrc++/mpreal.h	/^    #define MPREAL_MSVC_DEBUGVIEW_DATA /;"	d
MPREAL_PERMISSIVE_EXPR	mpfrc++/mpreal.h	/^  #define MPREAL_PERMISSIVE_EXPR /;"	d
MPREAL_PERMISSIVE_EXPR	mpfrc++/mpreal.h	/^  #define MPREAL_PERMISSIVE_EXPR$/;"	d
MPREAL_PRECISION	typedefs.hpp	/^static constexpr uint MPREAL_PRECISION = MPREALCXX;$/;"	v
MPREAL_UNARY_MATH_FUNCTION_BODY	mpfrc++/mpreal.h	/^#define MPREAL_UNARY_MATH_FUNCTION_BODY(/;"	d
MPREAL_VERSION_MAJOR	mpfrc++/mpreal.h	/^#define MPREAL_VERSION_MAJOR /;"	d
MPREAL_VERSION_MINOR	mpfrc++/mpreal.h	/^#define MPREAL_VERSION_MINOR /;"	d
MPREAL_VERSION_PATCHLEVEL	mpfrc++/mpreal.h	/^#define MPREAL_VERSION_PATCHLEVEL /;"	d
MPREAL_VERSION_STRING	mpfrc++/mpreal.h	/^#define MPREAL_VERSION_STRING /;"	d
Mask	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, ncntgrps, nstx*dt);$/;"	l
Mask	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, npgrps, nstx*dt);$/;"	l
Mask	gmxmdp.cpp	/^      ulong Mask = 0;$/;"	l
Mask	gmxmdp.cpp	/^    ans.emplace_back(fileio(fstream::in, false, 0, lse, MAXNLINE, "#@"), "ener.xvg", Mask, iNcol, oNcol, nstenergy*dt);$/;"	l
Mask	gmxmdp.cpp	/^    const ulong Mask = 2; $/;"	l
Mask	timeseries.hpp	/^    const ulong Mask = 0;$/;"	m	class:TimeSeries	access:public
MaskT	timeseries.hpp	/^    typedef decltype(TimeSeries<INPUT>::Mask) MaskT;$/;"	t	class:TimeSeries	access:public
MassLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
N	gwham.cpp	/^  histcounter N = 0;$/;"	l
N	gwham.hpp	/^     const vector<linecounter>* const N;$/;"	m	class:WHAM	access:private
N	likelihoodfunc.hpp	/^    const vector<ulong>& N;$/;"	m	class:LikeliHoodFunc	access:private
NDIV	ran2.c	/^#define NDIV /;"	d	file:
NDIV	ran2.c	/^#undef NDIV$/;"	d	file:
NFEPLambdas	mdp.hpp	/^    enum FEPLambdas { Lbond, Lmass, Lvdw, Lcoul, Lrst, Ltemp, Lpress, NFEPLambdas };$/;"	e	enum:MDP::FEPLambdas
NFEPTypes	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	e	enum:GMXMDP::FEPType
NGeomTypes	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
NL	gmxmdp.cpp	/^    uint NL = 0;$/;"	l
NPT	ensemble.cpp	/^NPT::NPT(const NPT& src) :$/;"	f	class:NPT
NPT	ensemble.cpp	/^NPT::NPT(const valtype _kB, const Hamiltonian& _H, const valtype _T, const valtype _P):$/;"	f	class:NPT
NPT	ensemble.hpp	/^    NPT(const NPT& src);$/;"	p	class:NPT	access:public
NPT	ensemble.hpp	/^    NPT(const valtype _kB, const Hamiltonian& _H, const valtype _T,  const valtype _P);$/;"	p	class:NPT	access:public
NPT	ensemble.hpp	/^class NPT : public virtual NVT {$/;"	c	inherits:NVT
NPT	typedefs.hpp	/^class NPT;$/;"	x
NPT::NPT	ensemble.cpp	/^NPT::NPT(const NPT& src) :$/;"	f	class:NPT
NPT::NPT	ensemble.cpp	/^NPT::NPT(const valtype _kB, const Hamiltonian& _H, const valtype _T, const valtype _P):$/;"	f	class:NPT
NPT::NPT	ensemble.hpp	/^    NPT(const NPT& src);$/;"	p	class:NPT	access:public
NPT::NPT	ensemble.hpp	/^    NPT(const valtype _kB, const Hamiltonian& _H, const valtype _T,  const valtype _P);$/;"	p	class:NPT	access:public
NPT::P	ensemble.hpp	/^    const valtype P; $/;"	m	class:NPT	access:protected
NPT::cmp	ensemble.cpp	/^uint NPT::cmp(const Ensemble& src) const {$/;"	f	class:NPT
NPT::cmp	ensemble.hpp	/^    virtual uint cmp(const Ensemble& src) const;$/;"	p	class:NPT	access:public
NPT::ener	ensemble.cpp	/^valtype NPT::ener(const vector<valtype>& vals) const {$/;"	f	class:NPT
NPT::ener	ensemble.hpp	/^    valtype ener(const vector<valtype>& vals) const; $/;"	p	class:NPT	access:public
NPT::getP	ensemble.hpp	/^    const valtype& getP() const { return P; }$/;"	f	class:NPT	access:public
NPT::~NPT	ensemble.hpp	/^    virtual ~NPT() {};$/;"	f	class:NPT	access:public
NPTypes	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	e	enum:GMXMDP::PType
NPullTypes	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
NRestraintTypes	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	e	enum:GMXMDP::GMXPGRP::RestraintType
NTAB	ran2.c	/^#define NTAB /;"	d	file:
NTAB	ran2.c	/^#undef NTAB$/;"	d	file:
NTTypes	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	e	enum:GMXMDP::TType
NVE	ensemble.cpp	/^NVE::NVE(const NVE& src) :$/;"	f	class:NVE
NVE	ensemble.cpp	/^NVE::NVE(const valtype _kB, const Hamiltonian& _H) :$/;"	f	class:NVE
NVE	ensemble.hpp	/^    NVE(const NVE& src);$/;"	p	class:NVE	access:public
NVE	ensemble.hpp	/^    NVE(const valtype _kB, const Hamiltonian& _H);$/;"	p	class:NVE	access:public
NVE	ensemble.hpp	/^class NVE : public virtual Ensemble {$/;"	c	inherits:Ensemble
NVE	typedefs.hpp	/^class NVE;$/;"	x
NVE::H	ensemble.hpp	/^    Hamiltonian H; $/;"	m	class:NVE	access:protected
NVE::NVE	ensemble.cpp	/^NVE::NVE(const NVE& src) :$/;"	f	class:NVE
NVE::NVE	ensemble.cpp	/^NVE::NVE(const valtype _kB, const Hamiltonian& _H) :$/;"	f	class:NVE
NVE::NVE	ensemble.hpp	/^    NVE(const NVE& src);$/;"	p	class:NVE	access:public
NVE::NVE	ensemble.hpp	/^    NVE(const valtype _kB, const Hamiltonian& _H);$/;"	p	class:NVE	access:public
NVE::cmp	ensemble.cpp	/^uint NVE::cmp(const Ensemble& src) const {$/;"	f	class:NVE
NVE::cmp	ensemble.hpp	/^    virtual uint cmp(const Ensemble& src) const;$/;"	p	class:NVE	access:public
NVE::ener	ensemble.cpp	/^valtype NVE::ener(const vector<valtype>& vals) const {$/;"	f	class:NVE
NVE::ener	ensemble.hpp	/^    virtual valtype ener(const vector<valtype>& vals) const;$/;"	p	class:NVE	access:public
NVE::getH	ensemble.hpp	/^    Hamiltonian& getH() { return H; };$/;"	f	class:NVE	access:public
NVE::getH	ensemble.hpp	/^    const Hamiltonian& getH() const { return H; };$/;"	f	class:NVE	access:public
NVE::~NVE	ensemble.hpp	/^    virtual ~NVE() {};$/;"	f	class:NVE	access:public
NVT	ensemble.cpp	/^NVT::NVT(const NVT& src) :$/;"	f	class:NVT
NVT	ensemble.cpp	/^NVT::NVT(const valtype _kB, const Hamiltonian& _H, const valtype _T):$/;"	f	class:NVT
NVT	ensemble.hpp	/^    NVT(const NVT& src);$/;"	p	class:NVT	access:public
NVT	ensemble.hpp	/^    NVT(const valtype _kB, const Hamiltonian& _H, const valtype _T);$/;"	p	class:NVT	access:public
NVT	ensemble.hpp	/^class NVT : public virtual NVE {$/;"	c	inherits:NVE
NVT	typedefs.hpp	/^class NVT;$/;"	x
NVT::NVT	ensemble.cpp	/^NVT::NVT(const NVT& src) :$/;"	f	class:NVT
NVT::NVT	ensemble.cpp	/^NVT::NVT(const valtype _kB, const Hamiltonian& _H, const valtype _T):$/;"	f	class:NVT
NVT::NVT	ensemble.hpp	/^    NVT(const NVT& src);$/;"	p	class:NVT	access:public
NVT::NVT	ensemble.hpp	/^    NVT(const valtype _kB, const Hamiltonian& _H, const valtype _T);$/;"	p	class:NVT	access:public
NVT::T	ensemble.hpp	/^    const valtype T;$/;"	m	class:NVT	access:protected
NVT::cmp	ensemble.cpp	/^uint NVT::cmp(const Ensemble& src) const {$/;"	f	class:NVT
NVT::cmp	ensemble.hpp	/^    virtual uint cmp(const Ensemble& src) const;$/;"	p	class:NVT	access:public
NVT::ener	ensemble.cpp	/^valtype NVT::ener(const vector<valtype>& vals) const {$/;"	f	class:NVT
NVT::ener	ensemble.hpp	/^    virtual valtype ener(const vector<valtype>& vals) const; $/;"	p	class:NVT	access:public
NVT::getT	ensemble.hpp	/^    const valtype& getT() const { return T; }$/;"	f	class:NVT	access:public
NVT::~NVT	ensemble.hpp	/^    virtual ~NVT() {};$/;"	f	class:NVT	access:public
NaN	typedefs.hpp	/^NaN = numeric_limits<valtype>::quiet_NaN();$/;"	v
Nbit	timeseries.hpp	/^    constexpr static int Nbit = numeric_limits<MaskT>::digits;$/;"	m	class:TimeSeries	access:public
Nbit	timeseries.hpp	/^constexpr int TimeSeries<INPUT>::Nbit;$/;"	m	class:TimeSeries
Nbits_UINT	typedefs.hpp	/^static const uint Nbits_UINT = numeric_limits<uint>::digits; $/;"	v
Nbits_ULONG	typedefs.hpp	/^static const uint Nbits_ULONG = numeric_limits<ulong>::digits;$/;"	v
NextIteration	metaprog_snippets.hpp	/^  typedef Extract_One_Type<N-1, T...> NextIteration;$/;"	t	struct:Extract_One_Type	access:public
Ng	gwham.hpp	/^      const auto Ng = (*N)[k]\/sw[k][coord];$/;"	l
NgexpmH	gwham.hpp	/^  vector<NARRAY> NgexpmH;$/;"	l
NgexpmH	likelihoodfunc.hpp	/^    const vector<NARRAY>& NgexpmH;$/;"	m	class:LikeliHoodFunc	access:private
Ni	gnarray.hpp	/^    const auto& Ni = Nsamples[i];$/;"	l
Nl	timeseries.hpp	/^      linecounter Nl = 0;$/;"	l
NoFEP	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	e	enum:GMXMDP::FEPType
NoP	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	e	enum:GMXMDP::PType
NoPull	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
NoT	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	e	enum:GMXMDP::TType
Node	likelihoodfunc.hpp	/^    typedef typename vector<V>::iterator Node;$/;"	t	class:ftree	access:public
Node	likelihoodfunc.hpp	/^  typedef typename FTree::Node Node;$/;"	t
Nodes	likelihoodfunc.hpp	/^    typedef vector<Node> Nodes;$/;"	t	class:ftree	access:public
Nph	functor.hpp	/^  constexpr size_t Nph = sizeof...(Input) - sizeof...(Params);$/;"	v
Npot	hamiltonian.hpp	/^    uint Npot = 0;$/;"	m	class:Hamiltonian	access:private
Npts_tot	mc.hpp	/^      ulong Npts_tot = 1;$/;"	l
Nsamples	gwham.cpp	/^      cout << "#Read " << Nsamples[i] << " sample\\n";$/;"	l
Nsamples	gwham.cpp	/^  vector<histcounter> Nsamples(hists.size(), 0);$/;"	p	file:
Nsamples	mc.cpp	/^  const vector<linecounter> Nsamples(nwins_tot,nsteps);$/;"	p	file:
Nstates	ensemble_factory.hpp	/^  const uint Nstates = pmdp->getNstates();$/;"	l
Nstates	mdp.hpp	/^    uint Nstates = 0;$/;"	m	class:MDP	access:protected
Ntree	likelihoodfunc.hpp	/^  const uint Ntree = nbnodes.size();$/;"	l
Ntreeb	likelihoodfunc.hpp	/^  const uint Ntreeb = trees.size();$/;"	l
Ntreesb	likelihoodfunc.hpp	/^  const uint Ntreesb = trees.size();$/;"	l
OIterator	gmxmdp.hpp	/^  typedef typename map<string,reference_wrapper<T>>::iterator OIterator;$/;"	t
Output from the gwham executable	doc/tex/usage.tex	/^\\subsection{Output from the ``gwham'' executable}$/;"	b
P	ensemble.hpp	/^    const valtype P; $/;"	m	class:NPT	access:protected
P	gmxmdp.hpp	/^    valtype P = NaN;$/;"	m	class:GMXMDP	access:public
PT	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::PType	access:public
PTstr	gmxmdp.hpp	/^    string PTstr = "PTstr";$/;"	m	class:GMXMDP	access:public
PType	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	g	class:GMXMDP	access:public
Pmax	gmxmdp.hpp	/^    valtype Pmax = P, Pmin = P;$/;"	m	class:GMXMDP	access:public
Pmin	gmxmdp.hpp	/^    valtype Pmax = P, Pmin = P;$/;"	m	class:GMXMDP	access:public
Position	gmxmdp.hpp	/^      Distance, Direction, DirectionPeriodic, Cylinder, Position, NGeomTypes$/;"	e	enum:GMXMDP::PullGeom
Pressure	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
Ps	ensemble_factory.hpp	/^  const auto& Ps = pmdp->getPs();$/;"	l
Ps	mdp.hpp	/^    vector<valtype> Ps;$/;"	m	class:MDP	access:protected
PullGeom	gmxmdp.hpp	/^    enum PullGeom {$/;"	g	class:GMXMDP	access:public
PullType	gmxmdp.hpp	/^    enum PullType {$/;"	g	class:GMXMDP	access:public
Qinv	gwham.hpp	/^  const valtype Qinv = expf[i]; \/\/this is the inverse of the partition function $/;"	l
Qt	ensemble.cpp	/^  uint Qt = 0;$/;"	l
Qt	ensemble.cpp	/^  uint Qt = NVE::cmp(src);$/;"	l
Qt	ensemble.cpp	/^  uint Qt = NVT::cmp(src);$/;"	l
Qt	ensemble.hpp	/^    enum Qt {DHamiltonian, DTemperature, DPressure};$/;"	g	class:Ensemble	access:public
Qt	ensemble_factory.hpp	/^  const uint Qt = cmpens(ens);$/;"	l
Qt	ensemble_factory.hpp	/^  uint Qt = 0;$/;"	l
Qt	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	g	class:MDP	access:public
Quad	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	e	enum:GMXMDP::GMXPGRP::RestraintType
QuadFlat	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	e	enum:GMXMDP::GMXPGRP::RestraintType
Quadratic	functor.hpp	/^T Quadratic ( const T k, const T r0, const T c, const T& r )$/;"	f
QuadraticFlat	functor.hpp	/^T QuadraticFlat (const T ref, $/;"	f
RNMX	ran2.c	/^#define RNMX /;"	d	file:
RNMX	ran2.c	/^#undef RNMX$/;"	d	file:
RestraintLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
RestraintType	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	g	class:GMXMDP::GMXPGRP	access:public
Restraints	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
Rk	gmxmdp.cpp	/^	  const valtype Rk = ((1-L)*pgrp.k1 + L*pgrp.k1B)\/2;$/;"	l
Rr	gmxmdp.cpp	/^	  const valtype Rr = (1-L)*pgrp.r1 + L*pgrp.r1B;$/;"	l
SIGN	minimizer/utils.hpp	/^inline T SIGN(const T &a, const T &b)$/;"	f
SIGN	minimizer/utils.hpp	/^inline float SIGN(const double &a, const float &b)$/;"	f
SIGN	minimizer/utils.hpp	/^inline float SIGN(const float &a, const double &b)$/;"	f
SQR	minimizer/utils.hpp	/^inline T SQR(const T a) {return a*a;}$/;"	f
SWAP	minimizer/utils.hpp	/^inline void SWAP(T &a, T &b) { swap(a,b); }$/;"	f
Solve equation ref eq WHAM1	doc/tex/implement.tex	/^\\subsubsection{Solve equation~\\ref{eq:WHAM1}}$/;"	b
StopAtMaxN	metaprog_snippets.hpp	/^struct StopAtMaxN<I<indices...>, I<Max> > {$/;"	s
StopAtMaxN	metaprog_snippets.hpp	/^template < class T, class Arg > struct StopAtMaxN {};$/;"	s
StopAtMaxN::decision	metaprog_snippets.hpp	/^  constexpr static bool decision = sizeof...(indices) >= Max ? true : false;$/;"	m	struct:StopAtMaxN	access:public
Superset	metaprog_snippets.hpp	/^  typedef I<indices...> Superset;$/;"	t	struct:Extract_Indices	access:public
Supported GROMACS free energy or PMF calculation schemes	doc/tex/usage.tex	/^\\subsubsection{Supported GROMACS free energy or PMF calculation schemes}$/;"	b
T	ensemble.hpp	/^    const valtype T;$/;"	m	class:NVT	access:protected
T	gmxmdp.hpp	/^    valtype T = NaN;$/;"	m	class:GMXMDP	access:public
T	gwham.cpp	/^    const auto T = pmdp0->getTs().front();$/;"	l
T	mc.cpp	/^  const valtype T = 300; \/\/temperature in K$/;"	l
T	mc.hpp	/^    const valtype T; $/;"	m	class:MC	access:private
TIMESERIES_HPP	timeseries.hpp	/^#define TIMESERIES_HPP$/;"	d
TINY	minimizer/cg.hpp	/^		const Doub GOLD=1.618034,GLIMIT=100.0,TINY=1.0e-8;$/;"	l
TT	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::TType	access:public
TTstr	gmxmdp.hpp	/^    string TTstr = "TTstr";$/;"	m	class:GMXMDP	access:public
TType	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	g	class:GMXMDP	access:public
TYPEDEFS_HPP	typedefs.hpp	/^#define TYPEDEFS_HPP$/;"	d
Temperature	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
TemperatureLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
Tf	functor.hpp	/^    typedef const Funct<Output(Arg...)> Tf;$/;"	t	class:Functor	access:public
Theory	doc/tex/theory.tex	/^\\section{Theory}\\label{sec:theory} $/;"	s
ThisType	functor.hpp	/^    typedef Functor<Tf, Tp, To, Params...> ThisType;$/;"	t	class:Functor	access:public
ThisType	gnarray.hpp	/^    typedef gnarray<Tcoord, Telem, Tval> ThisType;$/;"	t	class:gnarray	access:public
ThisType	likelihoodfunc.hpp	/^    typedef ftree<V> ThisType;$/;"	t	class:ftree	access:private
ThisType	timeseries.hpp	/^    typedef TimeSeries<INPUT> ThisType;$/;"	t	class:TimeSeries	access:public
TimeSeries	timeseries.hpp	/^    TimeSeries (const ThisType& src) :$/;"	f	class:TimeSeries	access:public
TimeSeries	timeseries.hpp	/^    TimeSeries (const fileio& _fio, const string& _fnsuffix, const ulong _Mask, const ulong _iNcol, const ulong _oNcol, const valtype _nst) : $/;"	f	class:TimeSeries	access:public
TimeSeries	timeseries.hpp	/^    TimeSeries (fileio&& _fio, const string& _fnsuffix, const ulong _Mask, const ulong _iNcol, const ulong _oNcol, const valtype _nst) :$/;"	f	class:TimeSeries	access:public
TimeSeries	timeseries.hpp	/^class TimeSeries$/;"	c
TimeSeries::Mask	timeseries.hpp	/^    const ulong Mask = 0;$/;"	m	class:TimeSeries	access:public
TimeSeries::MaskT	timeseries.hpp	/^    typedef decltype(TimeSeries<INPUT>::Mask) MaskT;$/;"	t	class:TimeSeries	access:public
TimeSeries::Nbit	timeseries.hpp	/^    constexpr static int Nbit = numeric_limits<MaskT>::digits;$/;"	m	class:TimeSeries	access:public
TimeSeries::Nbit	timeseries.hpp	/^constexpr int TimeSeries<INPUT>::Nbit;$/;"	m	class:TimeSeries
TimeSeries::Nl	timeseries.hpp	/^      linecounter Nl = 0;$/;"	l
TimeSeries::ThisType	timeseries.hpp	/^    typedef TimeSeries<INPUT> ThisType;$/;"	t	class:TimeSeries	access:public
TimeSeries::TimeSeries	timeseries.hpp	/^    TimeSeries (const ThisType& src) :$/;"	f	class:TimeSeries	access:public
TimeSeries::TimeSeries	timeseries.hpp	/^    TimeSeries (const fileio& _fio, const string& _fnsuffix, const ulong _Mask, const ulong _iNcol, const ulong _oNcol, const valtype _nst) : $/;"	f	class:TimeSeries	access:public
TimeSeries::TimeSeries	timeseries.hpp	/^    TimeSeries (fileio&& _fio, const string& _fnsuffix, const ulong _Mask, const ulong _iNcol, const ulong _oNcol, const valtype _nst) :$/;"	f	class:TimeSeries	access:public
TimeSeries::colids	timeseries.hpp	/^    vector<uint> colids;$/;"	m	class:TimeSeries	access:protected
TimeSeries::cols	timeseries.hpp	/^	const vector<valtype> cols(fio.line2val());$/;"	p
TimeSeries::cols	timeseries.hpp	/^          const vector<valtype> cols(fio.line2val());$/;"	p
TimeSeries::emplace_back	timeseries.hpp	/^	  colids.emplace_back(i);$/;"	p
TimeSeries::fio	timeseries.hpp	/^    fileio fio;$/;"	m	class:TimeSeries	access:public
TimeSeries::fnsuffix	timeseries.hpp	/^    const string fnsuffix;$/;"	m	class:TimeSeries	access:public
TimeSeries::iNcol	timeseries.hpp	/^    const ulong iNcol = 0;$/;"	m	class:TimeSeries	access:public
TimeSeries::init	timeseries.hpp	/^    void init() {$/;"	f	class:TimeSeries	access:private
TimeSeries::nst	timeseries.hpp	/^    const valtype nst = 0;$/;"	m	class:TimeSeries	access:public
TimeSeries::oNcol	timeseries.hpp	/^    const ulong oNcol = 0;$/;"	m	class:TimeSeries	access:public
TimeSeries::operator ()	timeseries.hpp	/^    linecounter operator()(const string& fname, const DATAPROCESSOR& dproc) {$/;"	f	class:TimeSeries	access:public
TimeSeries::out	timeseries.hpp	/^      vector<INPUT> out(colids.size(),INPUT{0});$/;"	p
TimeSeries::rINPUT	timeseries.hpp	/^    typedef std::reference_wrapper<INPUT> rINPUT;$/;"	t	class:TimeSeries	access:public
TimeSeries::read	timeseries.hpp	/^    linecounter read(const string& fname, const DATAPROCESSOR& dproc) {$/;"	f	class:TimeSeries	access:public
TimeSeries::skipemptylns	timeseries.hpp	/^        fio.skipemptylns();$/;"	p
TimeSeries_Exception	exception.hpp	/^    TimeSeries_Exception(const string& _msg) : General_Exception("TimeSeries exception: " + _msg) {};$/;"	f	class:TimeSeries_Exception	access:public
TimeSeries_Exception	exception.hpp	/^class TimeSeries_Exception : public General_Exception {$/;"	c	inherits:General_Exception
TimeSeries_Exception::TimeSeries_Exception	exception.hpp	/^    TimeSeries_Exception(const string& _msg) : General_Exception("TimeSeries exception: " + _msg) {};$/;"	f	class:TimeSeries_Exception	access:public
Tmax	gmxmdp.hpp	/^    valtype Tmax = T, Tmin = T;$/;"	m	class:GMXMDP	access:public
Tmc	gmxmdp.hpp	/^    valtype Tmc = T;$/;"	m	class:GMXMDP	access:public
Tmin	gmxmdp.hpp	/^    valtype Tmax = T, Tmin = T;$/;"	m	class:GMXMDP	access:public
To	functor.hpp	/^    typedef const Tobj To;$/;"	t	class:Functor	access:public
Tp	functor.hpp	/^    typedef const ParamsContainer<ParamsContained, ParamsContainerOther...> Tp;$/;"	t	class:Functor	access:public
Ts	ensemble_factory.hpp	/^  const auto& Ts = pmdp->getTs();$/;"	l
Ts	mdp.hpp	/^    vector<valtype> Ts;$/;"	m	class:MDP	access:protected
Tsuffix2MDP	mdp_factory.hpp	/^typedef map<string, function<pMDP(const string&)>> Tsuffix2MDP;$/;"	t
U	mc.hpp	/^    const potener U;$/;"	m	class:MC	access:private
UTILS_HPP	minimizer/utils.hpp	/^#define UTILS_HPP$/;"	d
Uint	minimizer/cg.hpp	/^typedef unsigned int Uint;$/;"	t
Umbrella	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
UmbrellaFlatBottom	gmxmdp.hpp	/^      NoPull, Umbrella, UmbrellaFlatBottom, Constraint, ConstantForce, Contact, NPullTypes$/;"	e	enum:GMXMDP::PullType
Usage	doc/tex/usage.tex	/^\\section{Usage} \\label{sec:usage}$/;"	s
Use the WHAM kernel	doc/tex/usage.tex	/^\\subsection{Use the WHAM kernel}$/;"	b
Use the gwham program	doc/tex/usage.tex	/^\\subsection{Use the ``gwham'' program}$/;"	b
Using the mc program	doc/tex/usage.tex	/^\\subsection{Using the ``mc'' program}$/;"	b
V	gwham.hpp	/^     const vector<PENSEMBLE>* const V;$/;"	m	class:WHAM	access:private
V	mc.cpp	/^  vpEnsemble V;$/;"	l
V	mc.hpp	/^    const bias V;$/;"	m	class:MC	access:private
V0	mc.cpp	/^  pEnsemble V0 = make_shared<NVT>(kB, Hamiltonian{}, T);$/;"	l
VALMAXDIGITS10	minimizer/cg.hpp	/^static const uint VALMAXDIGITS10 = numeric_limits<valtype>::max_digits10();$/;"	v
VALMAXDIGITS10	minimizer/cg.hpp	/^static const uint VALMAXDIGITS10 = numeric_limits<valtype>::max_digits10;$/;"	v
VdwLambdas	mdp.hpp	/^    enum Qt {Temperature, Pressure, Restraints, BondLambdas, MassLambdas, VdwLambdas, CoulLambdas, RestraintLambdas, TemperatureLambdas};$/;"	e	enum:MDP::Qt
VecDoub	minimizer/cg.hpp	/^typedef vector<Doub> VecDoub, VecDoub_O, VecDoub_IO;$/;"	t
VecDoub	minimizer/cg.hpp	/^typedef vector<Doub> VecDoub;$/;"	t
VecDoub_I	minimizer/cg.hpp	/^typedef const vector<Doub> VecDoub_I;$/;"	t
VecDoub_IO	minimizer/cg.hpp	/^typedef vector<Doub> VecDoub, VecDoub_O, VecDoub_IO;$/;"	t
VecDoub_O	minimizer/cg.hpp	/^typedef vector<Doub> VecDoub, VecDoub_O, VecDoub_IO;$/;"	t
Vi	gwham.hpp	/^  const pEnsemble Vi = (*V)[i];$/;"	l
WHAM	gwham.hpp	/^    WHAM(const map<coordtype, vector<uint> >& _record, $/;"	p	class:WHAM	access:public
WHAM	gwham.hpp	/^WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::WHAM(const map<coordtype, vector<uint> >& _record, $/;"	f	class:WHAM
WHAM	gwham.hpp	/^class WHAM {$/;"	c
WHAM::DOS	gwham.hpp	/^     DOStype DOS;$/;"	m	class:WHAM	access:private
WHAM::DOSptr	gwham.hpp	/^  typedef DOStype* DOSptr;$/;"	t	class:WHAM	access:private
WHAM::DOStype	gwham.hpp	/^  typedef DensityOfState<PENSEMBLE,HISTOGRAM,NARRAY> DOStype;$/;"	t	class:WHAM	access:private
WHAM::MAXIT	gwham.hpp	/^     static const ulong MAXIT = 1000000;$/;"	m	class:WHAM	access:private
WHAM::N	gwham.hpp	/^     const vector<linecounter>* const N;$/;"	m	class:WHAM	access:private
WHAM::V	gwham.hpp	/^     const vector<PENSEMBLE>* const V;$/;"	m	class:WHAM	access:private
WHAM::WHAM	gwham.hpp	/^    WHAM(const map<coordtype, vector<uint> >& _record, $/;"	p	class:WHAM	access:public
WHAM::WHAM	gwham.hpp	/^WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::WHAM(const map<coordtype, vector<uint> >& _record, $/;"	f	class:WHAM
WHAM::binsize	gwham.hpp	/^     const vector<valtype> binsize;$/;"	m	class:WHAM	access:private
WHAM::calrho	gwham.hpp	/^    NARRAY calrho(const vector<uint>& dim, const pEnsemble& _V) const;$/;"	p	class:WHAM	access:public
WHAM::calrho	gwham.hpp	/^NARRAY WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::calrho(const vector<uint>& _dim, const pEnsemble& _V) const {$/;"	f	class:WHAM
WHAM::coord2val	gwham.hpp	/^    const vector<valtype> coord2val(const coordtype& coord) const;$/;"	p	class:WHAM	access:public
WHAM::coord2val	gwham.hpp	/^    const vector<valtype> coord2val(const vector<uint>& _dim, const coordtype& coord) const;$/;"	p	class:WHAM	access:public
WHAM::coord2val	gwham.hpp	/^const vector<valtype> WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::coord2val(const coordtype& coord) const {$/;"	f	class:WHAM
WHAM::coord2val	gwham.hpp	/^const vector<valtype> WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::coord2val(const vector<uint>& _dim, const coordtype& coord) const {$/;"	f	class:WHAM
WHAM::dim	gwham.hpp	/^     const uint dim;$/;"	m	class:WHAM	access:private
WHAM::endit	gwham.hpp	/^     bool endit(const vector<valtype>& newexpf, const ulong& count); $/;"	p	class:WHAM	access:private
WHAM::endit	gwham.hpp	/^bool WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::endit(const vector<valtype>& newexpf, const ulong& count) {$/;"	f	class:WHAM
WHAM::expf	gwham.hpp	/^     vector<valtype> expf;$/;"	m	class:WHAM	access:private
WHAM::f	gwham.hpp	/^     vector<valtype> f;$/;"	m	class:WHAM	access:private
WHAM::g	gwham.hpp	/^     const vector<NARRAY>* const g;$/;"	m	class:WHAM	access:private
WHAM::hists	gwham.hpp	/^     const vector<HISTOGRAM>* const hists;$/;"	m	class:WHAM	access:private
WHAM::init	gwham.hpp	/^     void init(const map<coordtype, vector<uint> >& _record, $/;"	p	class:WHAM	access:private
WHAM::init	gwham.hpp	/^void WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::init$/;"	f	class:WHAM
WHAM::lv	gwham.hpp	/^     const vector<valtype> lv;$/;"	m	class:WHAM	access:private
WHAM::overlap	gwham.hpp	/^     const vector<vector<valtype> >* const overlap;$/;"	m	class:WHAM	access:private
WHAM::printfree	gwham.hpp	/^    void printfree() const;$/;"	p	class:WHAM	access:public
WHAM::printfree	gwham.hpp	/^void WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::printfree() const {$/;"	f	class:WHAM
WHAM::record	gwham.hpp	/^     const map<coordtype, vector<uint> >* const record;$/;"	m	class:WHAM	access:private
WHAM::shiftf	gwham.hpp	/^    void shiftf(vector<valtype>& newexpf) const;$/;"	p	class:WHAM	access:public
WHAM::shiftf	gwham.hpp	/^void WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::shiftf(vector<valtype>& newexpf) const {$/;"	f	class:WHAM
WHAM::tol	gwham.hpp	/^     const valtype tol;$/;"	m	class:WHAM	access:private
WHAM::whamvsraw	gwham.hpp	/^    vector<valtype> whamvsraw(const NARRAY& rho) const;$/;"	p	class:WHAM	access:public
WHAM::whamvsraw	gwham.hpp	/^vector<valtype> WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::whamvsraw(const NARRAY& rho) const {$/;"	f	class:WHAM
WHAM::whamvsrawi	gwham.hpp	/^    valtype whamvsrawi(const uint& i, const NARRAY& rho) const;$/;"	p	class:WHAM	access:public
WHAM::whamvsrawi	gwham.hpp	/^valtype WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::whamvsrawi(const uint& i, const NARRAY& rho) const {$/;"	f	class:WHAM
Yes	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	e	enum:GMXMDP::FEPType
YesP	gmxmdp.hpp	/^    enum PType {NoP, YesP, NPTypes} PT = NPTypes;$/;"	e	enum:GMXMDP::PType
YesT	gmxmdp.hpp	/^    enum TType {NoT, YesT, NTTypes} TT = NTTypes;$/;"	e	enum:GMXMDP::TType
ZEPS	minimizer/cg.hpp	/^		const Doub ZEPS=numeric_limits<Doub>::epsilon()*1.0e-3;$/;"	l
_Ls	gmxmdp.cpp	/^    vector<reference_wrapper<vector<valtype>>> _Ls = {$/;"	l
__MPREAL_H__	mpfrc++/mpreal.h	/^#define __MPREAL_H__$/;"	d
__has_feature	mpfrc++/mpreal.h	/^    #define __has_feature(/;"	d
_pens	ensemble_factory.hpp	/^      auto _pens = dynamic_pointer_cast<NVE>(pens);$/;"	l
_pens	ensemble_factory.hpp	/^      auto _pens = dynamic_pointer_cast<NVT>(pens);$/;"	l
_src	ensemble.cpp	/^    const NPT& _src = dynamic_cast<const NPT&>(src);$/;"	l
_src	ensemble.cpp	/^    const NVE& _src = dynamic_cast<const NVE&>(src);$/;"	l
_src	ensemble.cpp	/^    const NVT& _src = dynamic_cast<const NVT&>(src);$/;"	l
a	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
a	mpfrc++/mpreal.h	/^    mpreal a(x);$/;"	p
a	mpfrc++/mpreal.h	/^    mpreal a;$/;"	l
about.tex	doc/tex/about.tex	1;"	F
abs	mpfrc++/mpreal.h	/^    friend const mpreal abs(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
abs	mpfrc++/mpreal.h	/^inline const mpreal abs(const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
acos	mpfrc++/mpreal.h	/^    friend const mpreal acos  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
acosh	mpfrc++/mpreal.h	/^    friend const mpreal acosh (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
acot	mpfrc++/mpreal.h	/^    friend const mpreal acot  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
acoth	mpfrc++/mpreal.h	/^    friend const mpreal acoth (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
acsc	mpfrc++/mpreal.h	/^    friend const mpreal acsc  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
acsch	mpfrc++/mpreal.h	/^    friend const mpreal acsch (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
addedge	likelihoodfunc.hpp	/^    inline void addedge(const Edge& edge) {$/;"	f	class:ftree	access:public
addjoint	likelihoodfunc.hpp	/^    inline void addjoint(const Node& node, const uint& edgeid) { $/;"	f	class:ftree	access:public
addnode	likelihoodfunc.hpp	/^    inline void addnode(const Node& node) { nodes.emplace_back(node); }$/;"	f	class:ftree	access:public
addport	likelihoodfunc.hpp	/^    inline void addport(const uint& hubid, const Nodes& newport) { $/;"	f	class:ftree	access:public
addroute	likelihoodfunc.hpp	/^    inline void addroute(const Node& node, const uint& edgeid) {$/;"	f	class:ftree	access:public
adjustens	ensemble_factory.hpp	/^void adjustens(vpEnsemble& ens) {$/;"	f
agm	mpfrc++/mpreal.h	/^    friend const mpreal agm      (const mpreal& v1, const mpreal& v2, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
agm	mpfrc++/mpreal.h	/^inline const mpreal agm (const mpreal& v1, const mpreal& v2, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
ai	mpfrc++/mpreal.h	/^    friend const mpreal ai      (const mpreal& v,        mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
ai	mpfrc++/mpreal.h	/^inline const mpreal ai      (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(ai);          }$/;"	f	namespace:mpfr
ans	ensemble_factory.hpp	/^  vpEnsemble ans;$/;"	l
ans	fileio.hpp	/^      vector<V> ans;$/;"	l
ans	fileio.hpp	/^      vector<string> ans;$/;"	l
ans	fileio_utils.cpp	/^  array<string, 2> ans;$/;"	l
ans	fileio_utils.hpp	/^  T ans;$/;"	l
ans	fileio_utils.hpp	/^  vector<Tp> ans;$/;"	l
ans	gmxmdp.cpp	/^  auto ans = MDP::getlambdas();$/;"	l
ans	gnarray.hpp	/^  Telem ans = 0;$/;"	l
ans	gwham.hpp	/^  vector<vector<uint> > ans(matrix.size());$/;"	p
ans	hamiltonian.cpp	/^  valtype ans = 0.0;$/;"	l
ans	likelihoodfunc.hpp	/^      bool ans = true;$/;"	l
ans	likelihoodfunc.hpp	/^  vector<FTree> ans(Ntree);$/;"	p
ans	mc.hpp	/^      valtype ans = 0.0;$/;"	l
ans	mdp.hpp	/^      vector<valtype> ans;$/;"	l
ans	mdp_factory.hpp	/^  vector<PMDP> ans;$/;"	l
append	exception.hpp	/^    void append(const string& addmsg) { msg += addmsg; }$/;"	f	class:General_Exception	access:public
append	likelihoodfunc.hpp	/^	    root.append(branch, bedges[bedgeid]); $/;"	p
append	likelihoodfunc.hpp	/^	    root.append(branch, newedge);$/;"	p
append	likelihoodfunc.hpp	/^    inline ThisType& append(const ThisType& src, const Edge& junction) {$/;"	f	class:ftree	access:public
asec	mpfrc++/mpreal.h	/^    friend const mpreal asec  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
asech	mpfrc++/mpreal.h	/^    friend const mpreal asech (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
asin	mpfrc++/mpreal.h	/^    friend const mpreal asin  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
asinh	mpfrc++/mpreal.h	/^    friend const mpreal asinh (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
assign	densityofstate.hpp	/^      newexpf.assign(newexpf.size(), 0.0);$/;"	p
assign	likelihoodfunc.hpp	/^        graddf.assign(gradf.size(), 0.0);$/;"	p
atan	mpfrc++/mpreal.h	/^    friend const mpreal atan  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
atan2	mpfrc++/mpreal.h	/^    friend const mpreal atan2 (const mpreal& y, const mpreal& x, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
atanh	mpfrc++/mpreal.h	/^    friend const mpreal atanh (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
ax	minimizer/cg.hpp	/^		Doub ax,xx,xmin;$/;"	l
ax	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
b	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
base	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s, base, mode); $/;"	l
base	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode); $/;"	l
bedges	likelihoodfunc.hpp	/^          const auto& bedges = branch.getedges();$/;"	l
begin	densityofstate.hpp	/^    const_iterator begin() const { return DOS.begin(); }$/;"	f	class:DensityOfState	access:public
begin	densityofstate.hpp	/^    iterator begin() { return DOS.begin(); }$/;"	f	class:DensityOfState	access:public
begin	gnarray.hpp	/^    const_iterator begin() const;$/;"	p	class:gnarray	access:public
begin	gnarray.hpp	/^    iterator begin();$/;"	p	class:gnarray	access:public
begin	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::const_iterator gnarray<Tcoord,Telem,Tval>::begin() const {$/;"	f	class:gnarray
begin	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::iterator gnarray<Tcoord,Telem,Tval>::begin() {$/;"	f	class:gnarray
besselj0	mpfrc++/mpreal.h	/^    friend const mpreal besselj0 (const mpreal& v, mp_rnd_t rnd_mode); $/;"	p	class:mpfr::mpreal	access:friend
besselj1	mpfrc++/mpreal.h	/^    friend const mpreal besselj1 (const mpreal& v, mp_rnd_t rnd_mode); $/;"	p	class:mpfr::mpreal	access:friend
besseljn	mpfrc++/mpreal.h	/^    friend const mpreal besseljn (long n, const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
bessely0	mpfrc++/mpreal.h	/^    friend const mpreal bessely0 (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
bessely1	mpfrc++/mpreal.h	/^    friend const mpreal bessely1 (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
besselyn	mpfrc++/mpreal.h	/^    friend const mpreal besselyn (long n, const mpreal& v, mp_rnd_t rnd_mode); $/;"	p	class:mpfr::mpreal	access:friend
beta	mc.hpp	/^      const valtype beta = 1\/(kB*T);$/;"	l
beta	mc.hpp	/^    const valtype beta;$/;"	m	class:MC	access:private
bias	mc.cpp	/^    harmonic bias(dim,k,wincentr);$/;"	p	file:
bin	gnarray.hpp	/^    iterator bin(const vector<Tval>& data, const Telem& weight = 1);$/;"	p	class:gnarray	access:public
bin	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::iterator gnarray<Tcoord,Telem,Tval>::bin(const vector<Tval>& data, const Telem& weight) {$/;"	f	class:gnarray
bin	gwham.cpp	/^      const coordtype bin = it->first;$/;"	l
bin	gwham.cpp	/^      fcout << bin;$/;"	l
bin	mc.cpp	/^    const coordtype bin = it->first;$/;"	l
bin	mc.cpp	/^    fcout << bin;$/;"	l
bin	mc.hpp	/^	hist.bin(coord);$/;"	p
bind	functor.hpp	/^  -> decltype ( bind(f, forward<Params>(params)..., myplaceholder<indices+1>{}...) )$/;"	f
binsize	gnarray.hpp	/^    vector<Tval> binsize;$/;"	m	class:gnarray	access:private
binsize	gwham.hpp	/^     const vector<valtype> binsize;$/;"	m	class:WHAM	access:private
bit	gmxmdp.cpp	/^      const uint bit = bits[j];$/;"	l
bits2digits	mpfrc++/mpreal.h	/^inline int       bits2digits(mp_prec_t b);$/;"	p	namespace:mpfr
bits2digits	mpfrc++/mpreal.h	/^inline int bits2digits(mp_prec_t b)$/;"	f	namespace:mpfr
bitstr	gmxmdp.cpp	/^    const string& bitstr = dimstr[i];$/;"	l
bitunit	typedefs.hpp	/^const bitset<MAXNRST> bitunit = bitset<MAXNRST>(1);$/;"	v
bjoints	likelihoodfunc.hpp	/^          const auto& bjoints = branch.getjoints();$/;"	l
bracket	minimizer/cg.hpp	/^		dbrent.bracket(ax,xx,df1dim);$/;"	p
bracket	minimizer/cg.hpp	/^	void bracket(const Doub a, const Doub b, T &func)$/;"	f	struct:Bracketmethod	access:public
branch	likelihoodfunc.hpp	/^      auto& branch = trees[j];$/;"	l
broutes	likelihoodfunc.hpp	/^      auto& broutes = branch.getroutes();$/;"	l
build_debug.sh	build_debug.sh	1;"	F
build_doc.sh	doc/build_doc.sh	1;"	F
build_mpreal_debug.sh	build_mpreal_debug.sh	1;"	F
build_mpreal_release.sh	build_mpreal_release.sh	1;"	F
build_release.sh	build_release.sh	1;"	F
buildftree	likelihoodfunc.hpp	/^  friend vector<ThisType> buildftree<ThisType>(const vector<vector<uint>>&, vector<V>&);$/;"	p	class:ftree	access:friend
buildftree	likelihoodfunc.hpp	/^vector<FTree> buildftree(const vector<vector<uint>>& nbnodes, vector<typename FTree::Data>& f) {$/;"	f
buildnblist	gwham.hpp	/^vector<vector<uint> > buildnblist(const vector<vector<T>>& matrix) {$/;"	f
bx	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
c	likelihoodfunc.hpp	/^          const auto& c = itC->second;$/;"	l
c_str	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode); $/;"	p
calrho	gwham.hpp	/^    NARRAY calrho(const vector<uint>& dim, const pEnsemble& _V) const;$/;"	p	class:WHAM	access:public
calrho	gwham.hpp	/^NARRAY WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::calrho(const vector<uint>& _dim, const pEnsemble& _V) const {$/;"	f	class:WHAM
can_be_const_iterate	metaprog_snippets.hpp	/^struct can_be_const_iterate {$/;"	s
can_be_const_iterate::type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:can_be_const_iterate	access:public
can_be_get	metaprog_snippets.hpp	/^struct can_be_get {$/;"	s
can_be_get::type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:can_be_get	access:public
can_be_streamed	metaprog_snippets.hpp	/^struct can_be_streamed {$/;"	s
canonical_valseries	gnarray.hpp	/^    vector<vector<Tval> > canonical_valseries() const; $/;"	p	class:gnarray	access:public
canonical_valseries	gnarray.hpp	/^vector<vector<Tval> > gnarray<Tcoord,Telem,Tval>::canonical_valseries() const {$/;"	f	class:gnarray
cbrt	mpfrc++/mpreal.h	/^    friend const mpreal cbrt(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
ceil	mpfrc++/mpreal.h	/^    friend const mpreal ceil (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
ceil	mpfrc++/mpreal.h	/^inline const mpreal ceil(const mpreal& v)$/;"	f	namespace:mpfr
cg.hpp	minimizer/cg.hpp	1;"	F
check_if	metaprog_snippets.hpp	/^struct check_if$/;"	s
check_if::declval	metaprog_snippets.hpp	/^      std::declval<typename Condition::template type<C>>(), $/;"	p	struct:check_if	access:public
check_if::std::false_type	metaprog_snippets.hpp	/^  template < class C > static auto f(...) -> std::false_type;$/;"	m	class:check_if::std	access:public
check_if::std::true_type	metaprog_snippets.hpp	/^      std::true_type() $/;"	p	class:check_if::std	access:public
check_if::value	metaprog_snippets.hpp	/^  constexpr static bool value = decltype(f<T>(0))::value;$/;"	m	struct:check_if	access:public
check_range	mpfrc++/mpreal.h	/^    int check_range  (int t, mp_rnd_t rnd_mode = get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
checkfep	gmxmdp.cpp	/^void GMXMDP::checkfep() {$/;"	f	class:GMXMDP
checkfep	gmxmdp.hpp	/^    void checkfep();$/;"	p	class:GMXMDP	access:private
checkgeneric	gmxmdp.cpp	/^void GMXMDP::checkgeneric() {$/;"	f	class:GMXMDP
checkgeneric	gmxmdp.hpp	/^    void checkgeneric();$/;"	p	class:GMXMDP	access:private
checkpull	gmxmdp.cpp	/^void GMXMDP::checkpull() {$/;"	f	class:GMXMDP
checkpull	gmxmdp.hpp	/^    void checkpull();$/;"	p	class:GMXMDP	access:private
chkmdp	ensemble_factory.hpp	/^chkmdp ( const PMDP& pmdp )$/;"	f
clear	fileio.cpp	/^    if(emptyline()) { line.clear(); continue; }$/;"	p	file:
clear	fileio.cpp	/^    line.clear();$/;"	p	file:
clear	fileio.cpp	/^  if(!line.empty()) { line.clear(); }$/;"	p	file:
clear	fileio.cpp	/^  if(!lines.empty()) { lines.clear(); }$/;"	p	file:
clear	fileio.cpp	/^  line.clear();$/;"	p	file:
clear	fileio.hpp	/^	  line.clear();$/;"	p
clear	fileio.hpp	/^        else if(lc % ls) { line.clear(); continue; }$/;"	p
clear	fileio.hpp	/^        else if(lc > le) { line.clear(); break; }$/;"	p
clear	fileio.hpp	/^        if(lc < lb) { line.clear(); continue; }$/;"	p
clear	fileio.hpp	/^      line.clear();$/;"	p
clear	gmxmdp.cpp	/^  Ps.clear();$/;"	p	file:
clear	gmxmdp.cpp	/^  Ts.clear();$/;"	p	file:
clear	gmxmdp.cpp	/^  rstfuncts.clear();$/;"	p	file:
clear	gmxmdp.hpp	/^    rstfuncts.clear();$/;"	p
clear	hamiltonian.cpp	/^  potentials.clear();$/;"	p	file:
clear	mdp.hpp	/^      rstfuncts.clear();$/;"	p
clear	mpfrc++/mpreal.h	/^    void clear(::mpfr_ptr);$/;"	p	class:mpfr::mpreal	access:private
clear	mpfrc++/mpreal.h	/^inline void mpreal::clear(::mpfr_ptr x)$/;"	f	class:mpfr::mpreal
close	fileio.cpp	/^  if(fs.is_open()) { fs.close(); }$/;"	p	file:
cmdline	gwham.cpp	/^    cerr << cmdline;$/;"	l
cmdline	gwham.cpp	/^  fcout << cmdline;$/;"	l
cmp	ensemble.cpp	/^uint NPT::cmp(const Ensemble& src) const {$/;"	f	class:NPT
cmp	ensemble.cpp	/^uint NVE::cmp(const Ensemble& src) const {$/;"	f	class:NVE
cmp	ensemble.cpp	/^uint NVT::cmp(const Ensemble& src) const {$/;"	f	class:NVT
cmp	ensemble.hpp	/^    virtual uint cmp(const Ensemble& src) const = 0;$/;"	p	class:Ensemble	access:public
cmp	ensemble.hpp	/^    virtual uint cmp(const Ensemble& src) const;$/;"	p	class:NPT	access:public
cmp	ensemble.hpp	/^    virtual uint cmp(const Ensemble& src) const;$/;"	p	class:NVE	access:public
cmp	ensemble.hpp	/^    virtual uint cmp(const Ensemble& src) const;$/;"	p	class:NVT	access:public
cmpabs	mpfrc++/mpreal.h	/^    friend int cmpabs(const mpreal& a,const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
cmpens	ensemble_factory.hpp	/^cmpens(const vector<pE>& pens) {$/;"	f
colids	timeseries.hpp	/^    vector<uint> colids;$/;"	m	class:TimeSeries	access:protected
cols	gwham.cpp	/^    const auto cols = fio_hist.line2val<string>();$/;"	l
cols	timeseries.hpp	/^	const vector<valtype> cols(fio.line2val());$/;"	p
cols	timeseries.hpp	/^          const vector<valtype> cols(fio.line2val());$/;"	p
comments	fileio.hpp	/^    const string comments;$/;"	m	class:fileio	access:public
const_catalan	mpfrc++/mpreal.h	/^    friend const mpreal const_catalan   (mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
const_catalan	mpfrc++/mpreal.h	/^inline const mpreal const_catalan (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
const_euler	mpfrc++/mpreal.h	/^    friend const mpreal const_euler     (mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
const_euler	mpfrc++/mpreal.h	/^inline const mpreal const_euler (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
const_infinity	mpfrc++/mpreal.h	/^    friend const mpreal const_infinity(int sign, mp_prec_t prec);$/;"	p	class:mpfr::mpreal	access:friend
const_infinity	mpfrc++/mpreal.h	/^inline const mpreal const_infinity (int sign = 1, mp_prec_t p = mpreal::get_default_prec())$/;"	f	namespace:mpfr
const_iterator	densityofstate.hpp	/^    typedef typename narray::const_iterator const_iterator;$/;"	t	class:DensityOfState	access:public
const_iterator	gnarray.hpp	/^    typedef typename map<Tcoord, Telem>::const_iterator const_iterator;$/;"	t	class:gnarray	access:public
const_log2	mpfrc++/mpreal.h	/^    friend const mpreal const_log2      (mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
const_log2	mpfrc++/mpreal.h	/^inline const mpreal const_log2 (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
const_pi	mpfrc++/mpreal.h	/^    friend const mpreal const_pi        (mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
const_pi	mpfrc++/mpreal.h	/^inline const mpreal const_pi (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
conversion_overflow	mpfrc++/mpreal.h	/^class conversion_overflow : public std::exception {$/;"	c	namespace:mpfr	inherits:std::exception
coord	gnarray.hpp	/^      coord.push_back( (i%stride_array[j]) \/ stride_array[j+1] );$/;"	p
coord	gnarray.hpp	/^    Tcoord coord;$/;"	l
coord	gnarray.hpp	/^    const Tcoord coord = it->first;$/;"	l
coord	gnarray.hpp	/^    const auto& coord = it->first;$/;"	l
coord	gnarray.hpp	/^    fcout << coord;$/;"	l
coord	gnarray.hpp	/^  Tcoord coord;$/;"	l
coord	gnarray.hpp	/^  const Tcoord coord = val2coord(data);$/;"	l
coord	gwham.cpp	/^      const coordtype coord = it->first;$/;"	l
coord	gwham.cpp	/^    const auto& coord = it->first;$/;"	l
coord	gwham.cpp	/^    fcout << coord;$/;"	l
coord	gwham.cpp	/^    histogram::gridcoord coord;$/;"	l
coord	gwham.hpp	/^	const auto& coord = it->first;$/;"	l
coord	gwham.hpp	/^    const coordtype coord = it->first;$/;"	l
coord	mc.cpp	/^      const coordtype coord = it->first;$/;"	l
coord	mc.hpp	/^	vector<valtype> coord;$/;"	l
coord	mc.hpp	/^      vector<valtype> coord  = init_coord;$/;"	l
coord2	mc.hpp	/^	const valtype coord2 = coord[i]*coord[i];$/;"	l
coord2val	gnarray.hpp	/^    const vector<Tval> coord2val(const Tcoord& coord) const;$/;"	p	class:gnarray	access:public
coord2val	gnarray.hpp	/^const vector<Tval> gnarray<Tcoord,Telem,Tval>::coord2val(const Tcoord& coord) const {$/;"	f	class:gnarray
coord2val	gwham.hpp	/^    const vector<valtype> coord2val(const coordtype& coord) const;$/;"	p	class:WHAM	access:public
coord2val	gwham.hpp	/^    const vector<valtype> coord2val(const vector<uint>& _dim, const coordtype& coord) const;$/;"	p	class:WHAM	access:public
coord2val	gwham.hpp	/^const vector<valtype> WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::coord2val(const coordtype& coord) const {$/;"	f	class:WHAM
coord2val	gwham.hpp	/^const vector<valtype> WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::coord2val(const vector<uint>& _dim, const coordtype& coord) const {$/;"	f	class:WHAM
coordstr	gwham.cpp	/^    const vector<string> coordstr(cols.begin(), cols.begin()+ndim);$/;"	p	file:
coordtype	typedefs.hpp	/^typedef vector<uint> coordtype; \/\/type of the coordinate for histogram and narray$/;"	t
cos	mpfrc++/mpreal.h	/^    friend const mpreal cos(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
cosh	mpfrc++/mpreal.h	/^    friend const mpreal cosh  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
cot	mpfrc++/mpreal.h	/^    friend const mpreal cot(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
coth	mpfrc++/mpreal.h	/^    friend const mpreal coth  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
count	gwham.cpp	/^  linecounter count = 0;$/;"	l
count	gwham.hpp	/^  if(count % 100 == 0) { cout << "#At the " << count << "'th iteration\\n"; printfree(); } $/;"	l
count	gwham.hpp	/^  ulong count = 0;$/;"	l
cpTo	functor.hpp	/^    typedef const To* const cpTo;$/;"	t	class:Functor	access:public
csc	mpfrc++/mpreal.h	/^    friend const mpreal csc(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
csch	mpfrc++/mpreal.h	/^    friend const mpreal csch  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
ctz	metaprog_snippets.hpp	/^ctz(T a) $/;"	f
cx	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
d	likelihoodfunc.hpp	/^          const auto d = dos(itC, itsNgexpmH, expf);$/;"	l
d	mc.cpp	/^    const valtype d = pmf-pmf_analytic;$/;"	l
d	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
d1	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
d2	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
dE	mc.hpp	/^	const valtype dE = newE - E;$/;"	l
data	gmxmdp.hpp	/^    const T& data = it->second.get();$/;"	l
data	gwham.cpp	/^  vector<valtype> data = input;$/;"	l
dblopts	gmxmdp.hpp	/^    typedef map<string, valref> dblopts;$/;"	t	class:GMXMDP	access:public
dbrent	minimizer/cg.hpp	/^		Dbrent dbrent(ftol);$/;"	p
decision	metaprog_snippets.hpp	/^  constexpr static bool decision = sizeof...(indices) >= Max ? true : false;$/;"	m	struct:StopAtMaxN	access:public
decltype	functor.hpp	/^  -> decltype (dummy)$/;"	f
declval	metaprog_snippets.hpp	/^      std::declval<typename Condition::template type<C>>(), $/;"	p	struct:check_if	access:public
den	minimizer/cg.hpp	/^			Doub den=MAX(fp, Doub{1.0});$/;"	l
denorm_min	mpfrc++/mpreal.h	/^        inline static const mpfr::mpreal denorm_min()       { return (min)();                    }$/;"	f	class:std::numeric_limits	access:public
densityofstate.hpp	densityofstate.hpp	1;"	F
denum	densityofstate.hpp	/^      valtype denum = 0.0;$/;"	v
dev	functor.hpp	/^  const T dev = r - ref;$/;"	l
dev	mc.hpp	/^	const valtype dev = coord[i] - r[i];$/;"	l
df	gwham.hpp	/^    vector<valtype> df(expf.size()-1, 0.0);$/;"	p
df	likelihoodfunc.hpp	/^    void df (const vector<valtype>& deltaf, vector<valtype>& _graddf) {$/;"	f	class:LikeliHoodFunc	access:public
df	minimizer/cg.hpp	/^			func.df(p,xi);$/;"	p
df	minimizer/cg.hpp	/^		func.df(p,xi);$/;"	p
df	minimizer/cg.hpp	/^		funcd.df(xt,dft);$/;"	p
df	minimizer/cg.hpp	/^	Doub df(const Doub x)$/;"	f	struct:Df1dim	access:public
df1	minimizer/cg.hpp	/^		Doub df1=0.0;$/;"	l
df1dim	minimizer/cg.hpp	/^		Df1dim<T> df1dim(p,xi,func);$/;"	p
dft	minimizer/cg.hpp	/^	VecDoub dft;$/;"	m	struct:Df1dim	access:public
dgg	minimizer/cg.hpp	/^		Doub gg,dgg;$/;"	l
digamma	mpfrc++/mpreal.h	/^    friend const mpreal digamma (const mpreal& v,        mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
digamma	mpfrc++/mpreal.h	/^inline const mpreal digamma (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(digamma);     }$/;"	f	namespace:mpfr
digits	mpfrc++/mpreal.h	/^        inline static int digits()                        {    return int(mpfr::mpreal::get_default_prec());    }$/;"	f	class:std::numeric_limits	access:public
digits	mpfrc++/mpreal.h	/^        inline static int digits(const mpfr::mpreal& x)   {    return x.getPrecision();                         }$/;"	f	class:std::numeric_limits	access:public
digits	mpfrc++/mpreal.h	/^        static const int digits       = 53;$/;"	m	class:std::numeric_limits	access:public
digits	mpfrc++/mpreal.h	/^    format << "%." << digits << "RNg";$/;"	l
digits	mpfrc++/mpreal.h	/^    int digits = (n >= 0) ? n : bits2digits(mpfr_get_prec(mpfr_srcptr()));$/;"	l
digits10	mpfrc++/mpreal.h	/^        inline static int digits10(const mpfr::mpreal& x)$/;"	f	class:std::numeric_limits	access:public
digits10	mpfrc++/mpreal.h	/^        inline static int digits10(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits	access:public
digits10	mpfrc++/mpreal.h	/^        static const int digits10     = 15;$/;"	m	class:std::numeric_limits	access:public
digits2bits	gwham.cpp	/^  mpreal::set_default_prec(mpfr::digits2bits(MPREAL_PRECISION));$/;"	p	class:mpreal	file:
digits2bits	mpfrc++/mpreal.h	/^inline mp_prec_t digits2bits(int d)$/;"	f	namespace:mpfr
digits2bits	mpfrc++/mpreal.h	/^inline mp_prec_t digits2bits(int d);$/;"	p	namespace:mpfr
dim	gmxmdp.hpp	/^    int dim = 0;$/;"	m	class:GMXMDP	access:public
dim	gnarray.hpp	/^    uint dim;$/;"	m	class:gnarray	access:private
dim	gwham.hpp	/^     const uint dim;$/;"	m	class:WHAM	access:private
dim	mc.cpp	/^  const uint dim = atoi(argv[1]);$/;"	l
dim	mc.hpp	/^      const uint dim = coord.size();$/;"	l
dim	mc.hpp	/^    const uint dim;$/;"	m	class:harmonic	access:private
dim	mc.hpp	/^    const uint dim;$/;"	m	class:potpoly_dblwell	access:private
dim	mpfrc++/mpreal.h	/^    friend const mpreal dim(const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
dimindex	gnarray.hpp	/^    const uint dimindex = _dim[i];$/;"	l
dimindex	gwham.hpp	/^    const uint dimindex = _dim[i];$/;"	l
dimprt	mc.cpp	/^  vector<uint> nbins, nwins, dimprt;$/;"	l
dimprtstr	mc.cpp	/^  const string dimprtstr = string(argv[9]);$/;"	l
dimstr	gmxmdp.hpp	/^    vector<string> dimstr;$/;"	m	class:GMXMDP	access:public
div_2si	mpfrc++/mpreal.h	/^    friend inline const mpreal div_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
div_2si	mpfrc++/mpreal.h	/^inline const mpreal div_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
div_2si	mpfrc++/mpreal.h	/^inline const mpreal div_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
div_2ui	mpfrc++/mpreal.h	/^    friend inline const mpreal div_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
div_2ui	mpfrc++/mpreal.h	/^inline const mpreal div_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
div_2ui	mpfrc++/mpreal.h	/^inline const mpreal div_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
doc.tex	doc/tex/doc.tex	1;"	F
dos	densityofstate.hpp	/^	const auto dos = this->operator()(itC, itsNgexpmH, expf);$/;"	l
dos	likelihoodfunc.hpp	/^    DOS& dos;$/;"	m	class:LikeliHoodFunc	access:private
doscit	likelihoodfunc.hpp	/^  typedef typename DOS::const_iterator doscit;$/;"	t	class:LikeliHoodFunc	access:private
dosit	likelihoodfunc.hpp	/^  typedef typename DOS::iterator dosit;$/;"	t	class:LikeliHoodFunc	access:private
doublechk	gmxmdp.cpp	/^void GMXMDP::doublechk() {$/;"	f	class:GMXMDP
doublechk	gmxmdp.hpp	/^    virtual void doublechk();$/;"	p	class:GMXMDP	access:private
doublechk	mdp.hpp	/^    virtual void doublechk() = 0;$/;"	p	class:MDP	access:private
dpmf	mc.cpp	/^  vector<valtype> dpmf;$/;"	l
dr	functor.hpp	/^  const T dr = r - r0;$/;"	l
dt	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, ncntgrps, nstx*dt);$/;"	l
dt	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, npgrps, nstx*dt);$/;"	l
dt	gmxmdp.cpp	/^    ans.emplace_back(fileio(fstream::in, false, 0, ls, MAXNLINE, "#@"), "dhdl.xvg", 2, iNcol, 1, nstdhdl*dt);$/;"	l
dt	gmxmdp.cpp	/^    ans.emplace_back(fileio(fstream::in, false, 0, lse, MAXNLINE, "#@"), "ener.xvg", Mask, iNcol, oNcol, nstenergy*dt);$/;"	l
dt	mdp.hpp	/^    valtype dt = 0;$/;"	m	class:MDP	access:protected
du	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
dv	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
dw	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
dx	mc.hpp	/^      vector<valtype> dx(dim,0.0);$/;"	p
dx	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
dx_tot	mc.hpp	/^      valtype dx_tot = 1.0;$/;"	l
e	gwham.hpp	/^	const valtype e = exp(exparg);$/;"	l
e	likelihoodfunc.hpp	/^  	  const auto e = exp(fi);$/;"	l
e	minimizer/cg.hpp	/^		Doub a,b,d=0.0,d1,d2,du,dv,dw,dx,e=0.0;$/;"	l
edge	gwham.hpp	/^      const auto& edge = edges[i];$/;"	l
edge	likelihoodfunc.hpp	/^	  const auto& edge = edges[i];$/;"	l
edge	likelihoodfunc.hpp	/^      const auto& edge = edges[edgeid];$/;"	l
edges	gwham.hpp	/^    const auto& edges = tree.getedges();$/;"	l
edges	likelihoodfunc.hpp	/^	const auto& edges = tree.getedges();$/;"	l
edges	likelihoodfunc.hpp	/^    Edges edges;$/;"	m	class:ftree	access:public
edgesize	likelihoodfunc.hpp	/^    inline uint edgesize() const { return edges.size(); }$/;"	f	class:ftree	access:public
eint	mpfrc++/mpreal.h	/^    friend const mpreal eint   (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
eitas	mc.cpp	/^  vector<valtype> eitas = wham.whamvsraw(rho);$/;"	l
elem	gnarray.hpp	/^    const Telem elem = it->second;$/;"	l
emplace_back	ensemble_factory.hpp	/^    ens.emplace_back(newpens);$/;"	p
emplace_back	fileio_utils.hpp	/^    output.emplace_back(val);$/;"	p
emplace_back	gmxmdp.cpp	/^        rstfuncts[i].emplace_back(pgrprst[i]);$/;"	p	file:
emplace_back	gmxmdp.cpp	/^      for(int k = 0; k < ncntgrps; ++k) { pgrps.emplace_back(k); }$/;"	p	file:
emplace_back	gmxmdp.cpp	/^      lambdas.emplace_back(Lcnt1);$/;"	p	file:
emplace_back	gmxmdp.cpp	/^      lambdas.emplace_back(Lcnt2);$/;"	p	file:
emplace_back	gmxmdp.cpp	/^      lambdas.emplace_back(Lcnt3);$/;"	p	file:
emplace_back	gmxmdp.cpp	/^      lambdas.emplace_back(Ls[Lrst]);$/;"	p	file:
emplace_back	gmxmdp.cpp	/^  for(const auto& rstfunct : rstfuncts) Hs.emplace_back(rstfunct);$/;"	p	file:
emplace_back	gmxmdp.hpp	/^      rstfuncts.emplace_back(rstfunct);$/;"	p
emplace_back	gwham.hpp	/^    for(const auto& nb : seen) nbi.emplace_back(nb.first);$/;"	p
emplace_back	gwham.hpp	/^    nbi.emplace_back(imax);$/;"	p
emplace_back	hamiltonian.cpp	/^  for(const auto& srcpot : srcpots) potentials.emplace_back(srcpot);$/;"	p	file:
emplace_back	likelihoodfunc.hpp	/^        edges.emplace_back(edge);$/;"	p
emplace_back	likelihoodfunc.hpp	/^        edges.emplace_back(newedge);$/;"	p
emplace_back	likelihoodfunc.hpp	/^    inline void addnode(const Node& node) { nodes.emplace_back(node); }$/;"	p
emplace_back	mdp.hpp	/^	rstfuncts.emplace_back(rstfunct);$/;"	p
emplace_back	mdp_factory.hpp	/^      ans.emplace_back( suffix2mdp.find(MDPsuffix)->second(fmdp) );$/;"	p
emplace_back	timeseries.hpp	/^	  colids.emplace_back(i);$/;"	p
empty	likelihoodfunc.hpp	/^    inline bool empty() const { return !(nodes.size() || edges.size() || routes.size() || ports.size()); } $/;"	f	class:ftree	access:public
emptyline	fileio.hpp	/^    bool emptyline() const { return emptystr(line, comments); }$/;"	f	class:fileio	access:public
emptystr	fileio_utils.cpp	/^bool emptystr(const string& input, const string& comments) {$/;"	f
emptystr	fileio_utils.hpp	/^bool emptystr(const string& input, const string& comments);$/;"	p
end	densityofstate.hpp	/^    const_iterator end() const { return DOS.end(); }$/;"	f	class:DensityOfState	access:public
end	densityofstate.hpp	/^    iterator end() { return DOS.end(); }$/;"	f	class:DensityOfState	access:public
end	gnarray.hpp	/^    const_iterator end() const;$/;"	p	class:gnarray	access:public
end	gnarray.hpp	/^    iterator end();$/;"	p	class:gnarray	access:public
end	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::const_iterator gnarray<Tcoord,Telem,Tval>::end() const {$/;"	f	class:gnarray
end	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::iterator gnarray<Tcoord,Telem,Tval>::end() {$/;"	f	class:gnarray
endit	gwham.hpp	/^     bool endit(const vector<valtype>& newexpf, const ulong& count); $/;"	p	class:WHAM	access:private
endit	gwham.hpp	/^bool WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::endit(const vector<valtype>& newexpf, const ulong& count) {$/;"	f	class:WHAM
endl	fileio.cpp	/^    cout << "#Opening file: " << fname << endl;$/;"	l
endl	gmxmdp.cpp	/^      fcout << endl;$/;"	l
endl	gmxmdp.cpp	/^  fcout << kB << endl;$/;"	l
endl	gmxmdp.hpp	/^    fcout << data << endl;$/;"	l
endl	gnarray.hpp	/^    fcout << vals << elem << endl;$/;"	l
endl	gnarray.hpp	/^    fcout << vals << elem\/norm << endl;$/;"	l
endl	gwham.cpp	/^      fcout << endl;$/;"	l
endl	gwham.cpp	/^      fcout << rhonorm << endl;$/;"	l
endl	gwham.cpp	/^    fcout << endl;$/;"	l
endl	gwham.cpp	/^    fcout << histid << endl;$/;"	l
endl	gwham.cpp	/^  fcout << "#Number of samples: " << Nsamples << endl;$/;"	l
endl	gwham.cpp	/^  fcout << endl;$/;"	l
endl	gwham.cpp	/^  for(auto oi : overlap) { cout << "# "; fcout << oi << endl; }$/;"	l
endl	gwham.hpp	/^      cout << *edge[1] << " - " << *edge[0] << " = " << df[i] << endl;$/;"	l
endl	gwham.hpp	/^    cerr << "The number of dimension can't be larger than " << dim << endl;$/;"	l
endl	gwham.hpp	/^  cout << "#WHAM converge to " << tol << " after " << count << " iterations" << endl;$/;"	l
endl	gwham.hpp	/^  fcout << _dim << endl;$/;"	l
endl	gwham.hpp	/^  for(uint i = 0; i < f.size(); ++i) cout << "# " << i << "\\t" << f[i] << endl;$/;"	l
endl	mc.cpp	/^      cerr << "The dimension to be printed out must be less than " << dim << endl;$/;"	l
endl	mc.cpp	/^    cerr << "The size of nbins, hv, lv, nwins aren't all " << dim << endl;$/;"	l
endl	mc.cpp	/^    cout << "# Running window " << i << endl;$/;"	l
endl	mc.cpp	/^    fcout << rhonorm << endl;$/;"	l
endl	mc.cpp	/^    fcout << rstcenter << eitas[i] << endl;$/;"	l
endl	mc.cpp	/^  cout << "# WHAM - Analytic " << endl;$/;"	l
endl	mc.cpp	/^  cout << endl;$/;"	l
endl	minimizer/cg.hpp	/^			  cout << "#Convergence met at iteration " << its << " because gradient is smaller than " << GTOL << endl;$/;"	l
endl	minimizer/cg.hpp	/^			  cout << "#Convergence met at iteration " << its << " because the relative difference in F(p) between 2 consecutive iteration is smaller than " << scientific << ftol << endl;$/;"	l
endl	minimizer/cg.hpp	/^			  cout << "#Convergence met at iteration " << its << " because the search direction vector is exactly zero" << endl;$/;"	l
endl	minimizer/cg.hpp	/^			  for(uint i = 0; i < p.size(); ++i) cout << "#\\t" << i << "\\t" << p[i] << endl;$/;"	l
ener	ensemble.cpp	/^valtype NPT::ener(const vector<valtype>& vals) const {$/;"	f	class:NPT
ener	ensemble.cpp	/^valtype NVE::ener(const vector<valtype>& vals) const {$/;"	f	class:NVE
ener	ensemble.cpp	/^valtype NVT::ener(const vector<valtype>& vals) const {$/;"	f	class:NVT
ener	ensemble.hpp	/^    valtype ener(const vector<valtype>& vals) const; $/;"	p	class:NPT	access:public
ener	ensemble.hpp	/^    virtual valtype ener(const vector<valtype>& vals) const = 0;$/;"	p	class:Ensemble	access:public
ener	ensemble.hpp	/^    virtual valtype ener(const vector<valtype>& vals) const; $/;"	p	class:NVT	access:public
ener	ensemble.hpp	/^    virtual valtype ener(const vector<valtype>& vals) const;$/;"	p	class:NVE	access:public
ener	hamiltonian.cpp	/^valtype Hamiltonian::ener(const vector<valtype>& vals) const {$/;"	f	class:Hamiltonian
ener	hamiltonian.hpp	/^    valtype ener(const vector<valtype>& vals) const;$/;"	p	class:Hamiltonian	access:public
ener	mc.hpp	/^    valtype ener(const vector<valtype>& coord) const {$/;"	f	class:harmonic	access:public
ensemble.cpp	ensemble.cpp	1;"	F
ensemble.hpp	ensemble.hpp	1;"	F
ensemble_factory.hpp	ensemble_factory.hpp	1;"	F
epsilon	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal epsilon(const mpfr::mpreal& x) {  return mpfr::machine_epsilon(x);  }$/;"	f	class:std::numeric_limits	access:public
epsilon	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal epsilon(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::machine_epsilon(precision); }$/;"	f	class:std::numeric_limits	access:public
erase	gmxmdp.cpp	/^      lambdas.erase(lambdas.begin()); $/;"	p	file:
erase	gwham.hpp	/^      if(it != seen.end()) seen.erase(it);$/;"	p
erase	likelihoodfunc.hpp	/^	ans.erase(ans.begin() + j);$/;"	p
erase	likelihoodfunc.hpp	/^	trees.erase(trees.begin()+j);$/;"	p
erase	likelihoodfunc.hpp	/^          trees.erase(trees.begin()+j);$/;"	p
erf	mpfrc++/mpreal.h	/^    friend const mpreal erf      (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
erfc	mpfrc++/mpreal.h	/^    friend const mpreal erfc     (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
eta	gwham.hpp	/^  valtype eta = 0; \/\/eta in equation 41 from reference DOI: 10.1002\/jcc.21989$/;"	l
etas	gwham.hpp	/^  vector<valtype> etas;$/;"	l
exception.hpp	exception.hpp	1;"	F
exp	mpfrc++/mpreal.h	/^    friend const mpreal exp  (const mpreal& v, mp_rnd_t rnd_mode); $/;"	p	class:mpfr::mpreal	access:friend
exp10	mpfrc++/mpreal.h	/^    friend const mpreal exp10(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
exp2	mpfrc++/mpreal.h	/^    friend const mpreal exp2 (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
expandpgrps	gmxmdp.cpp	/^void GMXMDP::expandpgrps() {$/;"	f	class:GMXMDP
expandpgrps	gmxmdp.hpp	/^    void expandpgrps();$/;"	p	class:GMXMDP	access:private
exparg	gwham.hpp	/^      const auto exparg = -(*V)[k]->ener(vals);$/;"	l
exparg	gwham.hpp	/^    const valtype exparg = -_V->ener(vals);$/;"	l
expf	gwham.hpp	/^     vector<valtype> expf;$/;"	m	class:WHAM	access:private
expf	likelihoodfunc.hpp	/^    vector<valtype>& expf;$/;"	m	class:LikeliHoodFunc	access:private
expm1	mpfrc++/mpreal.h	/^    friend const mpreal expm1(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
expmH	gwham.hpp	/^  vector<NARRAY> expmH;$/;"	l
f	gwham.hpp	/^     vector<valtype> f;$/;"	m	class:WHAM	access:private
f	likelihoodfunc.hpp	/^    vector<valtype>& f;$/;"	m	class:LikeliHoodFunc	access:private
f	metaprog_snippets.hpp	/^    ThisType& operator<< (S& (*f)(S&)) {$/;"	f	class:FormatStream	access:public
fa	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
fabs	mpfrc++/mpreal.h	/^    friend const mpreal fabs(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
fac_ui	mpfrc++/mpreal.h	/^    friend const mpreal fac_ui (unsigned long int v,  mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
false_type	metaprog_snippets.hpp	/^  template < class C > static auto f(...) -> std::false_type;$/;"	m	class:check_if::std	access:public
fb	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
fc	minimizer/cg.hpp	/^	Doub ax,bx,cx,fa,fb,fc;$/;"	m	struct:Bracketmethod	access:public
fconst	gmxmdp.cpp	/^	  const valtype fconst = ((1-L)*pgrp.k + L*pgrp.kB)\/2;$/;"	l
fepT	gmxmdp.hpp	/^    enum FEPType {NoFEP, Yes, Expanded, NFEPTypes} fepT = NFEPTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::FEPType	access:public
fepTstr	gmxmdp.hpp	/^    string fepTstr = "fepTstr";$/;"	m	class:GMXMDP	access:public
fi	likelihoodfunc.hpp	/^	  const auto& fi = *itfi;$/;"	l
fileio	fileio.cpp	/^fileio::fileio($/;"	f	class:fileio
fileio	fileio.cpp	/^fileio::fileio(const fileio& _fio) :$/;"	f	class:fileio
fileio	fileio.hpp	/^    fileio(const fileio& _fio);$/;"	p	class:fileio	access:public
fileio	fileio.hpp	/^    fileio(const ios_base::openmode& mode, const bool& perm=true, const linecounter _lb=0, const linecounter _ls=1, const linecounter _le=MAXNLINE, const string& cm="#@;");$/;"	p	class:fileio	access:public
fileio	fileio.hpp	/^    fileio(const string& _fname, const ios_base::openmode& mode, const bool& perm=true, const linecounter _lb=0, const linecounter _ls=1, const linecounter _le=MAXNLINE, const string& cm="#@;");$/;"	p	class:fileio	access:public
fileio	fileio.hpp	/^class fileio {$/;"	c
fileio	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, ncntgrps, nstx*dt);$/;"	p	file:
fileio	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, npgrps, nstx*dt);$/;"	p	file:
fileio	gmxmdp.cpp	/^    ans.emplace_back(fileio(fstream::in, false, 0, ls, MAXNLINE, "#@"), "dhdl.xvg", 2, iNcol, 1, nstdhdl*dt);$/;"	p	file:
fileio	gmxmdp.cpp	/^    ans.emplace_back(fileio(fstream::in, false, 0, lse, MAXNLINE, "#@"), "ener.xvg", Mask, iNcol, oNcol, nstenergy*dt);$/;"	p	file:
fileio.cpp	fileio.cpp	1;"	F
fileio.hpp	fileio.hpp	1;"	F
fileio::ans	fileio.hpp	/^      vector<V> ans;$/;"	l
fileio::ans	fileio.hpp	/^      vector<string> ans;$/;"	l
fileio::clear	fileio.hpp	/^	  line.clear();$/;"	p
fileio::clear	fileio.hpp	/^        else if(lc % ls) { line.clear(); continue; }$/;"	p
fileio::clear	fileio.hpp	/^        else if(lc > le) { line.clear(); break; }$/;"	p
fileio::clear	fileio.hpp	/^        if(lc < lb) { line.clear(); continue; }$/;"	p
fileio::clear	fileio.hpp	/^      line.clear();$/;"	p
fileio::comments	fileio.hpp	/^    const string comments;$/;"	m	class:fileio	access:public
fileio::emptyline	fileio.hpp	/^    bool emptyline() const { return emptystr(line, comments); }$/;"	f	class:fileio	access:public
fileio::fileio	fileio.cpp	/^fileio::fileio($/;"	f	class:fileio
fileio::fileio	fileio.cpp	/^fileio::fileio(const fileio& _fio) :$/;"	f	class:fileio
fileio::fileio	fileio.hpp	/^    fileio(const fileio& _fio);$/;"	p	class:fileio	access:public
fileio::fileio	fileio.hpp	/^    fileio(const ios_base::openmode& mode, const bool& perm=true, const linecounter _lb=0, const linecounter _ls=1, const linecounter _le=MAXNLINE, const string& cm="#@;");$/;"	p	class:fileio	access:public
fileio::fileio	fileio.hpp	/^    fileio(const string& _fname, const ios_base::openmode& mode, const bool& perm=true, const linecounter _lb=0, const linecounter _ls=1, const linecounter _le=MAXNLINE, const string& cm="#@;");$/;"	p	class:fileio	access:public
fileio::fname	fileio.hpp	/^    string fname; \/\/filename$/;"	m	class:fileio	access:public
fileio::fopen	fileio.cpp	/^bool fileio::fopen() {$/;"	f	class:fileio
fileio::fopen	fileio.cpp	/^bool fileio::fopen(const string& _fname) {$/;"	f	class:fileio
fileio::fopen	fileio.cpp	/^bool fileio::fopen(const string& _fname, const ios_base::openmode& mode) {$/;"	f	class:fileio
fileio::fopen	fileio.hpp	/^    bool fopen();$/;"	p	class:fileio	access:private
fileio::fopen	fileio.hpp	/^    bool fopen(const string& _fname);$/;"	p	class:fileio	access:public
fileio::fopen	fileio.hpp	/^    bool fopen(const string& _fname, const ios_base::openmode& mode);$/;"	p	class:fileio	access:public
fileio::fs	fileio.hpp	/^    fstream fs; \/\/fstream handle$/;"	m	class:fileio	access:private
fileio::getlines	fileio.cpp	/^const vector<string>& fileio::getlines() const { return lines; }$/;"	f	class:fileio
fileio::getlines	fileio.hpp	/^    const vector<string>& getlines() const;$/;"	p	class:fileio	access:public
fileio::getln	fileio.cpp	/^const string& fileio::getln() const { return line; }$/;"	f	class:fileio
fileio::getln	fileio.hpp	/^    const string& getln() const;$/;"	p	class:fileio	access:public
fileio::ifperm	fileio.hpp	/^    const bool ifperm; \/\/if true, won't exit even though a file can't be opened$/;"	m	class:fileio	access:public
fileio::iomode	fileio.hpp	/^    ios_base::openmode iomode; \/\/read or write$/;"	m	class:fileio	access:public
fileio::lb	fileio.hpp	/^    linecounter lb; \/\/beginning (from 1) line of input file to be actually parsed $/;"	m	class:fileio	access:public
fileio::lc	fileio.hpp	/^    linecounter lc; \/\/number of lines actually read, excluding comments but including lines before fileio::lb$/;"	m	class:fileio	access:public
fileio::le	fileio.hpp	/^    linecounter le; \/\/ending line of input file to be actually parsed$/;"	m	class:fileio	access:public
fileio::line	fileio.hpp	/^    string line; \/\/used by fileio::readbyline()$/;"	m	class:fileio	access:public
fileio::line2str	fileio.hpp	/^    vector<string> line2str(const string& delims=" \\t") const {$/;"	f	class:fileio	access:public
fileio::line2val	fileio.hpp	/^    vector<V> line2val() const {$/;"	f	class:fileio	access:public
fileio::lines	fileio.hpp	/^    vector<string> lines; \/\/used by fileio::readall()$/;"	m	class:fileio	access:public
fileio::ls	fileio.hpp	/^    linecounter ls; \/\/parse the input file every this many of lines, starting from fileio::lb$/;"	m	class:fileio	access:public
fileio::pos	fileio.hpp	/^      auto pos = fs.tellg(); $/;"	l
fileio::readaline	fileio.hpp	/^    bool readaline() {$/;"	f	class:fileio	access:public
fileio::readalinenb	fileio.hpp	/^    bool readalinenb() {$/;"	f	class:fileio	access:public
fileio::readall	fileio.cpp	/^void fileio::readall() {$/;"	f	class:fileio
fileio::readall	fileio.hpp	/^    void readall();$/;"	p	class:fileio	access:public
fileio::readts	fileio.hpp	/^    bool readts() {$/;"	f	class:fileio	access:public
fileio::readtsnb	fileio.hpp	/^    bool readtsnb() {$/;"	f	class:fileio	access:public
fileio::resetlc	fileio.cpp	/^void fileio::resetlc() { lc = 0; }$/;"	f	class:fileio
fileio::resetlc	fileio.hpp	/^    void resetlc();$/;"	p	class:fileio	access:public
fileio::seekg	fileio.hpp	/^	  fs.seekg(pos);$/;"	p
fileio::skipemptylns	fileio.hpp	/^    void skipemptylns() {$/;"	f	class:fileio	access:public
fileio_utils.cpp	fileio_utils.cpp	1;"	F
fileio_utils.hpp	fileio_utils.hpp	1;"	F
find	gnarray.hpp	/^    const_iterator find(const Tcoord& coord) const;$/;"	p	class:gnarray	access:public
find	gnarray.hpp	/^    iterator find(const Tcoord& coord);$/;"	p	class:gnarray	access:public
find	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::const_iterator gnarray<Tcoord,Telem,Tval>::find(const Tcoord& coord) const {$/;"	f	class:gnarray
find	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::iterator gnarray<Tcoord,Telem,Tval>::find(const Tcoord& coord) {$/;"	f	class:gnarray
fio	gmxmdp.cpp	/^  fileio fio(fname, fstream::in, 1, 0, 1, MAXNLINE, ";");$/;"	p	file:
fio	mdp_factory.hpp	/^        fileio fio(fmdp, fstream::in, false, 0, 1, MAXNLINE, ";#@");$/;"	p
fio	timeseries.hpp	/^    fileio fio;$/;"	m	class:TimeSeries	access:public
fio_fseeds	gwham.cpp	/^  fileio fio_fseeds(fseedsstr, std::fstream::in, 1, 1, 1, 1);$/;"	p	file:
fio_hist	gwham.cpp	/^  fileio fio_hist(fnhist, std::fstream::in, false);$/;"	p	file:
fits_in_bits	mpfrc++/mpreal.h	/^    inline bool fits_in_bits(double x, int n);$/;"	p	class:mpfr::mpreal	access:public
fits_in_bits	mpfrc++/mpreal.h	/^inline bool mpreal::fits_in_bits(double x, int n)$/;"	f	class:mpfr::mpreal
flags	gmxmdp.cpp	/^      fcout.flags(ios::left);$/;"	p	file:
flags	gmxmdp.cpp	/^      fcout.flags(ios::right);$/;"	p	file:
flags	gmxmdp.cpp	/^  fcout.flags(ios::left);$/;"	p	file:
flags	gmxmdp.cpp	/^  fcout.flags(ios::right);$/;"	p	file:
flags	gmxmdp.hpp	/^    fcout.flags(ios::left);$/;"	p
flags	gmxmdp.hpp	/^    fcout.flags(ios::right);$/;"	p
flags	gnarray.hpp	/^    fcout.flags(ios::fixed);$/;"	p
flags	gwham.cpp	/^      fcout.flags(ios::scientific);$/;"	p	file:
flags	gwham.cpp	/^  fcout.flags(ios::fixed);$/;"	p	file:
flags	mc.cpp	/^    fcout.flags(ios::fixed);$/;"	p	file:
flags	mc.cpp	/^    fcout.flags(ios::scientific);$/;"	p	file:
flags	metaprog_snippets.hpp	/^    void flags(const F& flags) { stream.flags(flags); }$/;"	f	class:FormatStream	access:public
flags	metaprog_snippets.hpp	/^    void flags(const F& flags) { stream.flags(flags); }$/;"	p
flags	mpfrc++/mpreal.h	/^    const std::ios::fmtflags flags = os.flags();$/;"	l
floor	mpfrc++/mpreal.h	/^    friend const mpreal floor(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
floor	mpfrc++/mpreal.h	/^inline const mpreal floor(const mpreal& v)$/;"	f	namespace:mpfr
flush	minimizer/cg.hpp	/^			  cout.flush();$/;"	p
fma	mpfrc++/mpreal.h	/^    friend const mpreal fma      (const mpreal& v1, const mpreal& v2, const mpreal& v3, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
fmax	mpfrc++/mpreal.h	/^    friend const mpreal fmax(const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
fmax	mpfrc++/mpreal.h	/^inline const mpreal fmax(const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fmdp	mdp_factory.hpp	/^      const string fmdp = MDPprefix+"."+MDPsuffix;$/;"	l
fmin	minimizer/cg.hpp	/^	Doub xmin,fmin;$/;"	m	struct:Dbrent	access:public
fmin	mpfrc++/mpreal.h	/^    friend const mpreal fmin(const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
fmin	mpfrc++/mpreal.h	/^inline const mpreal fmin(const mpreal& x, const mpreal& y,  mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fmod	mpfrc++/mpreal.h	/^    friend const mpreal fmod        (const mpreal& x, const mpreal& y,      mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
fmod	mpfrc++/mpreal.h	/^inline const mpreal fmod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fms	mpfrc++/mpreal.h	/^    friend const mpreal fms      (const mpreal& v1, const mpreal& v2, const mpreal& v3, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
fname	fileio.hpp	/^    string fname; \/\/filename$/;"	m	class:fileio	access:public
fname	mdp.hpp	/^    const string fname;$/;"	m	class:MDP	access:public
fnhist	gwham.cpp	/^      const string fnhist = sysname + "_" + tostr(i) + ".hist";$/;"	l
fnprefixes	gwham.cpp	/^  vector<string> fnprefixes;$/;"	l
fnsuffix	gwham.cpp	/^  const auto& fnsuffix = ts.fnsuffix;$/;"	l
fnsuffix	timeseries.hpp	/^    const string fnsuffix;$/;"	m	class:TimeSeries	access:public
fopen	fileio.cpp	/^bool fileio::fopen() {$/;"	f	class:fileio
fopen	fileio.cpp	/^bool fileio::fopen(const string& _fname) {$/;"	f	class:fileio
fopen	fileio.cpp	/^bool fileio::fopen(const string& _fname, const ios_base::openmode& mode) {$/;"	f	class:fileio
fopen	fileio.hpp	/^    bool fopen();$/;"	p	class:fileio	access:private
fopen	fileio.hpp	/^    bool fopen(const string& _fname);$/;"	p	class:fileio	access:public
fopen	fileio.hpp	/^    bool fopen(const string& _fname, const ios_base::openmode& mode);$/;"	p	class:fileio	access:public
format	mpfrc++/mpreal.h	/^    std::ostringstream format;$/;"	l
fp	minimizer/cg.hpp	/^		Doub fp=func(p);$/;"	l
frac	mpfrc++/mpreal.h	/^    friend const mpreal frac        (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
frac	mpfrc++/mpreal.h	/^inline const mpreal frac       (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(frac      );     }$/;"	f	namespace:mpfr
fret	likelihoodfunc.hpp	/^    valtype fret;$/;"	m	class:LikeliHoodFunc	access:private
fret	minimizer/cg.hpp	/^	Doub fret;$/;"	m	struct:Frprmn	access:public
frexp	mpfrc++/mpreal.h	/^    friend const mpreal frexp(const mpreal& v, mp_exp_t* exp);    $/;"	p	class:mpfr::mpreal	access:friend
frprmn	gwham.hpp	/^    Frprmn<FUNC> frprmn(func, tol);$/;"	p
fs	fileio.hpp	/^    fstream fs; \/\/fstream handle$/;"	m	class:fileio	access:private
fseedsstr	gwham.cpp	/^  const string fseedsstr = string(argv[k++]);$/;"	l
ftol	minimizer/cg.hpp	/^	const Doub ftol;$/;"	m	struct:Dlinemethod	access:public
ftree	likelihoodfunc.hpp	/^    ftree() {};$/;"	f	class:ftree	access:public
ftree	likelihoodfunc.hpp	/^class ftree {$/;"	c
ftree::Data	likelihoodfunc.hpp	/^    typedef V Data;$/;"	t	class:ftree	access:public
ftree::Edge	likelihoodfunc.hpp	/^    typedef array<Node, 2> Edge;$/;"	t	class:ftree	access:public
ftree::Edges	likelihoodfunc.hpp	/^    typedef vector<Edge> Edges;$/;"	t	class:ftree	access:private
ftree::Node	likelihoodfunc.hpp	/^    typedef typename vector<V>::iterator Node;$/;"	t	class:ftree	access:public
ftree::Nodes	likelihoodfunc.hpp	/^    typedef vector<Node> Nodes;$/;"	t	class:ftree	access:public
ftree::ThisType	likelihoodfunc.hpp	/^    typedef ftree<V> ThisType;$/;"	t	class:ftree	access:private
ftree::addedge	likelihoodfunc.hpp	/^    inline void addedge(const Edge& edge) {$/;"	f	class:ftree	access:public
ftree::addjoint	likelihoodfunc.hpp	/^    inline void addjoint(const Node& node, const uint& edgeid) { $/;"	f	class:ftree	access:public
ftree::addnode	likelihoodfunc.hpp	/^    inline void addnode(const Node& node) { nodes.emplace_back(node); }$/;"	f	class:ftree	access:public
ftree::addport	likelihoodfunc.hpp	/^    inline void addport(const uint& hubid, const Nodes& newport) { $/;"	f	class:ftree	access:public
ftree::addroute	likelihoodfunc.hpp	/^    inline void addroute(const Node& node, const uint& edgeid) {$/;"	f	class:ftree	access:public
ftree::ans	likelihoodfunc.hpp	/^      bool ans = true;$/;"	l
ftree::append	likelihoodfunc.hpp	/^    inline ThisType& append(const ThisType& src, const Edge& junction) {$/;"	f	class:ftree	access:public
ftree::buildftree	likelihoodfunc.hpp	/^  friend vector<ThisType> buildftree<ThisType>(const vector<vector<uint>>&, vector<V>&);$/;"	p	class:ftree	access:friend
ftree::edge	likelihoodfunc.hpp	/^      const auto& edge = edges[edgeid];$/;"	l
ftree::edges	likelihoodfunc.hpp	/^    Edges edges;$/;"	m	class:ftree	access:public
ftree::edgesize	likelihoodfunc.hpp	/^    inline uint edgesize() const { return edges.size(); }$/;"	f	class:ftree	access:public
ftree::emplace_back	likelihoodfunc.hpp	/^        edges.emplace_back(edge);$/;"	p
ftree::emplace_back	likelihoodfunc.hpp	/^        edges.emplace_back(newedge);$/;"	p
ftree::emplace_back	likelihoodfunc.hpp	/^    inline void addnode(const Node& node) { nodes.emplace_back(node); }$/;"	p
ftree::empty	likelihoodfunc.hpp	/^    inline bool empty() const { return !(nodes.size() || edges.size() || routes.size() || ports.size()); } $/;"	f	class:ftree	access:public
ftree::ftree	likelihoodfunc.hpp	/^    ftree() {};$/;"	f	class:ftree	access:public
ftree::getedges	likelihoodfunc.hpp	/^    inline const Edges& getedges() const { return edges; } $/;"	f	class:ftree	access:public
ftree::getjoints	likelihoodfunc.hpp	/^    inline const map<Node, vector<uint> >& getjoints() const { return joints; } $/;"	f	class:ftree	access:public
ftree::getnodes	likelihoodfunc.hpp	/^    inline const Nodes& getnodes() const { return nodes; } $/;"	f	class:ftree	access:public
ftree::getports	likelihoodfunc.hpp	/^    inline const vector<Nodes>& getports() const { return ports; } $/;"	f	class:ftree	access:public
ftree::getroutes	likelihoodfunc.hpp	/^    inline const map<Node, vector<uint> >& getroutes() const { return routes; } $/;"	f	class:ftree	access:public
ftree::getroutes	likelihoodfunc.hpp	/^    inline map<Node, vector<uint> >& getroutes() { return routes; } $/;"	f	class:ftree	access:public
ftree::head	likelihoodfunc.hpp	/^      const auto head = edge[0];$/;"	l
ftree::insert	likelihoodfunc.hpp	/^      port.insert(port.end(), newport.begin(), newport.end());$/;"	p
ftree::it	likelihoodfunc.hpp	/^      auto it = joints.find(node);$/;"	l
ftree::it	likelihoodfunc.hpp	/^      auto it = routes.find(node);$/;"	l
ftree::it1	likelihoodfunc.hpp	/^      auto it1 = routes.find(node1);$/;"	l
ftree::it2	likelihoodfunc.hpp	/^      auto it2 = routes.find(node2);$/;"	l
ftree::itfnode	likelihoodfunc.hpp	/^      const auto& itfnode = routes.find(edge[0]);$/;"	l
ftree::ithead	likelihoodfunc.hpp	/^      const auto ithead = routes.find(head);$/;"	l
ftree::itsrcjoint	likelihoodfunc.hpp	/^      const auto itsrcjoint = srcjoints.find(newnode); $/;"	l
ftree::ittail	likelihoodfunc.hpp	/^      const auto ittail = routes.find(tail);$/;"	l
ftree::joints	likelihoodfunc.hpp	/^    map<Node, vector<uint> > joints;$/;"	m	class:ftree	access:public
ftree::newedge	likelihoodfunc.hpp	/^	Edge newedge = {tail, head};$/;"	l
ftree::newnode	likelihoodfunc.hpp	/^      const Node newnode = (it1 == routes.end()) ?  node1 : node2;$/;"	l
ftree::node	likelihoodfunc.hpp	/^	const auto& node = it->first;$/;"	l
ftree::node1	likelihoodfunc.hpp	/^      const auto& node1 = junction[0];$/;"	l
ftree::node2	likelihoodfunc.hpp	/^      const auto& node2 = junction[1];$/;"	l
ftree::nodes	likelihoodfunc.hpp	/^    Nodes nodes;$/;"	m	class:ftree	access:public
ftree::nodeset_equal	likelihoodfunc.hpp	/^    bool nodeset_equal(const ThisType& rhs) const {$/;"	f	class:ftree	access:public
ftree::nodesize	likelihoodfunc.hpp	/^    inline uint nodesize() const { return nodes.size(); }$/;"	f	class:ftree	access:public
ftree::port	likelihoodfunc.hpp	/^      auto& port = ports[hubid];$/;"	l
ftree::ports	likelihoodfunc.hpp	/^    vector<Nodes> ports;$/;"	m	class:ftree	access:public
ftree::push_back	likelihoodfunc.hpp	/^	it->second.push_back(edgeid);$/;"	p
ftree::push_back	likelihoodfunc.hpp	/^      if(it != joints.end()) { it->second.push_back(edgeid); }$/;"	p
ftree::resize	likelihoodfunc.hpp	/^      ports.resize(edges.size());$/;"	p
ftree::rhsroutes	likelihoodfunc.hpp	/^      const auto& rhsroutes = rhs.getroutes();$/;"	l
ftree::routes	likelihoodfunc.hpp	/^    map<Node, vector<uint> > routes;$/;"	m	class:ftree	access:public
ftree::srcedges	likelihoodfunc.hpp	/^      const auto& srcedges = src.getedges();$/;"	l
ftree::srcjoints	likelihoodfunc.hpp	/^      const auto& srcjoints = src.getjoints();$/;"	l
ftree::tail	likelihoodfunc.hpp	/^      const auto tail = edge[1];$/;"	l
ftrees	gwham.hpp	/^    auto ftrees = buildftree<ftree<valtype>>(histnbs, f);$/;"	l
fts	gwham.cpp	/^    const string fts = fnprefix + "_" + tostr(i) + fnsuffix;$/;"	l
fu	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
fu	minimizer/cg.hpp	/^		Doub fu;$/;"	l
func	gwham.hpp	/^    FUNC func(DOS, *N, C, NgexpmH, f, expf, tree);$/;"	p
func	minimizer/cg.hpp	/^	T &func;$/;"	m	struct:Dlinemethod	access:public
funcd	minimizer/cg.hpp	/^	T &funcd;$/;"	m	struct:Df1dim	access:public
funct	functor.hpp	/^    Tf funct;$/;"	m	class:Functor	access:protected
functor.hpp	functor.hpp	1;"	F
functors	mc.cpp	/^    vFunctVV functors;$/;"	l
fv	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
fw	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
fx	mc.hpp	/^	const valtype fx = this->operator()(coord);$/;"	l
fx	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
g	gwham.hpp	/^     const vector<NARRAY>* const g;$/;"	m	class:WHAM	access:private
g	minimizer/cg.hpp	/^		VecDoub g(n),h(n);$/;"	p
gam	minimizer/cg.hpp	/^			Doub gam=dgg\/gg;$/;"	l
gamma	mpfrc++/mpreal.h	/^    friend const mpreal gamma    (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
gdf	likelihoodfunc.hpp	/^          auto& gdf = graddf[i];$/;"	l
genens	ensemble_factory.hpp	/^genens(const PMDP& pmdp, vpEnsemble& ens, multimap<PMDP, uint>& pmdp2ipens, bool combinestates) {$/;"	f
geomT	gmxmdp.hpp	/^    } geomT = NGeomTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::PullGeom	access:public
geomTstr	gmxmdp.hpp	/^    string geomTstr = "geomTstr";$/;"	m	class:GMXMDP	access:public
get	metaprog_snippets.hpp	/^      *this << input.get();$/;"	p
get	metaprog_snippets.hpp	/^  static inline const type& get(const T1& a, const T&...) {$/;"	f	struct:Extract_One_Type	access:public
get	metaprog_snippets.hpp	/^  static inline const type& get(const T1&, const T&...args) {$/;"	f	struct:Extract_One_Type	access:public
get	metaprog_snippets.hpp	/^  static inline type get() {$/;"	f	struct:Extract_One_Type	access:public
getH	ensemble.hpp	/^    Hamiltonian& getH() { return H; };$/;"	f	class:NVE	access:public
getH	ensemble.hpp	/^    const Hamiltonian& getH() const { return H; };$/;"	f	class:NVE	access:public
getHs	mdp.hpp	/^    const vector<Hamiltonian>& getHs() const { return Hs; }$/;"	f	class:MDP	access:public
getHs	mdp.hpp	/^    vector<Hamiltonian>& getHs() { return Hs; }$/;"	f	class:MDP	access:public
getLbond	mdp.hpp	/^    const vector<valtype>& getLbond() const { return Ls[Lbond]; }$/;"	f	class:MDP	access:public
getLcoul	mdp.hpp	/^    const vector<valtype>& getLcoul() const { return Ls[Lcoul]; }$/;"	f	class:MDP	access:public
getLmass	mdp.hpp	/^    const vector<valtype>& getLmass() const { return Ls[Lmass]; }$/;"	f	class:MDP	access:public
getLrst	mdp.hpp	/^    const vector<valtype>& getLrst() const { return Ls[Lrst]; }$/;"	f	class:MDP	access:public
getLs	mdp.hpp	/^    const array<vector<valtype>, NFEPLambdas>& getLs() const { return Ls; }$/;"	f	class:MDP	access:public
getLtemp	mdp.hpp	/^    const vector<valtype>& getLtemp() const { return Ls[Ltemp]; }$/;"	f	class:MDP	access:public
getLvdw	mdp.hpp	/^    const vector<valtype>& getLvdw() const { return Ls[Lvdw]; }$/;"	f	class:MDP	access:public
getNstates	mdp.hpp	/^    const uint& getNstates() const { return Nstates; };$/;"	f	class:MDP	access:public
getP	ensemble.hpp	/^    const valtype& getP() const { return P; }$/;"	f	class:NPT	access:public
getParams	functor.hpp	/^    Tp& getParams() const { return params; };$/;"	f	class:Functor	access:public
getPotentialFuncts	hamiltonian.cpp	/^const vFunctVV& Hamiltonian::getPotentialFuncts() const {return potentials; }$/;"	f	class:Hamiltonian
getPotentialFuncts	hamiltonian.cpp	/^vFunctVV& Hamiltonian::getPotentialFuncts() {return potentials; }$/;"	f	class:Hamiltonian
getPotentialFuncts	hamiltonian.hpp	/^    const vFunctVV& getPotentialFuncts() const;$/;"	p	class:Hamiltonian	access:public
getPotentialFuncts	hamiltonian.hpp	/^    vFunctVV& getPotentialFuncts();$/;"	p	class:Hamiltonian	access:public
getPrecision	mpfrc++/mpreal.h	/^    inline int          getPrecision() const;$/;"	p	class:mpfr::mpreal	access:public
getPs	mdp.hpp	/^    const vector<valtype>& getPs() const { return Ps; }$/;"	f	class:MDP	access:public
getT	ensemble.hpp	/^    const valtype& getT() const { return T; }$/;"	f	class:NVT	access:public
getTs	mdp.hpp	/^    const vector<valtype>& getTs() const { return Ts; }$/;"	f	class:MDP	access:public
get_default_prec	mpfrc++/mpreal.h	/^    inline static mp_prec_t  get_default_prec()   {    return mpfr_get_default_prec();                            }$/;"	f	class:mpfr::mpreal	access:public
get_default_prec	mpfrc++/mpreal.h	/^    mpfr_init2 (mpfr_ptr(), mpreal::get_default_prec()); $/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^        mpfr_set  (mpfr_ptr(), u, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), t, mpreal::get_default_rnd()); $/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    inline static mp_rnd_t   get_default_rnd()    {    return (mp_rnd_t)(mpfr_get_default_rounding_mode());       }$/;"	f	class:mpfr::mpreal	access:public
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_d(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_q(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_z(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set  (mpfr_ptr(),u.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), 0, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
get_emax	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emax (void);$/;"	p	class:mpfr::mpreal	access:public
get_emax_max	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emax_max (void);$/;"	p	class:mpfr::mpreal	access:public
get_emax_min	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emax_min (void);$/;"	p	class:mpfr::mpreal	access:public
get_emin	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emin (void);$/;"	p	class:mpfr::mpreal	access:public
get_emin_max	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emin_max (void);$/;"	p	class:mpfr::mpreal	access:public
get_emin_min	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emin_min (void);$/;"	p	class:mpfr::mpreal	access:public
get_exp	mpfrc++/mpreal.h	/^    mp_exp_t get_exp();$/;"	p	class:mpfr::mpreal	access:public
get_prec	mpfrc++/mpreal.h	/^    inline mp_prec_t    get_prec() const;$/;"	p	class:mpfr::mpreal	access:public
getbinsize	gnarray.hpp	/^    const vector<Tval>& getbinsize() const { return binsize;}$/;"	f	class:gnarray	access:public
getdim	gnarray.hpp	/^    uint getdim() const { return dim; }$/;"	f	class:gnarray	access:public
getdim	mc.hpp	/^    uint getdim() const { return dim;};$/;"	f	class:harmonic	access:public
getdim	mc.hpp	/^    uint getdim() const { return dim;};$/;"	f	class:potpoly_dblwell	access:public
getdosarr	densityofstate.hpp	/^    const narray& getdosarr() const { return DOS;}$/;"	f	class:DensityOfState	access:public
getdt	mdp.hpp	/^    const valtype& getdt() const { return dt; };$/;"	f	class:MDP	access:public
getedges	likelihoodfunc.hpp	/^    inline const Edges& getedges() const { return edges; } $/;"	f	class:ftree	access:public
getfnfixes	fileio_utils.cpp	/^array<string, 2> getfnfixes(const string& entry) {$/;"	f
getfnfixes	fileio_utils.hpp	/^array<string, 2> getfnfixes(const string& entry);$/;"	p
gethv	gnarray.hpp	/^    const vector<Tval>& gethv() const { return hv;}$/;"	f	class:gnarray	access:public
getjoints	likelihoodfunc.hpp	/^    inline const map<Node, vector<uint> >& getjoints() const { return joints; } $/;"	f	class:ftree	access:public
getkB	ensemble.hpp	/^    const valtype& getkB() const { return kB; };$/;"	f	class:Ensemble	access:public
getkB	mdp.hpp	/^    const valtype& getkB() const { return kB; };$/;"	f	class:MDP	access:public
getlambdas	gmxmdp.cpp	/^vector<valtype> GMXMDP::getlambdas() const {$/;"	f	class:GMXMDP
getlambdas	gmxmdp.hpp	/^    virtual vector<valtype> getlambdas() const;$/;"	p	class:GMXMDP	access:public
getlambdas	mdp.hpp	/^    virtual vector<valtype> getlambdas() const {$/;"	f	class:MDP	access:public
getlines	fileio.cpp	/^const vector<string>& fileio::getlines() const { return lines; }$/;"	f	class:fileio
getlines	fileio.hpp	/^    const vector<string>& getlines() const;$/;"	p	class:fileio	access:public
getln	fileio.cpp	/^const string& fileio::getln() const { return line; }$/;"	f	class:fileio
getln	fileio.hpp	/^    const string& getln() const;$/;"	p	class:fileio	access:public
getlv	gnarray.hpp	/^    const vector<Tval>& getlv() const { return lv;}$/;"	f	class:gnarray	access:public
getnarr	gnarray.hpp	/^    const map<Tcoord,Telem>& getnarr() const { return narr;}$/;"	f	class:gnarray	access:public
getnelms	gnarray.hpp	/^    const vector<uint>& getnelms() const { return nelms;}$/;"	f	class:gnarray	access:public
getnelms_tot	gnarray.hpp	/^    const ulong& getnelms_tot() const { return nelms_tot;}$/;"	f	class:gnarray	access:public
getnodes	likelihoodfunc.hpp	/^    inline const Nodes& getnodes() const { return nodes; } $/;"	f	class:ftree	access:public
getpmf.pl	example/1lipo-popeg/getpmf.pl	1;"	F
getpobj	functor.hpp	/^    cpTo& getpobj() const { return pobj; };$/;"	f	class:Functor	access:public
getports	likelihoodfunc.hpp	/^    inline const vector<Nodes>& getports() const { return ports; } $/;"	f	class:ftree	access:public
getroutes	likelihoodfunc.hpp	/^    inline const map<Node, vector<uint> >& getroutes() const { return routes; } $/;"	f	class:ftree	access:public
getroutes	likelihoodfunc.hpp	/^    inline map<Node, vector<uint> >& getroutes() { return routes; } $/;"	f	class:ftree	access:public
getrstfuncts	mdp.hpp	/^    const vector<vFunctVV>& getrstfuncts() const { return rstfuncts; }$/;"	f	class:MDP	access:public
getstride_array	gnarray.hpp	/^    const vector<uint>& getstride_array() const { return stride_array;}$/;"	f	class:gnarray	access:public
gg	minimizer/cg.hpp	/^		Doub gg,dgg;$/;"	l
gid	gmxmdp.hpp	/^  uint gid;$/;"	m	class:GMXMDP::GMXPGRP	access:public
gidstr	gmxmdp.hpp	/^  string gidstr;$/;"	m	class:GMXMDP::GMXPGRP	access:public
gmxmdp.cpp	gmxmdp.cpp	1;"	F
gmxmdp.hpp	gmxmdp.hpp	1;"	F
gnarray	gnarray.hpp	/^    gnarray();$/;"	p	class:gnarray	access:public
gnarray	gnarray.hpp	/^    gnarray(const gnarray<Tcoord,Telem,Tval>& _gnarr);$/;"	p	class:gnarray	access:public
gnarray	gnarray.hpp	/^    gnarray(const gnarray<Tcoord,Telem,Tval>& _gnarr, const vector<uint>& _dim);$/;"	p	class:gnarray	access:public
gnarray	gnarray.hpp	/^    gnarray(const uint _dim, const vector<uint>& _nelms, const vector<Tval>& _hv, const vector<Tval>& _lv);$/;"	p	class:gnarray	access:public
gnarray	gnarray.hpp	/^class gnarray {$/;"	c
gnarray	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval>::gnarray():$/;"	f	class:gnarray
gnarray	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval>::gnarray(const gnarray<Tcoord,Telem,Tval>& _gnarr) :$/;"	f	class:gnarray
gnarray	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval>::gnarray(const gnarray<Tcoord,Telem,Tval>& _gnarr, const vector<uint>& _dim) :$/;"	f	class:gnarray
gnarray	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval>::gnarray(const uint _dim, const vector<uint>& _nelms, const vector<Tval>& _hv, const vector<Tval>& _lv):$/;"	f	class:gnarray
gnarray.hpp	gnarray.hpp	1;"	F
gnarray::ThisType	gnarray.hpp	/^    typedef gnarray<Tcoord, Telem, Tval> ThisType;$/;"	t	class:gnarray	access:public
gnarray::begin	gnarray.hpp	/^    const_iterator begin() const;$/;"	p	class:gnarray	access:public
gnarray::begin	gnarray.hpp	/^    iterator begin();$/;"	p	class:gnarray	access:public
gnarray::begin	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::const_iterator gnarray<Tcoord,Telem,Tval>::begin() const {$/;"	f	class:gnarray
gnarray::begin	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::iterator gnarray<Tcoord,Telem,Tval>::begin() {$/;"	f	class:gnarray
gnarray::bin	gnarray.hpp	/^    iterator bin(const vector<Tval>& data, const Telem& weight = 1);$/;"	p	class:gnarray	access:public
gnarray::bin	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::iterator gnarray<Tcoord,Telem,Tval>::bin(const vector<Tval>& data, const Telem& weight) {$/;"	f	class:gnarray
gnarray::binsize	gnarray.hpp	/^    vector<Tval> binsize;$/;"	m	class:gnarray	access:private
gnarray::canonical_valseries	gnarray.hpp	/^    vector<vector<Tval> > canonical_valseries() const; $/;"	p	class:gnarray	access:public
gnarray::canonical_valseries	gnarray.hpp	/^vector<vector<Tval> > gnarray<Tcoord,Telem,Tval>::canonical_valseries() const {$/;"	f	class:gnarray
gnarray::const_iterator	gnarray.hpp	/^    typedef typename map<Tcoord, Telem>::const_iterator const_iterator;$/;"	t	class:gnarray	access:public
gnarray::coord2val	gnarray.hpp	/^    const vector<Tval> coord2val(const Tcoord& coord) const;$/;"	p	class:gnarray	access:public
gnarray::coord2val	gnarray.hpp	/^const vector<Tval> gnarray<Tcoord,Telem,Tval>::coord2val(const Tcoord& coord) const {$/;"	f	class:gnarray
gnarray::dim	gnarray.hpp	/^    uint dim;$/;"	m	class:gnarray	access:private
gnarray::end	gnarray.hpp	/^    const_iterator end() const;$/;"	p	class:gnarray	access:public
gnarray::end	gnarray.hpp	/^    iterator end();$/;"	p	class:gnarray	access:public
gnarray::end	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::const_iterator gnarray<Tcoord,Telem,Tval>::end() const {$/;"	f	class:gnarray
gnarray::end	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::iterator gnarray<Tcoord,Telem,Tval>::end() {$/;"	f	class:gnarray
gnarray::find	gnarray.hpp	/^    const_iterator find(const Tcoord& coord) const;$/;"	p	class:gnarray	access:public
gnarray::find	gnarray.hpp	/^    iterator find(const Tcoord& coord);$/;"	p	class:gnarray	access:public
gnarray::find	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::const_iterator gnarray<Tcoord,Telem,Tval>::find(const Tcoord& coord) const {$/;"	f	class:gnarray
gnarray::find	gnarray.hpp	/^typename gnarray<Tcoord,Telem,Tval>::iterator gnarray<Tcoord,Telem,Tval>::find(const Tcoord& coord) {$/;"	f	class:gnarray
gnarray::getbinsize	gnarray.hpp	/^    const vector<Tval>& getbinsize() const { return binsize;}$/;"	f	class:gnarray	access:public
gnarray::getdim	gnarray.hpp	/^    uint getdim() const { return dim; }$/;"	f	class:gnarray	access:public
gnarray::gethv	gnarray.hpp	/^    const vector<Tval>& gethv() const { return hv;}$/;"	f	class:gnarray	access:public
gnarray::getlv	gnarray.hpp	/^    const vector<Tval>& getlv() const { return lv;}$/;"	f	class:gnarray	access:public
gnarray::getnarr	gnarray.hpp	/^    const map<Tcoord,Telem>& getnarr() const { return narr;}$/;"	f	class:gnarray	access:public
gnarray::getnelms	gnarray.hpp	/^    const vector<uint>& getnelms() const { return nelms;}$/;"	f	class:gnarray	access:public
gnarray::getnelms_tot	gnarray.hpp	/^    const ulong& getnelms_tot() const { return nelms_tot;}$/;"	f	class:gnarray	access:public
gnarray::getstride_array	gnarray.hpp	/^    const vector<uint>& getstride_array() const { return stride_array;}$/;"	f	class:gnarray	access:public
gnarray::gnarray	gnarray.hpp	/^    gnarray();$/;"	p	class:gnarray	access:public
gnarray::gnarray	gnarray.hpp	/^    gnarray(const gnarray<Tcoord,Telem,Tval>& _gnarr);$/;"	p	class:gnarray	access:public
gnarray::gnarray	gnarray.hpp	/^    gnarray(const gnarray<Tcoord,Telem,Tval>& _gnarr, const vector<uint>& _dim);$/;"	p	class:gnarray	access:public
gnarray::gnarray	gnarray.hpp	/^    gnarray(const uint _dim, const vector<uint>& _nelms, const vector<Tval>& _hv, const vector<Tval>& _lv);$/;"	p	class:gnarray	access:public
gnarray::gnarray	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval>::gnarray():$/;"	f	class:gnarray
gnarray::gnarray	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval>::gnarray(const gnarray<Tcoord,Telem,Tval>& _gnarr) :$/;"	f	class:gnarray
gnarray::gnarray	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval>::gnarray(const gnarray<Tcoord,Telem,Tval>& _gnarr, const vector<uint>& _dim) :$/;"	f	class:gnarray
gnarray::gnarray	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval>::gnarray(const uint _dim, const vector<uint>& _nelms, const vector<Tval>& _hv, const vector<Tval>& _lv):$/;"	f	class:gnarray
gnarray::gridcoord	gnarray.hpp	/^    typedef Tcoord gridcoord;$/;"	t	class:gnarray	access:public
gnarray::gridval	gnarray.hpp	/^    typedef Telem gridval;$/;"	t	class:gnarray	access:public
gnarray::hv	gnarray.hpp	/^    vector<Tval> hv;$/;"	m	class:gnarray	access:private
gnarray::it	gnarray.hpp	/^      const_iterator it = narr.find(coord);$/;"	l
gnarray::iterator	gnarray.hpp	/^    typedef typename map<Tcoord, Telem>::iterator iterator;$/;"	t	class:gnarray	access:public
gnarray::lv	gnarray.hpp	/^    vector<Tval> lv;$/;"	m	class:gnarray	access:private
gnarray::narr	gnarray.hpp	/^    map<Tcoord, Telem> narr;$/;"	m	class:gnarray	access:private
gnarray::nelms	gnarray.hpp	/^    vector<uint> nelms;$/;"	m	class:gnarray	access:private
gnarray::nelms_tot	gnarray.hpp	/^    ulong nelms_tot;$/;"	m	class:gnarray	access:private
gnarray::operator =	gnarray.hpp	/^    gnarray operator=(const gnarray<Tcoord,Telem,Tval>& rhs);$/;"	p	class:gnarray	access:public
gnarray::operator =	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval> gnarray<Tcoord,Telem,Tval>::operator=(const gnarray<Tcoord,Telem,Tval>& rhs) {$/;"	f	class:gnarray
gnarray::operator []	gnarray.hpp	/^    Telem operator[](const Tcoord& coord) const {$/;"	f	class:gnarray	access:public
gnarray::operator []	gnarray.hpp	/^    Telem& operator[](const Tcoord& coord) { return narr[coord]; }$/;"	f	class:gnarray	access:public
gnarray::overlap	gnarray.hpp	/^    Telem overlap(const ThisType& rhs) const;$/;"	p	class:gnarray	access:public
gnarray::overlap	gnarray.hpp	/^Telem gnarray<Tcoord,Telem,Tval>::overlap(const ThisType& rhs) const {$/;"	f	class:gnarray
gnarray::print	gnarray.hpp	/^    void print() const;$/;"	p	class:gnarray	access:public
gnarray::print	gnarray.hpp	/^    void print(const Telem& norm) const;$/;"	p	class:gnarray	access:public
gnarray::print	gnarray.hpp	/^void gnarray<Tcoord,Telem,Tval>::print() const {$/;"	f	class:gnarray
gnarray::print	gnarray.hpp	/^void gnarray<Tcoord,Telem,Tval>::print(const Telem& norm) const {$/;"	f	class:gnarray
gnarray::setbinsize	gnarray.hpp	/^    void setbinsize(const vector<Tval>& _binsize) { binsize = _binsize;}$/;"	f	class:gnarray	access:public
gnarray::setdim	gnarray.hpp	/^    void setdim(const uint& _dim) { dim = _dim; }$/;"	f	class:gnarray	access:public
gnarray::sethv	gnarray.hpp	/^    void sethv(const vector<Tval>& _hv) { hv = _hv;}$/;"	f	class:gnarray	access:public
gnarray::setlv	gnarray.hpp	/^    void setlv(const vector<Tval>& _lv) { lv = _lv;}$/;"	f	class:gnarray	access:public
gnarray::setnarr	gnarray.hpp	/^    void setnarr(const map<Tcoord,Telem>& _narr) { narr = _narr;}$/;"	f	class:gnarray	access:public
gnarray::setnelms	gnarray.hpp	/^    void setnelms(const vector<uint>& _nelms) { nelms = _nelms;}$/;"	f	class:gnarray	access:public
gnarray::setstride	gnarray.hpp	/^    void setstride();$/;"	p	class:gnarray	access:private
gnarray::setstride	gnarray.hpp	/^void gnarray<Tcoord,Telem,Tval>::setstride() {$/;"	f	class:gnarray
gnarray::size	gnarray.hpp	/^    size_t size() const;$/;"	p	class:gnarray	access:public
gnarray::size	gnarray.hpp	/^size_t gnarray<Tcoord,Telem,Tval>::size() const {$/;"	f	class:gnarray
gnarray::stride_array	gnarray.hpp	/^    vector<uint> stride_array;$/;"	m	class:gnarray	access:private
gnarray::sum	gnarray.hpp	/^    Telem sum() const;$/;"	p	class:gnarray	access:public
gnarray::sum	gnarray.hpp	/^Telem gnarray<Tcoord,Telem,Tval>::sum() const {$/;"	f	class:gnarray
gnarray::val2coord	gnarray.hpp	/^    const Tcoord val2coord(const vector<Tval>& vals) const;$/;"	p	class:gnarray	access:public
gnarray::val2coord	gnarray.hpp	/^const Tcoord gnarray<Tcoord,Telem,Tval>::val2coord(const vector<Tval>& vals) const {$/;"	f	class:gnarray
graddf	likelihoodfunc.hpp	/^    vector<valtype> graddf;$/;"	m	class:LikeliHoodFunc	access:private
gradf	likelihoodfunc.hpp	/^    vector<valtype> gradf;$/;"	m	class:LikeliHoodFunc	access:private
grandom	mpfrc++/mpreal.h	/^    friend const mpreal grandom (gmp_randstate_t& state, mp_rnd_t rnd_mode);     \/\/ use gmp_randinit_default() to init state, gmp_randclear() to clear$/;"	p	class:mpfr::mpreal	access:friend
grandom	mpfrc++/mpreal.h	/^    friend const mpreal grandom (unsigned int seed);$/;"	p	class:mpfr::mpreal	access:friend
grandom	mpfrc++/mpreal.h	/^inline const mpreal grandom (gmp_randstate_t& state, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
grandom	mpfrc++/mpreal.h	/^inline const mpreal grandom(unsigned int seed = 0)$/;"	f	namespace:mpfr
gridcoord	gnarray.hpp	/^    typedef Tcoord gridcoord;$/;"	t	class:gnarray	access:public
gridval	gnarray.hpp	/^    typedef Telem gridval;$/;"	t	class:gnarray	access:public
gwham.cpp	gwham.cpp	1;"	F
gwham.hpp	gwham.hpp	1;"	F
h	minimizer/cg.hpp	/^		VecDoub g(n),h(n);$/;"	p
hamiltonian.cpp	hamiltonian.cpp	1;"	F
hamiltonian.hpp	hamiltonian.hpp	1;"	F
harmonic	mc.hpp	/^    harmonic(const uint& _dim, const vector<valtype>& _k, const vector<valtype>& _r) :$/;"	f	class:harmonic	access:public
harmonic	mc.hpp	/^class harmonic {$/;"	c
harmonic::ans	mc.hpp	/^      valtype ans = 0.0;$/;"	l
harmonic::dev	mc.hpp	/^	const valtype dev = coord[i] - r[i];$/;"	l
harmonic::dim	mc.hpp	/^    const uint dim;$/;"	m	class:harmonic	access:private
harmonic::ener	mc.hpp	/^    valtype ener(const vector<valtype>& coord) const {$/;"	f	class:harmonic	access:public
harmonic::getdim	mc.hpp	/^    uint getdim() const { return dim;};$/;"	f	class:harmonic	access:public
harmonic::harmonic	mc.hpp	/^    harmonic(const uint& _dim, const vector<valtype>& _k, const vector<valtype>& _r) :$/;"	f	class:harmonic	access:public
harmonic::k	mc.hpp	/^    const vector<valtype> k;$/;"	m	class:harmonic	access:private
harmonic::operator ()	mc.hpp	/^    valtype operator() (const vector<valtype>& coord) const {$/;"	f	class:harmonic	access:public
harmonic::r	mc.hpp	/^    const vector<valtype> r;$/;"	m	class:harmonic	access:private
hasFEPLambda	mdp.hpp	/^    bool hasFEPLambda() const { return getlambdas().size() != 0; }; $/;"	f	class:MDP	access:public
hasLbond	mdp.hpp	/^    bool hasLbond() const { return !iszero(Ls[Lbond]); }$/;"	f	class:MDP	access:public
hasLcoul	mdp.hpp	/^    bool hasLcoul() const { return !iszero(Ls[Lcoul]); }$/;"	f	class:MDP	access:public
hasLmass	mdp.hpp	/^    bool hasLmass() const { return !iszero(Ls[Lmass]); }$/;"	f	class:MDP	access:public
hasLpress	mdp.hpp	/^    bool hasLpress() const { return !iszero(Ls[Lpress]); }$/;"	f	class:MDP	access:public
hasLrst	mdp.hpp	/^    bool hasLrst() const { return !iszero(Ls[Lrst]); }$/;"	f	class:MDP	access:public
hasLtemp	mdp.hpp	/^    bool hasLtemp() const { return !iszero(Ls[Ltemp]); }$/;"	f	class:MDP	access:public
hasLvdw	mdp.hpp	/^    bool hasLvdw() const { return !iszero(Ls[Lvdw]); }$/;"	f	class:MDP	access:public
hasPressure	mdp.hpp	/^    bool hasPressure() const { return !iszero(Ps); }; $/;"	f	class:MDP	access:public
hasRestraint	mdp.hpp	/^    bool hasRestraint() const { return rstfuncts.size() != 0; };$/;"	f	class:MDP	access:public
hasTemperature	mdp.hpp	/^    bool hasTemperature() const { return Ts.size() != 0; }; $/;"	f	class:MDP	access:public
has_denorm	mpfrc++/mpreal.h	/^        static const float_denorm_style has_denorm  = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
has_infinity	mpfrc++/mpreal.h	/^        static const bool has_infinity      = true;$/;"	m	class:std::numeric_limits	access:public
has_memfn_emplace_back	metaprog_snippets.hpp	/^struct has_memfn_emplace_back {$/;"	s
has_memfn_emplace_back::type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:has_memfn_emplace_back	access:public
has_memfn_get	metaprog_snippets.hpp	/^struct has_memfn_get {$/;"	s
has_memfn_get::type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:has_memfn_get	access:public
has_memfn_size	metaprog_snippets.hpp	/^struct has_memfn_size {$/;"	s
has_memfn_size::type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:has_memfn_size	access:public
has_quiet_NaN	mpfrc++/mpreal.h	/^        static const bool has_quiet_NaN     = true;$/;"	m	class:std::numeric_limits	access:public
has_signaling_NaN	mpfrc++/mpreal.h	/^        static const bool has_signaling_NaN = true;$/;"	m	class:std::numeric_limits	access:public
head	likelihoodfunc.hpp	/^      const auto head = edge[0];$/;"	l
headnode	gwham.hpp	/^    const auto& headnode = f.begin();$/;"	l
headnode	likelihoodfunc.hpp	/^	const auto headnode = f.begin();$/;"	l
headnode	likelihoodfunc.hpp	/^  const Node headnode = f.begin();$/;"	l
headnode	likelihoodfunc.hpp	/^  const auto headnode = f.begin();$/;"	l
hi	gnarray.hpp	/^    const auto& hi = hists[i];$/;"	l
hist	gwham.cpp	/^  auto& hist = hists[state];$/;"	l
hist	gwham.hpp	/^  const HISTOGRAM hist = (*hists)[i];$/;"	l
hist_sum	mc.cpp	/^  histogram hist_sum(dim,nbins,hv,lv);$/;"	p	file:
histcounter	typedefs.hpp	/^typedef ulong histcounter; \/\/the histogram counter$/;"	t
histfromTS	gwham.cpp	/^void histfromTS ($/;"	f
histid	gwham.cpp	/^    const auto& histid = it->second;$/;"	l
histids	gwham.hpp	/^    const vector<uint> histids = it->second;$/;"	l
histnbs	gwham.hpp	/^    const auto histnbs = buildnblist(*overlap);$/;"	l
histogram	gwham.cpp	/^typedef gnarray<coordtype, histcounter, valtype> histogram;$/;"	t	file:
histogram	mc.hpp	/^typedef gnarray<coordtype, histcounter, valtype> histogram;$/;"	t
histogrammer	gwham.cpp	/^  function<void(const vector<valtype>&)> histogrammer;$/;"	l
hists	gwham.hpp	/^     const vector<HISTOGRAM>* const hists;$/;"	m	class:WHAM	access:private
hists	mc.cpp	/^  vector<histogram> hists(nwins_tot,histogram(dim,nbins,hv,lv));$/;"	p	file:
hv	gnarray.hpp	/^    vector<Tval> hv;$/;"	m	class:gnarray	access:private
hv	gwham.cpp	/^  const vector<valtype> hv = split<valtype>(argv[k++]);$/;"	l
hv	mc.cpp	/^  vector<valtype> hv, lv;$/;"	l
hvstr	mc.cpp	/^  const string hvstr = string(argv[3]); $/;"	l
hypot	mpfrc++/mpreal.h	/^    friend const mpreal hypot (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
i	fileio_utils.cpp	/^  auto i = sregex_token_iterator(entry.begin(), entry.end(), fnamebase, {1,2});$/;"	l
i	gmxmdp.cpp	/^      auto i = sregex_token_iterator(line.begin(), line.end(), spliter, -1);$/;"	l
i	gmxmdp.cpp	/^  uint i = 0;$/;"	l
i	gwham.hpp	/^    fcout << i;$/;"	l
i	mc.cpp	/^    fcout << i;$/;"	l
i	mpfrc++/mpreal.h	/^    int i;$/;"	l
i	mpfrc++/mpreal.h	/^    unsigned long int i;$/;"	l
iNcol	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, ncntgrps, nstx*dt);$/;"	l
iNcol	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, npgrps, nstx*dt);$/;"	l
iNcol	gmxmdp.cpp	/^      const ulong iNcol = 2*npgrps + 1;$/;"	l
iNcol	gmxmdp.cpp	/^      const ulong iNcol = ncntgrps + 1;$/;"	l
iNcol	gmxmdp.cpp	/^    ans.emplace_back(fileio(fstream::in, false, 0, ls, MAXNLINE, "#@"), "dhdl.xvg", 2, iNcol, 1, nstdhdl*dt);$/;"	l
iNcol	gmxmdp.cpp	/^    ans.emplace_back(fileio(fstream::in, false, 0, lse, MAXNLINE, "#@"), "ener.xvg", Mask, iNcol, oNcol, nstenergy*dt);$/;"	l
iNcol	gmxmdp.cpp	/^    const linecounter iNcol = 3 + NFEPLambdas - 2 + 3 + Nstates + hasPressure();$/;"	l
iNcol	gmxmdp.cpp	/^    const ulong iNcol = 2;$/;"	l
iNcol	timeseries.hpp	/^    const ulong iNcol = 0;$/;"	m	class:TimeSeries	access:public
id	likelihoodfunc.hpp	/^	  const uint id = itfi-headnode;$/;"	l
id	likelihoodfunc.hpp	/^            const auto id = node - headnode; $/;"	l
idum	mc.hpp	/^      long idum = -random();$/;"	l
idum2	ran2.c	/^	static long idum2=123456789;$/;"	l	file:
ie	gmxmdp.cpp	/^      auto ie = sregex_token_iterator();$/;"	l
iens	gwham.cpp	/^    const auto iens = pmdp2ipens0.find(pmdp0)->second;$/;"	l
ifinit	gmxmdp.hpp	/^    const bool ifinit;$/;"	m	class:GMXMDP	access:public
ifinit	gmxmdp.hpp	/^  const bool ifinit;$/;"	m	class:GMXMDP::GMXPGRP	access:public
ifmerged	likelihoodfunc.hpp	/^      bool ifmerged = false;$/;"	l
ifmin	gwham.cpp	/^  const bool ifmin = stoul(argv[k++]);$/;"	l
ifperm	fileio.hpp	/^    const bool ifperm; \/\/if true, won't exit even though a file can't be opened$/;"	m	class:fileio	access:public
ifreadhist	gwham.cpp	/^  const bool ifreadhist = stoul(argv[k++]);$/;"	l
ihist	gwham.cpp	/^    const uint ihist = pmdp2ihist.find(pmdp)->second;$/;"	l
iit	gmxmdp.hpp	/^  InIterator iit = itbegin;$/;"	l
ij	gmxmdp.hpp	/^    auto ij = key2opt.find(Akeystr);$/;"	l
imax	gwham.hpp	/^    uint imax = i;$/;"	l
implement.tex	doc/tex/implement.tex	1;"	F
index	mc.hpp	/^	  const uint index = int( ( i%stride_array[j] ) \/ stride_array[j+1] );$/;"	l
infinity	mpfrc++/mpreal.h	/^        inline static const mpfr::mpreal infinity()         { return mpfr::const_infinity();     }$/;"	f	class:std::numeric_limits	access:public
init	gmxmdp.cpp	/^    const vector<valtype> init = pgrp.init;$/;"	l
init	gwham.hpp	/^     void init(const map<coordtype, vector<uint> >& _record, $/;"	p	class:WHAM	access:private
init	gwham.hpp	/^void WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::init$/;"	f	class:WHAM
init	timeseries.hpp	/^    void init() {$/;"	f	class:TimeSeries	access:private
initB	gmxmdp.cpp	/^    const vector<valtype> initB = pgrp.initB;$/;"	l
initialize	mpfrc++/mpreal.h	/^    static bool initialize = true;$/;"	l
initopts	gmxmdp.hpp	/^    bool initopts() {$/;"	f	class:GMXMDP	access:private
initopts	gmxmdp.hpp	/^  bool initopts() {$/;"	f	class:GMXMDP::GMXPGRP	access:private
input	fileio_utils.hpp	/^  ss << input;$/;"	l
input	metaprog_snippets.hpp	/^      stream << input;$/;"	l
insert	gmxmdp.cpp	/^  ans.insert(ans.end(), Lcnt1.begin(), Lcnt1.end());$/;"	p	file:
insert	gmxmdp.cpp	/^  ans.insert(ans.end(), Lcnt2.begin(), Lcnt2.end());$/;"	p	file:
insert	gmxmdp.cpp	/^  ans.insert(ans.end(), Lcnt3.begin(), Lcnt3.end());$/;"	p	file:
insert	likelihoodfunc.hpp	/^      port.insert(port.end(), newport.begin(), newport.end());$/;"	p
insert	mdp.hpp	/^      for(const auto& L : Ls) ans.insert(ans.end(), L.begin(), L.end());$/;"	p
internal	mpfrc++/mpreal.h	/^namespace internal{$/;"	n	namespace:mpfr
intgl	mc.hpp	/^      valtype intgl = 0.0;$/;"	l
intopts	gmxmdp.hpp	/^    typedef map<string, intref> intopts;$/;"	t	class:GMXMDP	access:public
intref	gmxmdp.hpp	/^    typedef rw<int> intref;$/;"	t	class:GMXMDP	access:public
intro.tex	doc/tex/intro.tex	1;"	F
iomode	fileio.hpp	/^    ios_base::openmode iomode; \/\/read or write$/;"	m	class:fileio	access:public
isEqualFuzzy	mpfrc++/mpreal.h	/^inline bool isEqualFuzzy(const mpreal& a, const mpreal& b);$/;"	p	namespace:mpfr
isEqualFuzzy	mpfrc++/mpreal.h	/^inline bool isEqualFuzzy(const mpreal& a, const mpreal& b, const mpreal& eps);$/;"	p	namespace:mpfr
isEqualUlps	mpfrc++/mpreal.h	/^inline bool isEqualUlps(const mpreal& a, const mpreal& b, int maxUlps);$/;"	p	namespace:mpfr
isExpandedEnsemble	mdp.hpp	/^    bool isExpandedEnsemble() const { return Nstates > 1; };$/;"	f	class:MDP	access:public
is_bounded	mpfrc++/mpreal.h	/^        static const bool is_bounded        = true;$/;"	m	class:std::numeric_limits	access:public
is_exact	mpfrc++/mpreal.h	/^        static const bool is_exact          = false;$/;"	m	class:std::numeric_limits	access:public
is_floating_point	mpfrc++/mpreal.h	/^    struct is_floating_point<mpfr::mpreal> : public std::true_type {};$/;"	s	namespace:std	inherits:std::true_type
is_iec559	mpfrc++/mpreal.h	/^        static const bool is_iec559         = true;        \/\/ = IEEE 754$/;"	m	class:std::numeric_limits	access:public
is_integer	mpfrc++/mpreal.h	/^        static const bool is_integer        = false;$/;"	m	class:std::numeric_limits	access:public
is_modulo	mpfrc++/mpreal.h	/^        static const bool is_modulo         = false;$/;"	m	class:std::numeric_limits	access:public
is_placeholder	functor.hpp	/^  struct is_placeholder< ::myplaceholder<i> > : public integral_constant<size_t, i>{};$/;"	s	namespace:std	inherits:integral_constant
is_pointer	metaprog_snippets.hpp	/^struct is_pointer<std::shared_ptr<T>> : std::true_type {};$/;"	s	namespace:std	inherits:std::true_type
is_signed	mpfrc++/mpreal.h	/^        static const bool is_signed         = true;$/;"	m	class:std::numeric_limits	access:public
is_specialized	mpfrc++/mpreal.h	/^        static const bool is_specialized    = true;$/;"	m	class:std::numeric_limits	access:public
is_stdfloat	metaprog_snippets.hpp	/^struct is_stdfloat<double> : std::true_type {};$/;"	s	inherits:std::true_type
is_stdfloat	metaprog_snippets.hpp	/^struct is_stdfloat<float> : std::true_type {};$/;"	s	inherits:std::true_type
is_stdfloat	metaprog_snippets.hpp	/^struct is_stdfloat<long double> : std::true_type {};$/;"	s	inherits:std::true_type
is_stdfloat	metaprog_snippets.hpp	/^template < class T > struct is_stdfloat : std::false_type {};$/;"	s	inherits:std::false_type
is_string	metaprog_snippets.hpp	/^struct is_string<std::basic_string<charT, traits, Alloc> > : std::true_type {};$/;"	s	inherits:std::true_type
is_string	metaprog_snippets.hpp	/^template < class T > struct is_string : std::false_type {};$/;"	s	inherits:std::false_type
isdefault	gmxmdp.hpp	/^isdefault(const T& obj) {$/;"	f
isfinite	mpfrc++/mpreal.h	/^    friend bool isfinite (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
isfinite	mpfrc++/mpreal.h	/^inline bool isfinite (const mpreal& op){    return (mpfr_number_p (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
isinf	mpfrc++/mpreal.h	/^    friend bool isinf    (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
isinf	mpfrc++/mpreal.h	/^inline bool isinf    (const mpreal& op){    return (mpfr_inf_p    (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
isint	mpfrc++/mpreal.h	/^    friend bool isint    (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
isint	mpfrc++/mpreal.h	/^inline bool isint    (const mpreal& op){    return (mpfr_integer_p(op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
isnan	mpfrc++/mpreal.h	/^    friend bool isnan    (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
isnan	mpfrc++/mpreal.h	/^    inline bool isnan    (const mpfr::mpreal& op){    return (mpfr_nan_p    (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:std
isnan	mpfrc++/mpreal.h	/^inline bool isnan    (const mpreal& op){    return (mpfr_nan_p    (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
isnum	mpfrc++/mpreal.h	/^    friend bool isnum    (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
isregular	mpfrc++/mpreal.h	/^    friend bool isregular(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
isregular	mpfrc++/mpreal.h	/^inline bool isregular(const mpreal& op){    return (mpfr_regular_p(op.mpfr_srcptr()));}$/;"	f	namespace:mpfr
iss	fileio_utils.cpp	/^    istringstream iss(pch);$/;"	p	file:
iss	fileio_utils.hpp	/^    istringstream iss(input[i]);$/;"	p
iss	fileio_utils.hpp	/^  istringstream iss(str);$/;"	p
iszero	mdp.hpp	/^bool iszero(const vector<T>& op) {$/;"	f
iszero	mpfrc++/mpreal.h	/^    friend bool iszero   (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
iszero	mpfrc++/mpreal.h	/^inline bool iszero   (const mpreal& op){    return (mpfr_zero_p   (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
it	gmxmdp.cpp	/^    const map<string, bool>::const_iterator it = str2dim.find(bitstr);$/;"	l
it	gmxmdp.hpp	/^  const typename map<string,T>::const_iterator it = str2enum.find(str);$/;"	l
it	gmxmdp.hpp	/^  typename map<string, reference_wrapper<T>>::const_iterator it = key2opt.begin();$/;"	l
it	gnarray.hpp	/^      const_iterator it = narr.find(coord);$/;"	l
it	gnarray.hpp	/^    const iterator it = narr.find(coord);$/;"	l
it	gwham.cpp	/^    typename histogram::iterator it;$/;"	l
it	gwham.hpp	/^      const auto it = seen.find(imax);$/;"	l
it	gwham.hpp	/^  typename HISTOGRAM::const_iterator it;$/;"	l
it	likelihoodfunc.hpp	/^      auto it = joints.find(node);$/;"	l
it	likelihoodfunc.hpp	/^      auto it = routes.find(node);$/;"	l
it	mc.cpp	/^    typename histogram::const_iterator it;$/;"	l
it	mdp_factory.hpp	/^    const Tmapciterator it = suffix2mdp.find(MDPsuffix);$/;"	l
it1	likelihoodfunc.hpp	/^      auto it1 = routes.find(node1);$/;"	l
it2	likelihoodfunc.hpp	/^      auto it2 = routes.find(node2);$/;"	l
itC	gwham.hpp	/^    typename NARRAY::const_iterator itC = C.begin();$/;"	l
itC	likelihoodfunc.hpp	/^      narrcit itC = C.begin();$/;"	l
itb	likelihoodfunc.hpp	/^	  auto itb = broutes.find(node);$/;"	l
itb	likelihoodfunc.hpp	/^        auto itb = broutes.find(rnode);$/;"	l
itc	gwham.hpp	/^      const typename NARRAY::iterator itc = C.find(coord);$/;"	l
iter	minimizer/cg.hpp	/^	Int iter;$/;"	m	struct:Frprmn	access:public
iterator	densityofstate.hpp	/^    typedef typename narray::iterator iterator;$/;"	t	class:DensityOfState	access:public
iterator	gmxmdp.hpp	/^  typedef typename map<string,reference_wrapper<T>>::iterator iterator;$/;"	t
iterator	gnarray.hpp	/^    typedef typename map<Tcoord, Telem>::iterator iterator;$/;"	t	class:gnarray	access:public
itfi	likelihoodfunc.hpp	/^	  const auto& itfi = edge[1];$/;"	l
itfj	likelihoodfunc.hpp	/^	  const auto& itfj = edge[0];$/;"	l
itfnode	likelihoodfunc.hpp	/^      const auto& itfnode = routes.find(edge[0]);$/;"	l
ithead	likelihoodfunc.hpp	/^      const auto ithead = routes.find(head);$/;"	l
itmax	gwham.cpp	/^    narray::iterator itmax = rho.begin();$/;"	l
itmax	mc.cpp	/^  narray::iterator itmax = rho.begin();$/;"	l
itpot	gwham.cpp	/^  auto itpot = pot.cbegin();$/;"	l
itr	gwham.cpp	/^    auto itr = pmdp2ipens.equal_range(pmdp);$/;"	l
itrhs	gnarray.hpp	/^    const auto& itrhs = rhs.find(coord);$/;"	l
its	minimizer/cg.hpp	/^			  cout << "#At iteration: " << its << " states are:\\n";$/;"	l
itsNgexpmH	gwham.hpp	/^    vector<typename NARRAY::const_iterator> itsNgexpmH, itsexpmH;$/;"	l
itsNgexpmH	likelihoodfunc.hpp	/^        vector<narrcit> itsNgexpmH;$/;"	l
itsexpmH	gwham.hpp	/^    vector<typename NARRAY::const_iterator> itsNgexpmH, itsexpmH;$/;"	l
itsrcjoint	likelihoodfunc.hpp	/^      const auto itsrcjoint = srcjoints.find(newnode); $/;"	l
ittail	likelihoodfunc.hpp	/^      const auto ittail = routes.find(tail);$/;"	l
iv	ran2.c	/^	static long iv[NTAB];$/;"	l	file:
iy	ran2.c	/^	static long iy=0;$/;"	l	file:
j	gmxmdp.cpp	/^    uint j = 0;$/;"	l
j	ran2.c	/^	int j;$/;"	l
joints	likelihoodfunc.hpp	/^    map<Node, vector<uint> > joints;$/;"	m	class:ftree	access:public
k	gmxmdp.hpp	/^  valtype k = NaN, kB = k;$/;"	m	class:GMXMDP::GMXPGRP	access:public
k	gwham.cpp	/^  uint k = 1;$/;"	l
k	mc.cpp	/^  const vector<valtype> k(dim,spring);$/;"	p	file:
k	mc.hpp	/^    const vector<valtype> k;$/;"	m	class:harmonic	access:private
k	ran2.c	/^	long k;$/;"	l
k0	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
k0B	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
k1	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
k1B	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
kB	ensemble.hpp	/^    const valtype kB; $/;"	m	class:Ensemble	access:protected
kB	gmxmdp.hpp	/^  valtype k = NaN, kB = k;$/;"	m	class:GMXMDP::GMXPGRP	access:public
kB	gwham.cpp	/^    const auto kB = pmdp0->getkB();$/;"	l
kB	mc.cpp	/^  const valtype kB = 0.0019872041; \/\/boltzmann factor in kcal\/mol\/K$/;"	l
kB	mc.hpp	/^    const valtype kB;$/;"	m	class:MC	access:private
kB	mdp.hpp	/^    valtype kB = Boltzmannkcal;$/;"	m	class:MDP	access:protected
key	gmxmdp.hpp	/^    const string& key = it->first;$/;"	l
key	gmxmdp.hpp	/^    fcout << key + " = ";$/;"	l
key2int	gmxmdp.hpp	/^    intopts key2int;$/;"	m	class:GMXMDP	access:public
key2str	gmxmdp.hpp	/^    stropts key2str; $/;"	m	class:GMXMDP	access:public
key2val	gmxmdp.hpp	/^    dblopts key2val;  $/;"	m	class:GMXMDP	access:public
key2val	gmxmdp.hpp	/^  dblopts key2val; $/;"	m	class:GMXMDP::GMXPGRP	access:public
key2vecstr	gmxmdp.hpp	/^    vecstropts key2vecstr;$/;"	m	class:GMXMDP	access:public
key2vvec	gmxmdp.hpp	/^    vecopts key2vvec;$/;"	m	class:GMXMDP	access:public
key2vvec	gmxmdp.hpp	/^  vecopts key2vvec;$/;"	m	class:GMXMDP::GMXPGRP	access:public
lambda	gmxmdp.cpp	/^  vector<valtype> lambda; $/;"	l
lambdas	gmxmdp.cpp	/^  vector<vector<valtype> > lambdas;$/;"	l
lb	fileio.hpp	/^    linecounter lb; \/\/beginning (from 1) line of input file to be actually parsed $/;"	m	class:fileio	access:public
lc	fileio.hpp	/^    linecounter lc; \/\/number of lines actually read, excluding comments but including lines before fileio::lb$/;"	m	class:fileio	access:public
ldev	functor.hpp	/^	const T ldev = dev - r0;$/;"	l
ldexp	mpfrc++/mpreal.h	/^    friend const mpreal ldexp(const mpreal& v, mp_exp_t exp);$/;"	p	class:mpfr::mpreal	access:friend
le	fileio.hpp	/^    linecounter le; \/\/ending line of input file to be actually parsed$/;"	m	class:fileio	access:public
lgamma	mpfrc++/mpreal.h	/^    friend const mpreal lgamma   (const mpreal& v, int *signp, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
li2	mpfrc++/mpreal.h	/^    friend const mpreal li2         (const mpreal& v,                       mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
li2	mpfrc++/mpreal.h	/^inline const mpreal li2 (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) $/;"	f	namespace:mpfr
likelihoodfunc.hpp	likelihoodfunc.hpp	1;"	F
line	fileio.hpp	/^    string line; \/\/used by fileio::readbyline()$/;"	m	class:fileio	access:public
line	gmxmdp.cpp	/^      const string& line = fio.line;$/;"	l
line2str	fileio.hpp	/^    vector<string> line2str(const string& delims=" \\t") const {$/;"	f	class:fileio	access:public
line2val	fileio.hpp	/^    vector<V> line2val() const {$/;"	f	class:fileio	access:public
linecounter	typedefs.hpp	/^typedef ulong linecounter; \/\/the file line counter$/;"	t
lines	fileio.hpp	/^    vector<string> lines; \/\/used by fileio::readall()$/;"	m	class:fileio	access:public
linmin	minimizer/cg.hpp	/^	Doub linmin()$/;"	f	struct:Dlinemethod	access:public
lngamma	mpfrc++/mpreal.h	/^    friend const mpreal lngamma  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
log	mpfrc++/mpreal.h	/^    friend const mpreal log  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
log10	mpfrc++/mpreal.h	/^    friend const mpreal log10(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
log1p	mpfrc++/mpreal.h	/^    friend const mpreal log1p(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
log2	mpfrc++/mpreal.h	/^    friend const mpreal log2 (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
lowest	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal lowest   (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return -mpfr::maxval(precision);  }$/;"	f	class:std::numeric_limits	access:public
ls	fileio.hpp	/^    linecounter ls; \/\/parse the input file every this many of lines, starting from fileio::lb$/;"	m	class:fileio	access:public
ls	gmxmdp.cpp	/^    const linecounter ls = linecounter(nstdhdlcv\/nstdhdl); $/;"	l
lse	gmxmdp.cpp	/^    const linecounter lse = linecounter(nstcv\/nstenergy);$/;"	l
lsx	gmxmdp.cpp	/^  const linecounter lsx = linecounter(nstcv\/nstx);$/;"	l
lv	gnarray.hpp	/^    vector<Tval> lv;$/;"	m	class:gnarray	access:private
lv	gwham.cpp	/^  const vector<valtype> lv = split<valtype>(argv[k++]); $/;"	l
lv	gwham.hpp	/^     const vector<valtype> lv;$/;"	m	class:WHAM	access:private
lv	mc.cpp	/^  vector<valtype> hv, lv;$/;"	l
lvstr	mc.cpp	/^  const string lvstr = string(argv[4]); $/;"	l
machine_epsilon	mpfrc++/mpreal.h	/^inline mpreal machine_epsilon(const mpreal& x);        $/;"	p	namespace:mpfr
machine_epsilon	mpfrc++/mpreal.h	/^inline mpreal machine_epsilon(mp_prec_t prec = mpreal::get_default_prec());$/;"	p	namespace:mpfr
macro.tex	doc/tex/macro.tex	1;"	F
main	gwham.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	mc.cpp	/^int main(int argc, char* argv[]) {$/;"	f
make_index_seq	metaprog_snippets.hpp	/^struct make_index_seq< false, Indices, Propagator<Indices, PropagatorArg>, Terminator<Indices, TerminatorArg> > {$/;"	s
make_index_seq	metaprog_snippets.hpp	/^struct make_index_seq<true, Indices, Propagator, Terminator> {$/;"	s
make_index_seq	metaprog_snippets.hpp	/^struct make_index_seq{};$/;"	s
make_index_seq::newIndices	metaprog_snippets.hpp	/^  typedef typename Propagator<Indices, PropagatorArg>::type newIndices;$/;"	t	struct:make_index_seq	access:public
make_index_seq::newPropagator	metaprog_snippets.hpp	/^  typedef Propagator<newIndices,newPropagatorArg> newPropagator;$/;"	t	struct:make_index_seq	access:public
make_index_seq::newPropagatorArg	metaprog_snippets.hpp	/^  typedef typename Propagator<Indices, PropagatorArg>::seed newPropagatorArg;$/;"	t	struct:make_index_seq	access:public
make_index_seq::newTerminator	metaprog_snippets.hpp	/^  typedef Terminator<newIndices,TerminatorArg> newTerminator;$/;"	t	struct:make_index_seq	access:public
make_index_seq::newdecision	metaprog_snippets.hpp	/^  constexpr static bool newdecision = newTerminator::decision;$/;"	m	struct:make_index_seq	access:public
make_index_seq::type	metaprog_snippets.hpp	/^  typedef Indices type;$/;"	t	struct:make_index_seq	access:public
make_index_seq::type	metaprog_snippets.hpp	/^  typedef typename make_index_seq<newdecision, newIndices, newPropagator, newTerminator>::type type; $/;"	t	struct:make_index_seq	access:public
make_pair	ensemble_factory.hpp	/^	    pmdp2ipens.insert(make_pair(pmdp, j));$/;"	p
make_pair	ensemble_factory.hpp	/^    pmdp2ipens.insert(make_pair(pmdp, ens.size()-1));$/;"	p
make_shared	mc.cpp	/^    V.emplace_back(make_shared<NVT>(kB, Hamiltonian{functors}, T));$/;"	p	file:
max	gwham.hpp	/^    T max = numeric_limits<T>::is_signed ? -numeric_limits<T>::max() : numeric_limits<T>::min();$/;"	l
max	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal (max)    (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::maxval(precision);  }$/;"	f	class:std::numeric_limits::mpfr	access:public
max	mpfrc++/mpreal.h	/^const mpreal (max)(const mpreal& x, const mpreal& y);$/;"	p	namespace:mpfr
max	mpfrc++/mpreal.h	/^inline const mpreal (max)(const mpreal& x, const mpreal& y){    return (x>y?x:y);       }$/;"	f	namespace:mpfr
max_digits10	mpfrc++/mpreal.h	/^        inline static int max_digits10(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits	access:public
max_digits10	mpfrc++/mpreal.h	/^        static const int max_digits10 = 16;$/;"	m	class:std::numeric_limits	access:public
max_exponent	mpfrc++/mpreal.h	/^        static const int max_exponent = MPFR_EMAX_DEFAULT;$/;"	m	class:std::numeric_limits	access:public
max_exponent10	mpfrc++/mpreal.h	/^        MPREAL_PERMISSIVE_EXPR static const int max_exponent10 = (int) (MPFR_EMAX_DEFAULT * 0.3010299956639811); $/;"	m	class:std::numeric_limits	access:public
maxdpmf	mc.cpp	/^  valtype mindpmf = 9999999999, maxdpmf = -9999999999;$/;"	l
maxval	mpfrc++/mpreal.h	/^inline mpreal maxval(mp_prec_t prec = mpreal::get_default_prec());$/;"	p	namespace:mpfr
mc	mc.cpp	/^    MC<potpoly_dblwell,harmonic> mc(kB,T,pot,bias,nsteps,stepsize);$/;"	p	file:
mc.cpp	mc.cpp	1;"	F
mc.hpp	mc.hpp	1;"	F
mdp.hpp	mdp.hpp	1;"	F
mdp0prefixes	gwham.cpp	/^  const vector<string> mdp0prefixes = split<string>(argv[k++]);$/;"	l
mdp_factory.hpp	mdp_factory.hpp	1;"	F
mdpsuffixes	gwham.cpp	/^  const vector<string> mdpsuffixes = split<string>(argv[k++]); $/;"	l
mergebranch	likelihoodfunc.hpp	/^void mergebranch(const vector<vector<uint>>& nbnodes, vector<FTree>& trees, vector<typename FTree::Data>& f) {$/;"	f
mergebranch2nd	likelihoodfunc.hpp	/^void mergebranch2nd(const vector<vector<uint>>& nbnodes, vector<FTree>& trees, vector<typename FTree::Data>& f) {$/;"	f
mergebranchNNB	likelihoodfunc.hpp	/^void mergebranchNNB(vector<FTree>& trees) {$/;"	f
metaprog_snippets.hpp	metaprog_snippets.hpp	1;"	F
min	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal (min)    (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::minval(precision);  }$/;"	f	class:std::numeric_limits::mpfr	access:public
min	mpfrc++/mpreal.h	/^const mpreal (min)(const mpreal& x, const mpreal& y);$/;"	p	namespace:mpfr
min	mpfrc++/mpreal.h	/^inline const mpreal (min)(const mpreal& x, const mpreal& y){    return (x<y?x:y);       }$/;"	f	namespace:mpfr
min_exponent	mpfrc++/mpreal.h	/^        static const int min_exponent = MPFR_EMIN_DEFAULT;$/;"	m	class:std::numeric_limits	access:public
min_exponent10	mpfrc++/mpreal.h	/^        MPREAL_PERMISSIVE_EXPR static const int min_exponent10 = (int) (MPFR_EMIN_DEFAULT * 0.3010299956639811); $/;"	m	class:std::numeric_limits	access:public
mindpmf	mc.cpp	/^  valtype mindpmf = 9999999999, maxdpmf = -9999999999;$/;"	l
minimize	minimizer/cg.hpp	/^	Doub minimize(T &funcd)$/;"	f	struct:Dbrent	access:public
minimize	minimizer/cg.hpp	/^	VecDoub minimize(VecDoub_I &pp)$/;"	f	struct:Frprmn	access:public
minval	mpfrc++/mpreal.h	/^inline mpreal minval(mp_prec_t prec = mpreal::get_default_prec());$/;"	p	namespace:mpfr
mod	mpfrc++/mpreal.h	/^    friend const mpreal mod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode); \/\/ Modulus after division$/;"	p	class:mpfr::mpreal	access:friend
mod	mpfrc++/mpreal.h	/^inline const mpreal mod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mode	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(), u, mode);$/;"	l
mode	mpfrc++/mpreal.h	/^	mpfr_set_d(mpfr_ptr(), u, mode);$/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), u, mode);$/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), u, mode);$/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), u, mode);$/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_sj(mpfr_ptr(), u, mode); $/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s, base, mode); $/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode); $/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), u, mode);$/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_uj(mpfr_ptr(), u, mode); $/;"	l
mode	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), u, mode);$/;"	l
modf	mpfrc++/mpreal.h	/^    friend const mpreal modf(const mpreal& v, mpreal& n);    $/;"	p	class:mpfr::mpreal	access:friend
mov3	minimizer/cg.hpp	/^	inline void mov3(Doub &a, Doub &b, Doub &c, const Doub d, const Doub e,$/;"	f	struct:Bracketmethod	access:public
mp	mpfrc++/mpreal.h	/^    mpfr_t mp;$/;"	m	class:mpfr::mpreal	access:private
mpf_get_prec	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(),(mp_prec_t) mpf_get_prec(u)); \/\/ (gmp: mp_bitcnt_t) unsigned long -> long (mpfr: mp_prec_t)$/;"	p
mpfr	mpfrc++/mpreal.h	/^namespace mpfr {$/;"	n
mpfr::LOG10_2	mpfrc++/mpreal.h	/^    const double LOG10_2 = 0.30102999566398119;$/;"	l
mpfr::LOG2_10	mpfrc++/mpreal.h	/^    const double LOG2_10 = 3.3219280948873624;$/;"	l
mpfr::a	mpfrc++/mpreal.h	/^    mpreal a(x);$/;"	p
mpfr::a	mpfrc++/mpreal.h	/^    mpreal a;$/;"	l
mpfr::abs	mpfrc++/mpreal.h	/^inline const mpreal abs(const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::agm	mpfrc++/mpreal.h	/^inline const mpreal agm (const mpreal& v1, const mpreal& v2, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::ai	mpfrc++/mpreal.h	/^inline const mpreal ai      (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(ai);          }$/;"	f	namespace:mpfr
mpfr::base	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s, base, mode); $/;"	l
mpfr::base	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode); $/;"	l
mpfr::bits2digits	mpfrc++/mpreal.h	/^inline int       bits2digits(mp_prec_t b);$/;"	p	namespace:mpfr
mpfr::bits2digits	mpfrc++/mpreal.h	/^inline int bits2digits(mp_prec_t b)$/;"	f	namespace:mpfr
mpfr::c_str	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode); $/;"	p
mpfr::ceil	mpfrc++/mpreal.h	/^inline const mpreal ceil(const mpreal& v)$/;"	f	namespace:mpfr
mpfr::const_catalan	mpfrc++/mpreal.h	/^inline const mpreal const_catalan (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::const_euler	mpfrc++/mpreal.h	/^inline const mpreal const_euler (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::const_infinity	mpfrc++/mpreal.h	/^inline const mpreal const_infinity (int sign = 1, mp_prec_t p = mpreal::get_default_prec())$/;"	f	namespace:mpfr
mpfr::const_log2	mpfrc++/mpreal.h	/^inline const mpreal const_log2 (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::const_pi	mpfrc++/mpreal.h	/^inline const mpreal const_pi (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::conversion_overflow	mpfrc++/mpreal.h	/^class conversion_overflow : public std::exception {$/;"	c	namespace:mpfr	inherits:std::exception
mpfr::conversion_overflow::why	mpfrc++/mpreal.h	/^    std::string why() { return "inexact conversion from floating point"; }$/;"	f	class:mpfr::conversion_overflow	access:public
mpfr::digamma	mpfrc++/mpreal.h	/^inline const mpreal digamma (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(digamma);     }$/;"	f	namespace:mpfr
mpfr::digits	mpfrc++/mpreal.h	/^    format << "%." << digits << "RNg";$/;"	l
mpfr::digits	mpfrc++/mpreal.h	/^    int digits = (n >= 0) ? n : bits2digits(mpfr_get_prec(mpfr_srcptr()));$/;"	l
mpfr::digits2bits	mpfrc++/mpreal.h	/^inline mp_prec_t digits2bits(int d)$/;"	f	namespace:mpfr
mpfr::digits2bits	mpfrc++/mpreal.h	/^inline mp_prec_t digits2bits(int d);$/;"	p	namespace:mpfr
mpfr::div_2si	mpfrc++/mpreal.h	/^inline const mpreal div_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::div_2si	mpfrc++/mpreal.h	/^inline const mpreal div_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::div_2ui	mpfrc++/mpreal.h	/^inline const mpreal div_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::div_2ui	mpfrc++/mpreal.h	/^inline const mpreal div_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::flags	mpfrc++/mpreal.h	/^    const std::ios::fmtflags flags = os.flags();$/;"	l
mpfr::floor	mpfrc++/mpreal.h	/^inline const mpreal floor(const mpreal& v)$/;"	f	namespace:mpfr
mpfr::fmax	mpfrc++/mpreal.h	/^inline const mpreal fmax(const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::fmin	mpfrc++/mpreal.h	/^inline const mpreal fmin(const mpreal& x, const mpreal& y,  mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::fmod	mpfrc++/mpreal.h	/^inline const mpreal fmod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::format	mpfrc++/mpreal.h	/^    std::ostringstream format;$/;"	l
mpfr::frac	mpfrc++/mpreal.h	/^inline const mpreal frac       (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(frac      );     }$/;"	f	namespace:mpfr
mpfr::grandom	mpfrc++/mpreal.h	/^inline const mpreal grandom (gmp_randstate_t& state, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::grandom	mpfrc++/mpreal.h	/^inline const mpreal grandom(unsigned int seed = 0)$/;"	f	namespace:mpfr
mpfr::i	mpfrc++/mpreal.h	/^    int i;$/;"	l
mpfr::i	mpfrc++/mpreal.h	/^    unsigned long int i;$/;"	l
mpfr::initialize	mpfrc++/mpreal.h	/^    static bool initialize = true;$/;"	l
mpfr::internal	mpfrc++/mpreal.h	/^namespace internal{$/;"	n	namespace:mpfr
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<double>              {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<int>                 {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<long double>         {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<long int>            {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<long long>           {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpq_t>               {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpreal>              {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpz_t>               {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned int>        {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned long int>   {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned long long>  {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type	mpfrc++/mpreal.h	/^    template <typename ArgumentType> struct result_type {};    $/;"	s	namespace:mpfr::internal
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<double>              {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<int>                 {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<long double>         {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<long int>            {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<long long>           {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpq_t>               {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpreal>              {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpz_t>               {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned int>        {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned long int>   {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::internal::result_type::type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned long long>  {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
mpfr::isEqualFuzzy	mpfrc++/mpreal.h	/^inline bool isEqualFuzzy(const mpreal& a, const mpreal& b);$/;"	p	namespace:mpfr
mpfr::isEqualFuzzy	mpfrc++/mpreal.h	/^inline bool isEqualFuzzy(const mpreal& a, const mpreal& b, const mpreal& eps);$/;"	p	namespace:mpfr
mpfr::isEqualUlps	mpfrc++/mpreal.h	/^inline bool isEqualUlps(const mpreal& a, const mpreal& b, int maxUlps);$/;"	p	namespace:mpfr
mpfr::isfinite	mpfrc++/mpreal.h	/^inline bool isfinite (const mpreal& op){    return (mpfr_number_p (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
mpfr::isinf	mpfrc++/mpreal.h	/^inline bool isinf    (const mpreal& op){    return (mpfr_inf_p    (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
mpfr::isint	mpfrc++/mpreal.h	/^inline bool isint    (const mpreal& op){    return (mpfr_integer_p(op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
mpfr::isnan	mpfrc++/mpreal.h	/^inline bool isnan    (const mpreal& op){    return (mpfr_nan_p    (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
mpfr::isregular	mpfrc++/mpreal.h	/^inline bool isregular(const mpreal& op){    return (mpfr_regular_p(op.mpfr_srcptr()));}$/;"	f	namespace:mpfr
mpfr::iszero	mpfrc++/mpreal.h	/^inline bool iszero   (const mpreal& op){    return (mpfr_zero_p   (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
mpfr::li2	mpfrc++/mpreal.h	/^inline const mpreal li2 (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) $/;"	f	namespace:mpfr
mpfr::machine_epsilon	mpfrc++/mpreal.h	/^inline mpreal machine_epsilon(const mpreal& x);        $/;"	p	namespace:mpfr
mpfr::machine_epsilon	mpfrc++/mpreal.h	/^inline mpreal machine_epsilon(mp_prec_t prec = mpreal::get_default_prec());$/;"	p	namespace:mpfr
mpfr::max	mpfrc++/mpreal.h	/^const mpreal (max)(const mpreal& x, const mpreal& y);$/;"	p	namespace:mpfr
mpfr::max	mpfrc++/mpreal.h	/^inline const mpreal (max)(const mpreal& x, const mpreal& y){    return (x>y?x:y);       }$/;"	f	namespace:mpfr
mpfr::maxval	mpfrc++/mpreal.h	/^inline mpreal maxval(mp_prec_t prec = mpreal::get_default_prec());$/;"	p	namespace:mpfr
mpfr::min	mpfrc++/mpreal.h	/^const mpreal (min)(const mpreal& x, const mpreal& y);$/;"	p	namespace:mpfr
mpfr::min	mpfrc++/mpreal.h	/^inline const mpreal (min)(const mpreal& x, const mpreal& y){    return (x<y?x:y);       }$/;"	f	namespace:mpfr
mpfr::minval	mpfrc++/mpreal.h	/^inline mpreal minval(mp_prec_t prec = mpreal::get_default_prec());$/;"	p	namespace:mpfr
mpfr::mod	mpfrc++/mpreal.h	/^inline const mpreal mod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::mode	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(), u, mode);$/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^	mpfr_set_d(mpfr_ptr(), u, mode);$/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), u, mode);$/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), u, mode);$/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), u, mode);$/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_sj(mpfr_ptr(), u, mode); $/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s, base, mode); $/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode); $/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), u, mode);$/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_uj(mpfr_ptr(), u, mode); $/;"	l
mpfr::mode	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), u, mode);$/;"	l
mpfr::mpf_get_prec	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(),(mp_prec_t) mpf_get_prec(u)); \/\/ (gmp: mp_bitcnt_t) unsigned long -> long (mpfr: mp_prec_t)$/;"	p
mpfr::mpfr_get_prec	mpfrc++/mpreal.h	/^        mpfr_init2(mpfr_ptr(), mpfr_get_prec(u));$/;"	p
mpfr::mpfr_get_prec	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(),mpfr_get_prec(u.mpfr_srcptr()));$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^			clear(mpfr_ptr());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^			mpfr_init2(mpfr_ptr(), vp);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(), u, mode);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^	mpfr_set_d(mpfr_ptr(), u, mode);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^        mpfr_init2(mpfr_ptr(), mpfr_get_prec(u));$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^        mpfr_set  (mpfr_ptr(), u, mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), t, mpreal::get_default_rnd()); $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^     mpfr_init2(mpfr_ptr(), prec);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    clear(mpfr_ptr());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_d(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_q(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_z(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2  (mpfr_ptr(), prec);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2 (mpfr_ptr(), mpreal::get_default_prec()); $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2 (mpfr_ptr(), prec);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(), prec);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(),(mp_prec_t) mpf_get_prec(u)); \/\/ (gmp: mp_bitcnt_t) unsigned long -> long (mpfr: mp_prec_t)$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(),mpfr_get_prec(u.mpfr_srcptr()));$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set  (mpfr_ptr(),u.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), u, mode);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), u, mode);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), u, mode);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_sj(mpfr_ptr(), u, mode); $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s, base, mode); $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode); $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), 0, mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), u, mode);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_uj(mpfr_ptr(), u, mode); $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_uninitialized(mpfr_ptr());     \/\/ make sure "other" holds no pinter to actual data $/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), u, mode);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_setsign(mpfr_ptr(), mpfr_srcptr(), (sign < 0 ? 1 : 0), RoundingMode);$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_swap(mpfr_ptr(), other.mpfr_ptr());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_d(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_q(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_z(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_set  (mpfr_ptr(),u.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_setsign(mpfr_ptr(), mpfr_srcptr(), (sign < 0 ? 1 : 0), RoundingMode);$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr::mpreal	mpfrc++/mpreal.h	/^class mpreal {$/;"	c	namespace:mpfr
mpfr::mpreal::abs	mpfrc++/mpreal.h	/^    friend const mpreal abs(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::acos	mpfrc++/mpreal.h	/^    friend const mpreal acos  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::acosh	mpfrc++/mpreal.h	/^    friend const mpreal acosh (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::acot	mpfrc++/mpreal.h	/^    friend const mpreal acot  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::acoth	mpfrc++/mpreal.h	/^    friend const mpreal acoth (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::acsc	mpfrc++/mpreal.h	/^    friend const mpreal acsc  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::acsch	mpfrc++/mpreal.h	/^    friend const mpreal acsch (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::agm	mpfrc++/mpreal.h	/^    friend const mpreal agm      (const mpreal& v1, const mpreal& v2, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::ai	mpfrc++/mpreal.h	/^    friend const mpreal ai      (const mpreal& v,        mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::asec	mpfrc++/mpreal.h	/^    friend const mpreal asec  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::asech	mpfrc++/mpreal.h	/^    friend const mpreal asech (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::asin	mpfrc++/mpreal.h	/^    friend const mpreal asin  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::asinh	mpfrc++/mpreal.h	/^    friend const mpreal asinh (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::atan	mpfrc++/mpreal.h	/^    friend const mpreal atan  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::atan2	mpfrc++/mpreal.h	/^    friend const mpreal atan2 (const mpreal& y, const mpreal& x, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::atanh	mpfrc++/mpreal.h	/^    friend const mpreal atanh (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::besselj0	mpfrc++/mpreal.h	/^    friend const mpreal besselj0 (const mpreal& v, mp_rnd_t rnd_mode); $/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::besselj1	mpfrc++/mpreal.h	/^    friend const mpreal besselj1 (const mpreal& v, mp_rnd_t rnd_mode); $/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::besseljn	mpfrc++/mpreal.h	/^    friend const mpreal besseljn (long n, const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::bessely0	mpfrc++/mpreal.h	/^    friend const mpreal bessely0 (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::bessely1	mpfrc++/mpreal.h	/^    friend const mpreal bessely1 (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::besselyn	mpfrc++/mpreal.h	/^    friend const mpreal besselyn (long n, const mpreal& v, mp_rnd_t rnd_mode); $/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::cbrt	mpfrc++/mpreal.h	/^    friend const mpreal cbrt(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::ceil	mpfrc++/mpreal.h	/^    friend const mpreal ceil (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::check_range	mpfrc++/mpreal.h	/^    int check_range  (int t, mp_rnd_t rnd_mode = get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::clear	mpfrc++/mpreal.h	/^    void clear(::mpfr_ptr);$/;"	p	class:mpfr::mpreal	access:private
mpfr::mpreal::clear	mpfrc++/mpreal.h	/^inline void mpreal::clear(::mpfr_ptr x)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::cmpabs	mpfrc++/mpreal.h	/^    friend int cmpabs(const mpreal& a,const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::const_catalan	mpfrc++/mpreal.h	/^    friend const mpreal const_catalan   (mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::const_euler	mpfrc++/mpreal.h	/^    friend const mpreal const_euler     (mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::const_infinity	mpfrc++/mpreal.h	/^    friend const mpreal const_infinity(int sign, mp_prec_t prec);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::const_log2	mpfrc++/mpreal.h	/^    friend const mpreal const_log2      (mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::const_pi	mpfrc++/mpreal.h	/^    friend const mpreal const_pi        (mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::cos	mpfrc++/mpreal.h	/^    friend const mpreal cos(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::cosh	mpfrc++/mpreal.h	/^    friend const mpreal cosh  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::cot	mpfrc++/mpreal.h	/^    friend const mpreal cot(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::coth	mpfrc++/mpreal.h	/^    friend const mpreal coth  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::csc	mpfrc++/mpreal.h	/^    friend const mpreal csc(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::csch	mpfrc++/mpreal.h	/^    friend const mpreal csch  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::digamma	mpfrc++/mpreal.h	/^    friend const mpreal digamma (const mpreal& v,        mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::dim	mpfrc++/mpreal.h	/^    friend const mpreal dim(const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::div_2si	mpfrc++/mpreal.h	/^    friend inline const mpreal div_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::div_2ui	mpfrc++/mpreal.h	/^    friend inline const mpreal div_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::eint	mpfrc++/mpreal.h	/^    friend const mpreal eint   (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::erf	mpfrc++/mpreal.h	/^    friend const mpreal erf      (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::erfc	mpfrc++/mpreal.h	/^    friend const mpreal erfc     (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::exp	mpfrc++/mpreal.h	/^    friend const mpreal exp  (const mpreal& v, mp_rnd_t rnd_mode); $/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::exp10	mpfrc++/mpreal.h	/^    friend const mpreal exp10(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::exp2	mpfrc++/mpreal.h	/^    friend const mpreal exp2 (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::expm1	mpfrc++/mpreal.h	/^    friend const mpreal expm1(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::fabs	mpfrc++/mpreal.h	/^    friend const mpreal fabs(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::fac_ui	mpfrc++/mpreal.h	/^    friend const mpreal fac_ui (unsigned long int v,  mp_prec_t prec, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::fits_in_bits	mpfrc++/mpreal.h	/^    inline bool fits_in_bits(double x, int n);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::fits_in_bits	mpfrc++/mpreal.h	/^inline bool mpreal::fits_in_bits(double x, int n)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::floor	mpfrc++/mpreal.h	/^    friend const mpreal floor(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::fma	mpfrc++/mpreal.h	/^    friend const mpreal fma      (const mpreal& v1, const mpreal& v2, const mpreal& v3, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::fmax	mpfrc++/mpreal.h	/^    friend const mpreal fmax(const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::fmin	mpfrc++/mpreal.h	/^    friend const mpreal fmin(const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::fmod	mpfrc++/mpreal.h	/^    friend const mpreal fmod        (const mpreal& x, const mpreal& y,      mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::fms	mpfrc++/mpreal.h	/^    friend const mpreal fms      (const mpreal& v1, const mpreal& v2, const mpreal& v3, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::frac	mpfrc++/mpreal.h	/^    friend const mpreal frac        (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::frexp	mpfrc++/mpreal.h	/^    friend const mpreal frexp(const mpreal& v, mp_exp_t* exp);    $/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::gamma	mpfrc++/mpreal.h	/^    friend const mpreal gamma    (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::getPrecision	mpfrc++/mpreal.h	/^    inline int          getPrecision() const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::get_default_prec	mpfrc++/mpreal.h	/^    inline static mp_prec_t  get_default_prec()   {    return mpfr_get_default_prec();                            }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::get_default_prec	mpfrc++/mpreal.h	/^    mpfr_init2 (mpfr_ptr(), mpreal::get_default_prec()); $/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^        mpfr_set  (mpfr_ptr(), u, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), t, mpreal::get_default_rnd()); $/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    inline static mp_rnd_t   get_default_rnd()    {    return (mp_rnd_t)(mpfr_get_default_rounding_mode());       }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_d(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_q(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_add_z(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_div_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_mul_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set  (mpfr_ptr(),u.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(),u,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), 0, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_default_rnd	mpfrc++/mpreal.h	/^    mpfr_sub_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal
mpfr::mpreal::get_emax	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emax (void);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::get_emax_max	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emax_max (void);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::get_emax_min	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emax_min (void);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::get_emin	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emin (void);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::get_emin_max	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emin_max (void);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::get_emin_min	mpfrc++/mpreal.h	/^    static mp_exp_t  get_emin_min (void);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::get_exp	mpfrc++/mpreal.h	/^    mp_exp_t get_exp();$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::get_prec	mpfrc++/mpreal.h	/^    inline mp_prec_t    get_prec() const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::grandom	mpfrc++/mpreal.h	/^    friend const mpreal grandom (gmp_randstate_t& state, mp_rnd_t rnd_mode);     \/\/ use gmp_randinit_default() to init state, gmp_randclear() to clear$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::grandom	mpfrc++/mpreal.h	/^    friend const mpreal grandom (unsigned int seed);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::hypot	mpfrc++/mpreal.h	/^    friend const mpreal hypot (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::isfinite	mpfrc++/mpreal.h	/^    friend bool isfinite (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::isinf	mpfrc++/mpreal.h	/^    friend bool isinf    (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::isint	mpfrc++/mpreal.h	/^    friend bool isint    (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::isnan	mpfrc++/mpreal.h	/^    friend bool isnan    (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::isnum	mpfrc++/mpreal.h	/^    friend bool isnum    (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::isregular	mpfrc++/mpreal.h	/^    friend bool isregular(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::iszero	mpfrc++/mpreal.h	/^    friend bool iszero   (const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::ldexp	mpfrc++/mpreal.h	/^    friend const mpreal ldexp(const mpreal& v, mp_exp_t exp);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::lgamma	mpfrc++/mpreal.h	/^    friend const mpreal lgamma   (const mpreal& v, int *signp, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::li2	mpfrc++/mpreal.h	/^    friend const mpreal li2         (const mpreal& v,                       mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::lngamma	mpfrc++/mpreal.h	/^    friend const mpreal lngamma  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::log	mpfrc++/mpreal.h	/^    friend const mpreal log  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::log10	mpfrc++/mpreal.h	/^    friend const mpreal log10(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::log1p	mpfrc++/mpreal.h	/^    friend const mpreal log1p(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::log2	mpfrc++/mpreal.h	/^    friend const mpreal log2 (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::mod	mpfrc++/mpreal.h	/^    friend const mpreal mod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode); \/\/ Modulus after division$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::modf	mpfrc++/mpreal.h	/^    friend const mpreal modf(const mpreal& v, mpreal& n);    $/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::mp	mpfrc++/mpreal.h	/^    mpfr_t mp;$/;"	m	class:mpfr::mpreal	access:private
mpfr::mpreal::mpfr_ptr	mpfrc++/mpreal.h	/^    ::mpfr_ptr    mpfr_ptr();$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpfr_ptr	mpfrc++/mpreal.h	/^    ::mpfr_srcptr mpfr_ptr()    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpfr_ptr	mpfrc++/mpreal.h	/^inline ::mpfr_ptr     mpreal::mpfr_ptr()             { return mp; }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpfr_ptr	mpfrc++/mpreal.h	/^inline ::mpfr_srcptr  mpreal::mpfr_ptr()    const    { return mp; }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpfr_srcptr	mpfrc++/mpreal.h	/^    ::mpfr_srcptr mpfr_srcptr() const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpfr_srcptr	mpfrc++/mpreal.h	/^inline ::mpfr_srcptr  mpreal::mpfr_srcptr() const    { return mp; }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal();$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const char* s,             mp_prec_t prec = mpreal::get_default_prec(), int base = 10, mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const double u,                 mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const int u,                    mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const long double u,            mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const long int u,               mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const long long int u,          mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpf_t u);    $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpfr_t  u, bool shared = false);   $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpq_t u,                  mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());    $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpreal& u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpz_t u,                  mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());    $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const std::string& s,      mp_prec_t prec = mpreal::get_default_prec(), int base = 10, mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const unsigned int u,           mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const unsigned long int u,      mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(const unsigned long long int u, mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^    mpreal(mpreal&& u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal() $/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const char* s, mp_prec_t prec, int base, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const double u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const long double u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const long long u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpf_t u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpfr_t  u, bool shared)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpq_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpreal& u) $/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpz_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const std::string& s, mp_prec_t prec, int base, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const unsigned int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const unsigned long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const unsigned long long u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(mpreal&& other)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::mul_2si	mpfrc++/mpreal.h	/^    friend inline const mpreal mul_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::mul_2ui	mpfrc++/mpreal.h	/^    friend inline const mpreal mul_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::nextabove	mpfrc++/mpreal.h	/^    friend const mpreal nextabove  (const mpreal& x);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::nextbelow	mpfrc++/mpreal.h	/^    friend const mpreal nextbelow  (const mpreal& x);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::nexttoward	mpfrc++/mpreal.h	/^    friend const mpreal nexttoward (const mpreal& x, const mpreal& y);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator !=	mpfrc++/mpreal.h	/^    friend bool operator != (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const double v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const long double v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const long int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const long long int  u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const unsigned int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const unsigned long int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const unsigned long long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*= (const mpreal& v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const double v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const long double v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const long int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const long long int  u)        {    *this *= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const mpq_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const mpz_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned long long int u){    *this *= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +	mpfrc++/mpreal.h	/^    const mpreal operator+() const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +	mpfrc++/mpreal.h	/^inline const mpreal mpreal::operator+()const    {    return mpreal(*this); }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator ++	mpfrc++/mpreal.h	/^    const mpreal  operator++ (int); $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator ++	mpfrc++/mpreal.h	/^    mpreal& operator++ ();$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator ++	mpfrc++/mpreal.h	/^inline const mpreal mpreal::operator++ (int)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator ++	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator++() $/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const double u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const long double u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const long long int  u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const mpf_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const unsigned int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const unsigned long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const unsigned long long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+= (const double u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+= (const long double u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const long int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const long long int u)         {    *this += mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpf_t u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpq_t u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpreal& v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpz_t u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned long long int u){    *this += mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -	mpfrc++/mpreal.h	/^    const mpreal operator-() const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const double b,            const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const int b,               const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const long int b,          const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const unsigned int b,      const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const unsigned long int b, const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator -	mpfrc++/mpreal.h	/^inline const mpreal mpreal::operator-()const$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator --	mpfrc++/mpreal.h	/^    const mpreal  operator-- (int);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator --	mpfrc++/mpreal.h	/^    mpreal& operator-- ();    $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator --	mpfrc++/mpreal.h	/^inline const mpreal mpreal::operator-- (int)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator --	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator--() $/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const double u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const long double u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const long long int  u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const unsigned int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const unsigned long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const unsigned long long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const double v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const long double v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const long int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const long long int  u)        {    *this -= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpq_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpreal& v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpz_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned long long int u){    *this -= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const double b,            const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const int b,               const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const long int b,          const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const unsigned int b,      const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const unsigned long int b, const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const double v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const long double v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const long int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const long long int  u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const unsigned int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const unsigned long int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const unsigned long long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const double v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long double v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long long int  u)        {    *this \/= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpq_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpreal& v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpz_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned long long int u){    *this \/= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator <	mpfrc++/mpreal.h	/^    friend bool operator <  (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator <<	mpfrc++/mpreal.h	/^    friend std::ostream& operator<<(std::ostream& os, const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator <<=	mpfrc++/mpreal.h	/^    mpreal& operator<<=(const int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator <<=	mpfrc++/mpreal.h	/^    mpreal& operator<<=(const long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator <<=	mpfrc++/mpreal.h	/^    mpreal& operator<<=(const unsigned int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator <<=	mpfrc++/mpreal.h	/^    mpreal& operator<<=(const unsigned long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator <<=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator<<=(const int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator <<=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator<<=(const long int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator <<=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator<<=(const unsigned int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator <<=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator<<=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator <=	mpfrc++/mpreal.h	/^    friend bool operator <= (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const char* s);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const double v);        $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const long double v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const long int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const mpf_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const std::string& s);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const unsigned int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const unsigned long int v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(mpreal&& v);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const char* s)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const double v)                $/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const int v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const long double v)        $/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const long int v)            $/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const mpf_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const mpq_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const mpreal& v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const mpz_t v)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const std::string& s)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned int v)        $/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned long int v)    $/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(mpreal&& other)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const double b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const int b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const long double b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const long int b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const unsigned int b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const unsigned long int b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator >	mpfrc++/mpreal.h	/^    friend bool operator >  (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator >=	mpfrc++/mpreal.h	/^    friend bool operator >= (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator >>	mpfrc++/mpreal.h	/^    friend std::istream& operator>>(std::istream& is, mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::operator >>=	mpfrc++/mpreal.h	/^    mpreal& operator>>=(const int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator >>=	mpfrc++/mpreal.h	/^    mpreal& operator>>=(const long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator >>=	mpfrc++/mpreal.h	/^    mpreal& operator>>=(const unsigned int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator >>=	mpfrc++/mpreal.h	/^    mpreal& operator>>=(const unsigned long int u);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::operator >>=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator>>=(const int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator >>=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator>>=(const long int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator >>=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator>>=(const unsigned int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator >>=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator>>=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::operator bool	mpfrc++/mpreal.h	/^    explicit operator bool               () const { return toBool();       }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator double	mpfrc++/mpreal.h	/^    explicit operator double             () const { return toDouble();     }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator float	mpfrc++/mpreal.h	/^    explicit operator float              () const { return toFloat();      }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator int	mpfrc++/mpreal.h	/^    explicit operator int                () const { return toLong();       }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator long	mpfrc++/mpreal.h	/^    explicit operator long               () const { return toLong();       }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator long double	mpfrc++/mpreal.h	/^    explicit operator long double        () const { return toLDouble();    }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator long long	mpfrc++/mpreal.h	/^    explicit operator long long          () const { return toLLong();      }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator unsigned	mpfrc++/mpreal.h	/^    explicit operator unsigned           () const { return toULong();      }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator unsigned long	mpfrc++/mpreal.h	/^    explicit operator unsigned long      () const { return toULong();      }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::operator unsigned long long	mpfrc++/mpreal.h	/^    explicit operator unsigned long long () const { return toULLong();     }$/;"	f	class:mpfr::mpreal	access:public
mpfr::mpreal::output	mpfrc++/mpreal.h	/^    std::ostream& output(std::ostream& os) const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::output	mpfrc++/mpreal.h	/^inline std::ostream& mpreal::output(std::ostream& os) const $/;"	f	class:mpfr::mpreal
mpfr::mpreal::pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const mpreal& a, const long int b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const mpreal& a, const mpz_t b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const mpreal& a, const unsigned long int b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const unsigned long int a, const mpreal& b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const unsigned long int a, const unsigned long int b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::random	mpfrc++/mpreal.h	/^    friend const mpreal random(unsigned int seed);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::random2	mpfrc++/mpreal.h	/^    friend const mpreal random2 (mp_size_t size, mp_exp_t exp);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::rec_sqrt	mpfrc++/mpreal.h	/^    friend const mpreal rec_sqrt    (const mpreal& v,                       mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::rem	mpfrc++/mpreal.h	/^    friend const mpreal rem (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode); \/\/ Remainder after division$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::remainder	mpfrc++/mpreal.h	/^    friend const mpreal remainder   (         const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::remquo	mpfrc++/mpreal.h	/^    friend const mpreal remquo      (long* q, const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::rint	mpfrc++/mpreal.h	/^    friend const mpreal rint (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::rint_ceil	mpfrc++/mpreal.h	/^    friend const mpreal rint_ceil   (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::rint_floor	mpfrc++/mpreal.h	/^    friend const mpreal rint_floor  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::rint_round	mpfrc++/mpreal.h	/^    friend const mpreal rint_round  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::rint_trunc	mpfrc++/mpreal.h	/^    friend const mpreal rint_trunc  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::root	mpfrc++/mpreal.h	/^    friend const mpreal root(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::round	mpfrc++/mpreal.h	/^    friend const mpreal round(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sec	mpfrc++/mpreal.h	/^    friend const mpreal sec(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sech	mpfrc++/mpreal.h	/^    friend const mpreal sech  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::setInf	mpfrc++/mpreal.h	/^    mpreal&        setInf  (int Sign = +1);    $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::setNan	mpfrc++/mpreal.h	/^    mpreal&        setNan  ();$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::setPrecision	mpfrc++/mpreal.h	/^    inline mpreal&      setPrecision(int Precision, mp_rnd_t RoundingMode = get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::setSign	mpfrc++/mpreal.h	/^    mpreal&        setSign (int Sign, mp_rnd_t RoundingMode = get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::setSign	mpfrc++/mpreal.h	/^inline mpreal& mpreal::setSign(int sign, mp_rnd_t RoundingMode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::setZero	mpfrc++/mpreal.h	/^    mpreal&        setZero (int Sign = +1);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::set_default_prec	mpfrc++/mpreal.h	/^    static void            set_default_prec(mp_prec_t prec);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::set_default_prec	mpfrc++/mpreal.h	/^inline void mpreal::set_default_prec(mp_prec_t prec)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::set_default_rnd	mpfrc++/mpreal.h	/^    static void            set_default_rnd(mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::set_default_rnd	mpfrc++/mpreal.h	/^inline void mpreal::set_default_rnd(mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
mpfr::mpreal::set_emax	mpfrc++/mpreal.h	/^    static int       set_emax (mp_exp_t exp);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::set_emin	mpfrc++/mpreal.h	/^    static int       set_emin (mp_exp_t exp);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::set_exp	mpfrc++/mpreal.h	/^    int set_exp(mp_exp_t e);$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::set_prec	mpfrc++/mpreal.h	/^    inline void         set_prec(mp_prec_t prec, mp_rnd_t rnd_mode = get_default_rnd());    \/\/ Change precision with rounding mode$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::sgn	mpfrc++/mpreal.h	/^    friend int sgn(const mpreal& v); \/\/ returns -1 or +1$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sin	mpfrc++/mpreal.h	/^    friend const mpreal sin(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sin_cos	mpfrc++/mpreal.h	/^    friend int sin_cos(mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sinh	mpfrc++/mpreal.h	/^    friend const mpreal sinh  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sinh_cosh	mpfrc++/mpreal.h	/^    friend int          sinh_cosh   (mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sqr	mpfrc++/mpreal.h	/^    friend const mpreal sqr (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sqrt	mpfrc++/mpreal.h	/^    friend const mpreal sqrt(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::sqrt	mpfrc++/mpreal.h	/^    friend const mpreal sqrt(const unsigned long int v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::subnormalize	mpfrc++/mpreal.h	/^    int subnormalize (int t, mp_rnd_t rnd_mode = get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::sum	mpfrc++/mpreal.h	/^    friend const mpreal sum      (const mpreal tab[], unsigned long int n, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::swap	mpfrc++/mpreal.h	/^    friend void swap(mpreal& x, mpreal& y);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::tan	mpfrc++/mpreal.h	/^    friend const mpreal tan(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::tanh	mpfrc++/mpreal.h	/^    friend const mpreal tanh  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::toBool	mpfrc++/mpreal.h	/^    bool               toBool      (                        )    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toBool	mpfrc++/mpreal.h	/^inline bool               mpreal::toBool   (             )  const    {    return  mpfr_zero_p (mpfr_srcptr()) == 0;     }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toDouble	mpfrc++/mpreal.h	/^    double             toDouble    (mp_rnd_t mode = GMP_RNDN)    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toDouble	mpfrc++/mpreal.h	/^inline double             mpreal::toDouble (mp_rnd_t mode)  const    {    return  mpfr_get_d  (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toFloat	mpfrc++/mpreal.h	/^    float              toFloat     (mp_rnd_t mode = GMP_RNDN)    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toFloat	mpfrc++/mpreal.h	/^inline float              mpreal::toFloat  (mp_rnd_t mode)  const    {    return  mpfr_get_flt(mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toLDouble	mpfrc++/mpreal.h	/^    long double        toLDouble   (mp_rnd_t mode = GMP_RNDN)    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toLDouble	mpfrc++/mpreal.h	/^inline long double        mpreal::toLDouble(mp_rnd_t mode)  const    {    return  mpfr_get_ld (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toLLong	mpfrc++/mpreal.h	/^    long long          toLLong     (mp_rnd_t mode = GMP_RNDZ)    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toLLong	mpfrc++/mpreal.h	/^inline long long          mpreal::toLLong  (mp_rnd_t mode)  const    {    return  mpfr_get_sj (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toLong	mpfrc++/mpreal.h	/^    long               toLong      (mp_rnd_t mode = GMP_RNDZ)    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toLong	mpfrc++/mpreal.h	/^inline long               mpreal::toLong   (mp_rnd_t mode)  const    {    return  mpfr_get_si (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toString	mpfrc++/mpreal.h	/^    std::string toString(const std::string& format) const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toString	mpfrc++/mpreal.h	/^    std::string toString(int n = -1, int b = 10, mp_rnd_t mode = mpreal::get_default_rnd()) const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toString	mpfrc++/mpreal.h	/^inline std::string mpreal::toString(const std::string& format) const$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toString	mpfrc++/mpreal.h	/^inline std::string mpreal::toString(int n, int b, mp_rnd_t mode) const$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toULLong	mpfrc++/mpreal.h	/^    unsigned long long toULLong    (mp_rnd_t mode = GMP_RNDZ)    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toULLong	mpfrc++/mpreal.h	/^inline unsigned long long mpreal::toULLong (mp_rnd_t mode)  const    {    return  mpfr_get_uj (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::toULong	mpfrc++/mpreal.h	/^    unsigned long      toULong     (mp_rnd_t mode = GMP_RNDZ)    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::toULong	mpfrc++/mpreal.h	/^inline unsigned long      mpreal::toULong  (mp_rnd_t mode)  const    {    return  mpfr_get_ui (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
mpfr::mpreal::trunc	mpfrc++/mpreal.h	/^    friend const mpreal trunc(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::urandom	mpfrc++/mpreal.h	/^    friend const mpreal urandom (gmp_randstate_t& state, mp_rnd_t rnd_mode);     \/\/ use gmp_randinit_default() to init state, gmp_randclear() to clear$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::urandomb	mpfrc++/mpreal.h	/^    friend const mpreal urandomb (gmp_randstate_t& state); $/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::zeta	mpfrc++/mpreal.h	/^    friend const mpreal zeta     (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mpfr::mpreal::~mpreal	mpfrc++/mpreal.h	/^    ~mpreal();                           $/;"	p	class:mpfr::mpreal	access:public
mpfr::mpreal::~mpreal	mpfrc++/mpreal.h	/^inline mpreal::~mpreal() $/;"	f	class:mpfr::mpreal
mpfr::mul_2si	mpfrc++/mpreal.h	/^inline const mpreal mul_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::mul_2si	mpfrc++/mpreal.h	/^inline const mpreal mul_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::mul_2ui	mpfrc++/mpreal.h	/^inline const mpreal mul_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::mul_2ui	mpfrc++/mpreal.h	/^inline const mpreal mul_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::nextabove	mpfrc++/mpreal.h	/^inline const mpreal nextabove  (const mpreal& x)$/;"	f	namespace:mpfr
mpfr::nextbelow	mpfrc++/mpreal.h	/^inline const mpreal nextbelow  (const mpreal& x)$/;"	f	namespace:mpfr
mpfr::nexttoward	mpfrc++/mpreal.h	/^inline const mpreal nexttoward (const mpreal& x, const mpreal& y)$/;"	f	namespace:mpfr
mpfr::operator !=	mpfrc++/mpreal.h	/^inline bool operator != (const mpreal& a, const mpreal& b){    return (mpfr_lessgreater_p   (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
mpfr::operator *	mpfrc++/mpreal.h	/^    operator*(const Lhs& lhs, const mpreal& rhs){ return mpreal(rhs) *= lhs;    } $/;"	f	namespace:mpfr
mpfr::operator *	mpfrc++/mpreal.h	/^    operator*(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) *= rhs;    }$/;"	f	namespace:mpfr
mpfr::operator *	mpfrc++/mpreal.h	/^inline const mpreal operator*(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
mpfr::operator +	mpfrc++/mpreal.h	/^    operator+(const Lhs& lhs, const mpreal& rhs){ return mpreal(rhs) += lhs;    } $/;"	f	namespace:mpfr
mpfr::operator +	mpfrc++/mpreal.h	/^    operator+(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) += rhs;    }$/;"	f	namespace:mpfr
mpfr::operator +	mpfrc++/mpreal.h	/^inline const mpreal operator+(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
mpfr::operator -	mpfrc++/mpreal.h	/^    operator-(const Lhs& lhs, const mpreal& rhs){ return mpreal(lhs) -= rhs;    }$/;"	f	namespace:mpfr
mpfr::operator -	mpfrc++/mpreal.h	/^    operator-(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) -= rhs;    }$/;"	f	namespace:mpfr
mpfr::operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const double  b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const int b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const long int b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
mpfr::operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const unsigned int b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const unsigned long int b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator /	mpfrc++/mpreal.h	/^    operator\/(const Lhs& lhs, const mpreal& rhs){ return mpreal(lhs) \/= rhs;    }$/;"	f	namespace:mpfr
mpfr::operator /	mpfrc++/mpreal.h	/^    operator\/(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) \/= rhs;    }$/;"	f	namespace:mpfr
mpfr::operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const double  b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const int b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const long int b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
mpfr::operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const unsigned int b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const unsigned long int b, const mpreal& a)$/;"	f	namespace:mpfr
mpfr::operator <	mpfrc++/mpreal.h	/^inline bool operator <  (const mpreal& a, const mpreal& b){    return (mpfr_less_p          (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
mpfr::operator <<	mpfrc++/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const int k)$/;"	f	namespace:mpfr
mpfr::operator <<	mpfrc++/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const long int k)$/;"	f	namespace:mpfr
mpfr::operator <<	mpfrc++/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const unsigned int k)$/;"	f	namespace:mpfr
mpfr::operator <<	mpfrc++/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const unsigned long int k)$/;"	f	namespace:mpfr
mpfr::operator <<	mpfrc++/mpreal.h	/^inline std::ostream& operator<<(std::ostream& os, const mpreal& v)$/;"	f	namespace:mpfr
mpfr::operator <=	mpfrc++/mpreal.h	/^inline bool operator <= (const mpreal& a, const mpreal& b){    return (mpfr_lessequal_p     (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
mpfr::operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const double b            ){    return (mpfr_cmp_d (a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
mpfr::operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const int b               ){    return (mpfr_cmp_si(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
mpfr::operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const long double b       ){    return (mpfr_cmp_ld(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
mpfr::operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const long int b          ){    return (mpfr_cmp_si(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
mpfr::operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const mpreal& b){    return (mpfr_equal_p         (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
mpfr::operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const unsigned int b      ){    return (mpfr_cmp_ui(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
mpfr::operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const unsigned long int b ){    return (mpfr_cmp_ui(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
mpfr::operator >	mpfrc++/mpreal.h	/^inline bool operator >  (const mpreal& a, const mpreal& b){    return (mpfr_greater_p       (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
mpfr::operator >=	mpfrc++/mpreal.h	/^inline bool operator >= (const mpreal& a, const mpreal& b){    return (mpfr_greaterequal_p  (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
mpfr::operator >>	mpfrc++/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const int k)$/;"	f	namespace:mpfr
mpfr::operator >>	mpfrc++/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const long int k)$/;"	f	namespace:mpfr
mpfr::operator >>	mpfrc++/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const unsigned int k)$/;"	f	namespace:mpfr
mpfr::operator >>	mpfrc++/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const unsigned long int k)$/;"	f	namespace:mpfr
mpfr::operator >>	mpfrc++/mpreal.h	/^inline std::istream& operator>>(std::istream &is, mpreal& v)$/;"	f	namespace:mpfr
mpfr::oss	mpfrc++/mpreal.h	/^    std::ostringstream oss;$/;"	l
mpfr::out	mpfrc++/mpreal.h	/^    std::string out;$/;"	l
mpfr::p1	mpfrc++/mpreal.h	/^    mp_prec_t p1, p2;$/;"	l
mpfr::p2	mpfrc++/mpreal.h	/^    mp_prec_t p1, p2;$/;"	l
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());    $/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()); $/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()); $/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());    $/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const mpreal& a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const mpreal& a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const mpreal& a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const mpreal& a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const mpz_t b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mpfr::prec	mpfrc++/mpreal.h	/^     mpfr_init2(mpfr_ptr(), prec);$/;"	l
mpfr::prec	mpfrc++/mpreal.h	/^    mpfr_init2  (mpfr_ptr(), prec);$/;"	l
mpfr::prec	mpfrc++/mpreal.h	/^    mpfr_init2 (mpfr_ptr(), prec);$/;"	l
mpfr::prec	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(), prec);$/;"	l
mpfr::precision	mpfrc++/mpreal.h	/^        format << '.' << os.precision() << "R*"$/;"	p
mpfr::r	mpfrc++/mpreal.h	/^    int r = mpfr_signbit(op.mpfr_srcptr());$/;"	l
mpfr::random	mpfrc++/mpreal.h	/^inline const mpreal random(unsigned int seed = 0)$/;"	f	namespace:mpfr
mpfr::random2	mpfrc++/mpreal.h	/^inline const mpreal random2 (mp_size_t size, mp_exp_t exp)$/;"	f	namespace:mpfr
mpfr::rec_sqrt	mpfrc++/mpreal.h	/^inline const mpreal rec_sqrt(const mpreal& v, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::rem	mpfrc++/mpreal.h	/^inline const mpreal rem (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::rint	mpfrc++/mpreal.h	/^inline const mpreal rint       (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint      );     }$/;"	f	namespace:mpfr
mpfr::rint_ceil	mpfrc++/mpreal.h	/^inline const mpreal rint_ceil  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_ceil );     }$/;"	f	namespace:mpfr
mpfr::rint_floor	mpfrc++/mpreal.h	/^inline const mpreal rint_floor (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_floor);     }$/;"	f	namespace:mpfr
mpfr::rint_round	mpfrc++/mpreal.h	/^inline const mpreal rint_round (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_round);     }$/;"	f	namespace:mpfr
mpfr::rint_trunc	mpfrc++/mpreal.h	/^inline const mpreal rint_trunc (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_trunc);     }$/;"	f	namespace:mpfr
mpfr::round	mpfrc++/mpreal.h	/^inline const mpreal round(const mpreal& v)$/;"	f	namespace:mpfr
mpfr::s	mpfrc++/mpreal.h	/^    char *s = NULL;$/;"	l
mpfr::s	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s, base, mode); $/;"	l
mpfr::sgn	mpfrc++/mpreal.h	/^    m.setSign(sgn(y)); \/\/ make sure result has the same sign as Y$/;"	p
mpfr::sgn	mpfrc++/mpreal.h	/^inline int sgn(const mpreal& op)$/;"	f	namespace:mpfr
mpfr::sinh_cosh	mpfrc++/mpreal.h	/^inline int sinh_cosh(mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::sizeof	mpfrc++/mpreal.h	/^        std::memcpy(mpfr_ptr(), u, sizeof(mpfr_t));$/;"	p
mpfr::sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const double v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const long double v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const long int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const unsigned int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mpfr::state	mpfrc++/mpreal.h	/^    static gmp_randstate_t state;$/;"	l
mpfr::static_cast	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::static_cast	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::static_cast	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::static_cast	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr::std::mpfr_ptr	mpfrc++/mpreal.h	/^        std::memcpy(mpfr_ptr(), u, sizeof(mpfr_t));$/;"	p	class:mpfr::std
mpfr::std::string	mpfrc++/mpreal.h	/^        os << std::string(s);$/;"	p	class:mpfr::std
mpfr::sum	mpfrc++/mpreal.h	/^inline const mpreal sum (const mpreal tab[], unsigned long int n, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::swap	mpfrc++/mpreal.h	/^inline void         swap (mpreal& a, mpreal& b)            {    mpfr_swap(a.mp,b.mp);   }$/;"	f	namespace:mpfr
mpfr::t	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), t, mpreal::get_default_rnd()); $/;"	l
mpfr::t	mpfrc++/mpreal.h	/^    double t;$/;"	l
mpfr::t	mpfrc++/mpreal.h	/^    mpfr_ptr* t;$/;"	l
mpfr::t	mpfrc++/mpreal.h	/^    mpfr_t t;$/;"	l
mpfr::t	mpfrc++/mpreal.h	/^    oss << f << t;$/;"	l
mpfr::tmp	mpfrc++/mpreal.h	/^    is >> tmp;$/;"	l
mpfr::tmp	mpfrc++/mpreal.h	/^    std::string tmp;$/;"	l
mpfr::toString	mpfrc++/mpreal.h	/^inline std::string toString(T t, std::ios_base & (*f)(std::ios_base&))$/;"	f	namespace:mpfr
mpfr::tp	mpfrc++/mpreal.h	/^		mp_prec_t tp = mpfr_get_prec(  mpfr_srcptr());$/;"	l
mpfr::trunc	mpfrc++/mpreal.h	/^inline const mpreal trunc(const mpreal& v)$/;"	f	namespace:mpfr
mpfr::u	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(), u, mode);$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^	mpfr_set_d(mpfr_ptr(), u, mode);$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^        mpfr_set  (mpfr_ptr(), u, mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^        std::memcpy(mpfr_ptr(), u, sizeof(mpfr_t));$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_add_d(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_add_q(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_add_si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_add_ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_add_z(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(),u,mpreal::get_default_rnd());$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), u, mode);$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), u, mode);$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), u, mode);$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_set_sj(mpfr_ptr(), u, mode); $/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), u, mode);$/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_set_uj(mpfr_ptr(), u, mode); $/;"	l
mpfr::u	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), u, mode);$/;"	l
mpfr::urandom	mpfrc++/mpreal.h	/^inline const mpreal urandom (gmp_randstate_t& state, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
mpfr::urandomb	mpfrc++/mpreal.h	/^inline const mpreal urandomb (gmp_randstate_t& state)$/;"	f	namespace:mpfr
mpfr::v	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_div_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_div_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_div_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_div_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_div_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_mul_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_mul_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_mul_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_mul_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_mul_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_sub_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_sub_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_sub_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_sub_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::v	mpfrc++/mpreal.h	/^    mpfr_sub_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
mpfr::vp	mpfrc++/mpreal.h	/^			mpfr_init2(mpfr_ptr(), vp);$/;"	l
mpfr::vp	mpfrc++/mpreal.h	/^		mp_prec_t vp = mpfr_get_prec(v.mpfr_srcptr());$/;"	l
mpfr::x	mpfrc++/mpreal.h	/^    mpreal x(a);$/;"	p
mpfr::x	mpfrc++/mpreal.h	/^    mpreal x(v);$/;"	p
mpfr::x	mpfrc++/mpreal.h	/^    mpreal x;$/;"	l
mpfr::xp	mpfrc++/mpreal.h	/^    mp_prec_t yp, xp;$/;"	l
mpfr::yp	mpfrc++/mpreal.h	/^    mp_prec_t yp, xp;$/;"	l
mpfr_get_prec	mpfrc++/mpreal.h	/^        mpfr_init2(mpfr_ptr(), mpfr_get_prec(u));$/;"	p
mpfr_get_prec	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(),mpfr_get_prec(u.mpfr_srcptr()));$/;"	p
mpfr_is_initialized	mpfrc++/mpreal.h	/^    #define mpfr_is_initialized(/;"	d
mpfr_ptr	mpfrc++/mpreal.h	/^			clear(mpfr_ptr());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^			mpfr_init2(mpfr_ptr(), vp);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(), u, mode);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^	mpfr_set_d(mpfr_ptr(), u, mode);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^        mpfr_init2(mpfr_ptr(), mpfr_get_prec(u));$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^        mpfr_set  (mpfr_ptr(), u, mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), t, mpreal::get_default_rnd()); $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^        std::memcpy(mpfr_ptr(), u, sizeof(mpfr_t));$/;"	p	class:mpfr::std
mpfr_ptr	mpfrc++/mpreal.h	/^     mpfr_init2(mpfr_ptr(), prec);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    ::mpfr_ptr    mpfr_ptr();$/;"	p	class:mpfr::mpreal	access:public
mpfr_ptr	mpfrc++/mpreal.h	/^    ::mpfr_srcptr mpfr_ptr()    const;$/;"	p	class:mpfr::mpreal	access:public
mpfr_ptr	mpfrc++/mpreal.h	/^    clear(mpfr_ptr());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_d(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_q(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_add_z(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_div_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2  (mpfr_ptr(), prec);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2 (mpfr_ptr(), mpreal::get_default_prec()); $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2 (mpfr_ptr(), prec);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(), prec);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(),(mp_prec_t) mpf_get_prec(u)); \/\/ (gmp: mp_bitcnt_t) unsigned long -> long (mpfr: mp_prec_t)$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(),mpfr_get_prec(u.mpfr_srcptr()));$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_mul_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set  (mpfr_ptr(),u.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), u, mode);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), u, mode);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), u, mode);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_sj(mpfr_ptr(), u, mode); $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s, base, mode); $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode); $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), 0, mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), u, mode);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_uj(mpfr_ptr(), u, mode); $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_uninitialized(mpfr_ptr());     \/\/ make sure "other" holds no pinter to actual data $/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), u, mode);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_setsign(mpfr_ptr(), mpfr_srcptr(), (sign < 0 ? 1 : 0), RoundingMode);$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_sub_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^    mpfr_swap(mpfr_ptr(), other.mpfr_ptr());$/;"	p
mpfr_ptr	mpfrc++/mpreal.h	/^inline ::mpfr_ptr     mpreal::mpfr_ptr()             { return mp; }$/;"	f	class:mpfr::mpreal
mpfr_ptr	mpfrc++/mpreal.h	/^inline ::mpfr_srcptr  mpreal::mpfr_ptr()    const    { return mp; }$/;"	f	class:mpfr::mpreal
mpfr_set_uninitialized	mpfrc++/mpreal.h	/^    #define mpfr_set_uninitialized(/;"	d
mpfr_srcptr	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    ::mpfr_srcptr mpfr_srcptr() const;$/;"	p	class:mpfr::mpreal	access:public
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_d(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_q(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_add_z(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_div_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_mul_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_set  (mpfr_ptr(),u.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_setsign(mpfr_ptr(), mpfr_srcptr(), (sign < 0 ? 1 : 0), RoundingMode);$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub(mpfr_ptr(),mpfr_srcptr(),v.mpfr_srcptr(),mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^    mpfr_sub_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	p
mpfr_srcptr	mpfrc++/mpreal.h	/^inline ::mpfr_srcptr  mpreal::mpfr_srcptr() const    { return mp; }$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^    mpreal();$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const char* s,             mp_prec_t prec = mpreal::get_default_prec(), int base = 10, mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const double u,                 mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const int u,                    mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const long double u,            mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const long int u,               mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const long long int u,          mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpf_t u);    $/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpfr_t  u, bool shared = false);   $/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpq_t u,                  mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());    $/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpreal& u);$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const mpz_t u,                  mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());    $/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const std::string& s,      mp_prec_t prec = mpreal::get_default_prec(), int base = 10, mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const unsigned int u,           mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const unsigned long int u,      mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(const unsigned long long int u, mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^    mpreal(mpreal&& u);$/;"	p	class:mpfr::mpreal	access:public
mpreal	mpfrc++/mpreal.h	/^class mpreal {$/;"	c	namespace:mpfr
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal() $/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const char* s, mp_prec_t prec, int base, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const double u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const long double u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const long long u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpf_t u)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpfr_t  u, bool shared)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpq_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpreal& u) $/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const mpz_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const std::string& s, mp_prec_t prec, int base, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const unsigned int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const unsigned long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(const unsigned long long u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	mpfrc++/mpreal.h	/^inline mpreal::mpreal(mpreal&& other)$/;"	f	class:mpfr::mpreal
mpreal.h	mpfrc++/mpreal.h	1;"	F
mpreal::digits2bits	gwham.cpp	/^  mpreal::set_default_prec(mpfr::digits2bits(MPREAL_PRECISION));$/;"	p	class:mpreal	file:
msg	exception.hpp	/^    string msg;$/;"	m	class:General_Exception	access:protected
mul_2si	mpfrc++/mpreal.h	/^    friend inline const mpreal mul_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mul_2si	mpfrc++/mpreal.h	/^inline const mpreal mul_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mul_2si	mpfrc++/mpreal.h	/^inline const mpreal mul_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mul_2ui	mpfrc++/mpreal.h	/^    friend inline const mpreal mul_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
mul_2ui	mpfrc++/mpreal.h	/^inline const mpreal mul_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
mul_2ui	mpfrc++/mpreal.h	/^inline const mpreal mul_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
myplaceholder	functor.hpp	/^template < size_t i > struct myplaceholder{};$/;"	s
n	gwham.cpp	/^    const histogram::gridval n = stoul(cols[ndim*2]);$/;"	l
n	minimizer/cg.hpp	/^		Int n=pp.size();$/;"	l
n	minimizer/cg.hpp	/^	Int n;$/;"	m	struct:Df1dim	access:public
n	minimizer/cg.hpp	/^	Int n;$/;"	m	struct:Dlinemethod	access:public
naccept	mc.hpp	/^      ulong naccept = 0;$/;"	l
narr	gnarray.hpp	/^    map<Tcoord, Telem> narr;$/;"	m	class:gnarray	access:private
narray	gwham.cpp	/^typedef gnarray<coordtype, valtype, valtype> narray;$/;"	t	file:
narray	mc.hpp	/^typedef gnarray<coordtype, valtype, valtype> narray;$/;"	t
narrayoverlap	gnarray.hpp	/^vector<vector<V> > narrayoverlap(const vector<NARRAY>& hists, const vector<C>& Nsamples) {$/;"	f
narrcit	likelihoodfunc.hpp	/^  typedef typename NARRAY::const_iterator narrcit;$/;"	t	class:LikeliHoodFunc	access:private
narrit	likelihoodfunc.hpp	/^  typedef typename NARRAY::iterator narrit;$/;"	t	class:LikeliHoodFunc	access:private
nbi	gwham.hpp	/^    auto& nbi = ans[i];$/;"	l
nbins	gwham.cpp	/^  const vector<uint> nbins = split<uint>(argv[k++]);$/;"	l
nbins	mc.cpp	/^  vector<uint> nbins, nwins, dimprt;$/;"	l
nbinstr	mc.cpp	/^  const string nbinstr = string(argv[2]); $/;"	l
nc0	gmxmdp.hpp	/^  valtype nc0 = NaN, nc0B = NaN;$/;"	m	class:GMXMDP::GMXPGRP	access:public
nc0B	gmxmdp.hpp	/^  valtype nc0 = NaN, nc0B = NaN;$/;"	m	class:GMXMDP::GMXPGRP	access:public
ncntgrps	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, ncntgrps, nstx*dt);$/;"	l
ncntgrps	gmxmdp.hpp	/^    int ncntgrps = -1;$/;"	m	class:GMXMDP	access:public
ndim	gwham.cpp	/^  const auto ndim = hist.getdim();$/;"	l
ndim	gwham.cpp	/^  const uint ndim = nbins.size();$/;"	l
needpotential	gwham.cpp	/^    const bool needpotential = cmpens(pens)&(1<<Ensemble::DTemperature);$/;"	l
nelms	gnarray.hpp	/^    vector<uint> nelms;$/;"	m	class:gnarray	access:private
nelms_tot	gnarray.hpp	/^    ulong nelms_tot;$/;"	m	class:gnarray	access:private
newE	mc.hpp	/^	const valtype newE = U(newcoord) + V(newcoord);$/;"	l
newIndices	metaprog_snippets.hpp	/^  typedef typename Propagator<Indices, PropagatorArg>::type newIndices;$/;"	t	struct:make_index_seq	access:public
newPropagator	metaprog_snippets.hpp	/^  typedef Propagator<newIndices,newPropagatorArg> newPropagator;$/;"	t	struct:make_index_seq	access:public
newPropagatorArg	metaprog_snippets.hpp	/^  typedef typename Propagator<Indices, PropagatorArg>::seed newPropagatorArg;$/;"	t	struct:make_index_seq	access:public
newTerminator	metaprog_snippets.hpp	/^  typedef Terminator<newIndices,TerminatorArg> newTerminator;$/;"	t	struct:make_index_seq	access:public
newcoord	mc.hpp	/^	vector<valtype> newcoord = coord;$/;"	l
newdecision	metaprog_snippets.hpp	/^  constexpr static bool newdecision = newTerminator::decision;$/;"	m	struct:make_index_seq	access:public
newedge	likelihoodfunc.hpp	/^	    const typename FTree::Edge newedge = {itr->first ,node};$/;"	l
newedge	likelihoodfunc.hpp	/^	Edge newedge = {tail, head};$/;"	l
newelement	metaprog_snippets.hpp	/^  constexpr static size_t newelement = Extract_One_Index<Superset, id1>::value;$/;"	m	struct:Extract_Indices	access:public
newexpf	gwham.hpp	/^  vector<valtype> newexpf(expf);$/;"	p
newnode	likelihoodfunc.hpp	/^      const Node newnode = (it1 == routes.end()) ?  node1 : node2;$/;"	l
newpens	ensemble_factory.hpp	/^    pEnsemble newpens;$/;"	l
nextabove	mpfrc++/mpreal.h	/^    friend const mpreal nextabove  (const mpreal& x);$/;"	p	class:mpfr::mpreal	access:friend
nextabove	mpfrc++/mpreal.h	/^inline const mpreal nextabove  (const mpreal& x)$/;"	f	namespace:mpfr
nextbelow	mpfrc++/mpreal.h	/^    friend const mpreal nextbelow  (const mpreal& x);$/;"	p	class:mpfr::mpreal	access:friend
nextbelow	mpfrc++/mpreal.h	/^inline const mpreal nextbelow  (const mpreal& x)$/;"	f	namespace:mpfr
nexttoward	mpfrc++/mpreal.h	/^    friend const mpreal nexttoward (const mpreal& x, const mpreal& y);$/;"	p	class:mpfr::mpreal	access:friend
nexttoward	mpfrc++/mpreal.h	/^inline const mpreal nexttoward (const mpreal& x, const mpreal& y)$/;"	f	namespace:mpfr
node	likelihoodfunc.hpp	/^	  const auto node = headnode + id;$/;"	l
node	likelihoodfunc.hpp	/^	const auto& node = it->first;$/;"	l
node1	likelihoodfunc.hpp	/^      const auto& node1 = junction[0];$/;"	l
node1	likelihoodfunc.hpp	/^    const Node node1 = headnode + i;$/;"	l
node2	likelihoodfunc.hpp	/^      const auto& node2 = junction[1];$/;"	l
node2	likelihoodfunc.hpp	/^    const Node node2 = headnode + nbnodes[i][0];$/;"	l
nodes	likelihoodfunc.hpp	/^    Nodes nodes;$/;"	m	class:ftree	access:public
nodeset_equal	likelihoodfunc.hpp	/^    bool nodeset_equal(const ThisType& rhs) const {$/;"	f	class:ftree	access:public
nodesize	likelihoodfunc.hpp	/^    inline uint nodesize() const { return nodes.size(); }$/;"	f	class:ftree	access:public
nonzero_diff	mdp.hpp	/^bool nonzero_diff(const vector<T>& op1, const vector<T>& op2) {$/;"	f
npgrps	gmxmdp.cpp	/^      ans.emplace_back(fileio(fstream::in, true, 0, lsx, MAXNLINE, "#@"), "x.xvg", Mask, iNcol, npgrps, nstx*dt);$/;"	l
npgrps	gmxmdp.hpp	/^    int npgrps = -1;$/;"	m	class:GMXMDP	access:public
nrun	gwham.cpp	/^  const uint nrun = atoi(argv[k++]);$/;"	l
nst	timeseries.hpp	/^    const valtype nst = 0;$/;"	m	class:TimeSeries	access:public
nstcv	gmxmdp.cpp	/^  uint nstcv = requirepot ? LCM(uint(nstx), uint(nstenergy)) : nstx; $/;"	l
nstdhdl	gmxmdp.hpp	/^    int nstdhdl = 100;$/;"	m	class:GMXMDP	access:public
nstdhdlcv	gmxmdp.cpp	/^    const uint nstdhdlcv = LCM(uint(nstdhdl), uint(nstcv));$/;"	l
nstenergy	gmxmdp.hpp	/^    int nstenergy = 1000;$/;"	m	class:GMXMDP	access:public
nsteps	mc.cpp	/^  const linecounter nsteps = stoul(argv[6]);$/;"	l
nsteps	mc.hpp	/^    const ulong nsteps;$/;"	m	class:MC	access:private
nstexpanded	gmxmdp.hpp	/^    int nstexpanded = -1;$/;"	m	class:GMXMDP	access:public
nstf	gmxmdp.hpp	/^    int nstf = 1;$/;"	m	class:GMXMDP	access:public
nststates	gwham.cpp	/^    const linecounter nststates = linecounter(prevts->nst * prevts->fio.ls \/ (it->nst * it->fio.ls));$/;"	l
nstx	gmxmdp.hpp	/^    int nstx = 10;$/;"	m	class:GMXMDP	access:public
num	densityofstate.hpp	/^      const auto& num = itC->second;$/;"	v
numeric_limits	mpfrc++/mpreal.h	/^    class numeric_limits<mpfr::mpreal>$/;"	c	namespace:std
nwin	gwham.cpp	/^  const uint nwin = atoi(argv[k++]);$/;"	l
nwins	mc.cpp	/^  vector<uint> nbins, nwins, dimprt;$/;"	l
nwins_tot	mc.cpp	/^  const ulong nwins_tot = windows.getnelms_tot();$/;"	l
nwinsstr	mc.cpp	/^  const string nwinsstr = string(argv[5]); $/;"	l
oNcol	gmxmdp.cpp	/^    ans.emplace_back(fileio(fstream::in, false, 0, lse, MAXNLINE, "#@"), "ener.xvg", Mask, iNcol, oNcol, nstenergy*dt);$/;"	l
oNcol	gmxmdp.cpp	/^    const ulong oNcol = 1;$/;"	l
oNcol	timeseries.hpp	/^    const ulong oNcol = 0;$/;"	m	class:TimeSeries	access:public
oij	gnarray.hpp	/^      const V oij = V(ov)\/(Ni+Nsamples[j]);$/;"	l
oit	gmxmdp.hpp	/^  OIterator oit = key2opt.find(key);$/;"	l
ok1	minimizer/cg.hpp	/^		Bool ok1,ok2;$/;"	l
ok2	minimizer/cg.hpp	/^		Bool ok1,ok2;$/;"	l
olde	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
oldpens	ensemble_factory.hpp	/^	  const auto& oldpens = ens[j];$/;"	l
open	fileio.cpp	/^  fs.open(fname.c_str(),iomode);$/;"	p	file:
operator !=	ensemble.cpp	/^bool Ensemble::operator!=(const Ensemble& src) const {$/;"	f	class:Ensemble
operator !=	ensemble.hpp	/^    virtual bool operator!=(const Ensemble& src) const;$/;"	p	class:Ensemble	access:public
operator !=	functor.hpp	/^    bool operator!=(const ThisType& rhs) const { return !((*this)==rhs); }$/;"	f	class:Functor	access:public
operator !=	hamiltonian.cpp	/^bool Hamiltonian::operator!=(const Hamiltonian& src) const {$/;"	f	class:Hamiltonian
operator !=	hamiltonian.hpp	/^    bool operator!=(const Hamiltonian& src) const;$/;"	p	class:Hamiltonian	access:public
operator !=	mpfrc++/mpreal.h	/^    friend bool operator != (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
operator !=	mpfrc++/mpreal.h	/^inline bool operator != (const mpreal& a, const mpreal& b){    return (mpfr_lessgreater_p   (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
operator ()	densityofstate.hpp	/^    void operator() ($/;"	f	class:DensityOfState	access:public
operator ()	functor.hpp	/^    Output operator()(Arg... arg) const { return funct(forward<Arg...>(arg...)); };$/;"	f	class:Functor	access:public
operator ()	likelihoodfunc.hpp	/^    valtype operator() (const vector<valtype>& deltaf) {$/;"	f	class:LikeliHoodFunc	access:public
operator ()	mc.hpp	/^    valtype operator() (const vector <valtype>& init_coord, histogram& hist) const {$/;"	f	class:MC	access:public
operator ()	mc.hpp	/^    valtype operator() (const vector<valtype>& coord) const {$/;"	f	class:harmonic	access:public
operator ()	mc.hpp	/^    valtype operator() (const vector<valtype>& coord) const {$/;"	f	class:potpoly_dblwell	access:public
operator ()	minimizer/cg.hpp	/^	Doub operator()(const Doub x)$/;"	f	struct:Df1dim	access:public
operator ()	timeseries.hpp	/^    linecounter operator()(const string& fname, const DATAPROCESSOR& dproc) {$/;"	f	class:TimeSeries	access:public
operator *	mpfrc++/mpreal.h	/^    operator*(const Lhs& lhs, const mpreal& rhs){ return mpreal(rhs) *= lhs;    } $/;"	f	namespace:mpfr
operator *	mpfrc++/mpreal.h	/^    operator*(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) *= rhs;    }$/;"	f	namespace:mpfr
operator *	mpfrc++/mpreal.h	/^inline const mpreal operator*(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const double v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const int v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const long double v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const long int v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const long long int  u);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const unsigned int v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const unsigned long int v);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^    mpreal& operator*=(const unsigned long long int u);$/;"	p	class:mpfr::mpreal	access:public
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*= (const mpreal& v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const double v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const int v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const long double v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const long int v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const long long int  u)        {    *this *= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator *=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned long long int u){    *this *= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator +	mpfrc++/mpreal.h	/^    const mpreal operator+() const;$/;"	p	class:mpfr::mpreal	access:public
operator +	mpfrc++/mpreal.h	/^    operator+(const Lhs& lhs, const mpreal& rhs){ return mpreal(rhs) += lhs;    } $/;"	f	namespace:mpfr
operator +	mpfrc++/mpreal.h	/^    operator+(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) += rhs;    }$/;"	f	namespace:mpfr
operator +	mpfrc++/mpreal.h	/^inline const mpreal mpreal::operator+()const    {    return mpreal(*this); }$/;"	f	class:mpfr::mpreal
operator +	mpfrc++/mpreal.h	/^inline const mpreal operator+(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator ++	mpfrc++/mpreal.h	/^    const mpreal  operator++ (int); $/;"	p	class:mpfr::mpreal	access:public
operator ++	mpfrc++/mpreal.h	/^    mpreal& operator++ ();$/;"	p	class:mpfr::mpreal	access:public
operator ++	mpfrc++/mpreal.h	/^inline const mpreal mpreal::operator++ (int)$/;"	f	class:mpfr::mpreal
operator ++	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator++() $/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const double u);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const int u);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const long double u);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const long int u);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const long long int  u);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const mpf_t v);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const unsigned int u);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const unsigned long int u);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^    mpreal& operator+=(const unsigned long long int u);$/;"	p	class:mpfr::mpreal	access:public
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+= (const double u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+= (const long double u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const int u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const long int u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const long long int u)         {    *this += mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpf_t u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpq_t u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpz_t u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator +=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned long long int u){    *this += mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator -	mpfrc++/mpreal.h	/^    const mpreal operator-() const;$/;"	p	class:mpfr::mpreal	access:public
operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const double b,            const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const int b,               const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const long int b,          const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const unsigned int b,      const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator -	mpfrc++/mpreal.h	/^    friend const mpreal operator-(const unsigned long int b, const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator -	mpfrc++/mpreal.h	/^    operator-(const Lhs& lhs, const mpreal& rhs){ return mpreal(lhs) -= rhs;    }$/;"	f	namespace:mpfr
operator -	mpfrc++/mpreal.h	/^    operator-(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) -= rhs;    }$/;"	f	namespace:mpfr
operator -	mpfrc++/mpreal.h	/^inline const mpreal mpreal::operator-()const$/;"	f	class:mpfr::mpreal
operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const double  b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const unsigned int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	mpfrc++/mpreal.h	/^inline const mpreal operator-(const unsigned long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator --	mpfrc++/mpreal.h	/^    const mpreal  operator-- (int);$/;"	p	class:mpfr::mpreal	access:public
operator --	mpfrc++/mpreal.h	/^    mpreal& operator-- ();    $/;"	p	class:mpfr::mpreal	access:public
operator --	mpfrc++/mpreal.h	/^inline const mpreal mpreal::operator-- (int)$/;"	f	class:mpfr::mpreal
operator --	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator--() $/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const double u);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const int u);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const long double u);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const long int u);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const long long int  u);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const unsigned int u);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const unsigned long int u);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^    mpreal& operator-=(const unsigned long long int u);$/;"	p	class:mpfr::mpreal	access:public
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const double v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const int v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const long double v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const long int v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const long long int  u)        {    *this -= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator -=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned long long int u){    *this -= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const double b,            const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const int b,               const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const long int b,          const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const unsigned int b,      const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator /	mpfrc++/mpreal.h	/^    friend const mpreal operator\/(const unsigned long int b, const mpreal& a);$/;"	p	class:mpfr::mpreal	access:friend
operator /	mpfrc++/mpreal.h	/^    operator\/(const Lhs& lhs, const mpreal& rhs){ return mpreal(lhs) \/= rhs;    }$/;"	f	namespace:mpfr
operator /	mpfrc++/mpreal.h	/^    operator\/(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) \/= rhs;    }$/;"	f	namespace:mpfr
operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const double  b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const unsigned int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	mpfrc++/mpreal.h	/^inline const mpreal operator\/(const unsigned long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const double v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const int v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const long double v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const long int v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const long long int  u);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const unsigned int v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const unsigned long int v);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^    mpreal& operator\/=(const unsigned long long int u);$/;"	p	class:mpfr::mpreal	access:public
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const double v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const int v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long double v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long int v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long long int  u)        {    *this \/= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator /=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned long long int u){    *this \/= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator <	mpfrc++/mpreal.h	/^    friend bool operator <  (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
operator <	mpfrc++/mpreal.h	/^inline bool operator <  (const mpreal& a, const mpreal& b){    return (mpfr_less_p          (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
operator <<	metaprog_snippets.hpp	/^    ThisType& operator<< (const std::string& input) {$/;"	f	class:FormatStream	access:public
operator <<	metaprog_snippets.hpp	/^    operator<< (const T& input) {$/;"	f	class:FormatStream	access:public
operator <<	mpfrc++/mpreal.h	/^    friend std::ostream& operator<<(std::ostream& os, const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
operator <<	mpfrc++/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const int k)$/;"	f	namespace:mpfr
operator <<	mpfrc++/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const long int k)$/;"	f	namespace:mpfr
operator <<	mpfrc++/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const unsigned int k)$/;"	f	namespace:mpfr
operator <<	mpfrc++/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const unsigned long int k)$/;"	f	namespace:mpfr
operator <<	mpfrc++/mpreal.h	/^inline std::ostream& operator<<(std::ostream& os, const mpreal& v)$/;"	f	namespace:mpfr
operator <<=	mpfrc++/mpreal.h	/^    mpreal& operator<<=(const int u);$/;"	p	class:mpfr::mpreal	access:public
operator <<=	mpfrc++/mpreal.h	/^    mpreal& operator<<=(const long int u);$/;"	p	class:mpfr::mpreal	access:public
operator <<=	mpfrc++/mpreal.h	/^    mpreal& operator<<=(const unsigned int u);$/;"	p	class:mpfr::mpreal	access:public
operator <<=	mpfrc++/mpreal.h	/^    mpreal& operator<<=(const unsigned long int u);$/;"	p	class:mpfr::mpreal	access:public
operator <<=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator<<=(const int u)$/;"	f	class:mpfr::mpreal
operator <<=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator<<=(const long int u)$/;"	f	class:mpfr::mpreal
operator <<=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator<<=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator <<=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator<<=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator <=	mpfrc++/mpreal.h	/^    friend bool operator <= (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
operator <=	mpfrc++/mpreal.h	/^inline bool operator <= (const mpreal& a, const mpreal& b){    return (mpfr_lessequal_p     (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
operator =	gmxmdp.hpp	/^  GMXPGRP& operator=(const GMXPGRP& src) {$/;"	f	class:GMXMDP::GMXPGRP	access:public
operator =	gnarray.hpp	/^    gnarray operator=(const gnarray<Tcoord,Telem,Tval>& rhs);$/;"	p	class:gnarray	access:public
operator =	gnarray.hpp	/^gnarray<Tcoord,Telem,Tval> gnarray<Tcoord,Telem,Tval>::operator=(const gnarray<Tcoord,Telem,Tval>& rhs) {$/;"	f	class:gnarray
operator =	hamiltonian.cpp	/^Hamiltonian& Hamiltonian::operator=(const Hamiltonian& src) {$/;"	f	class:Hamiltonian
operator =	hamiltonian.hpp	/^    Hamiltonian& operator=(const Hamiltonian& src);$/;"	p	class:Hamiltonian	access:public
operator =	mdp.hpp	/^    MDP& operator=(const MDP& src) {$/;"	f	class:MDP	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const char* s);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const double v);        $/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const int v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const long double v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const long int v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const mpf_t v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const mpq_t v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const mpz_t v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const std::string& s);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const unsigned int v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(const unsigned long int v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^    mpreal& operator=(mpreal&& v);$/;"	p	class:mpfr::mpreal	access:public
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const char* s)$/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const double v)                $/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const int v)$/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const long double v)        $/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const long int v)            $/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const mpf_t v)$/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const std::string& s)$/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned int v)        $/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned long int v)    $/;"	f	class:mpfr::mpreal
operator =	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator=(mpreal&& other)$/;"	f	class:mpfr::mpreal
operator ==	ensemble.cpp	/^bool Ensemble::operator==(const Ensemble& src) const {$/;"	f	class:Ensemble
operator ==	ensemble.hpp	/^    virtual bool operator==(const Ensemble& src) const;$/;"	p	class:Ensemble	access:public
operator ==	functor.hpp	/^    bool operator==(const ThisType& rhs) const { return this == &rhs || (this->params == rhs.getParams() && this->pobj == rhs.getpobj()); }$/;"	f	class:Functor	access:public
operator ==	hamiltonian.cpp	/^bool Hamiltonian::operator==(const Hamiltonian& src) const {$/;"	f	class:Hamiltonian
operator ==	hamiltonian.hpp	/^    bool operator==(const Hamiltonian& src) const;$/;"	p	class:Hamiltonian	access:public
operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const double b);$/;"	p	class:mpfr::mpreal	access:friend
operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const int b);$/;"	p	class:mpfr::mpreal	access:friend
operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const long double b);$/;"	p	class:mpfr::mpreal	access:friend
operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const long int b);$/;"	p	class:mpfr::mpreal	access:friend
operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const unsigned int b);$/;"	p	class:mpfr::mpreal	access:friend
operator ==	mpfrc++/mpreal.h	/^    friend bool operator == (const mpreal& a, const unsigned long int b);$/;"	p	class:mpfr::mpreal	access:friend
operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const double b            ){    return (mpfr_cmp_d (a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const int b               ){    return (mpfr_cmp_si(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const long double b       ){    return (mpfr_cmp_ld(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const long int b          ){    return (mpfr_cmp_si(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const mpreal& b){    return (mpfr_equal_p         (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const unsigned int b      ){    return (mpfr_cmp_ui(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
operator ==	mpfrc++/mpreal.h	/^inline bool operator == (const mpreal& a, const unsigned long int b ){    return (mpfr_cmp_ui(a.mpfr_srcptr(),b) == 0 );    }$/;"	f	namespace:mpfr
operator >	mpfrc++/mpreal.h	/^    friend bool operator >  (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
operator >	mpfrc++/mpreal.h	/^inline bool operator >  (const mpreal& a, const mpreal& b){    return (mpfr_greater_p       (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
operator >=	mpfrc++/mpreal.h	/^    friend bool operator >= (const mpreal& a, const mpreal& b);$/;"	p	class:mpfr::mpreal	access:friend
operator >=	mpfrc++/mpreal.h	/^inline bool operator >= (const mpreal& a, const mpreal& b){    return (mpfr_greaterequal_p  (a.mpfr_srcptr(),b.mpfr_srcptr()) !=0 );    }$/;"	f	namespace:mpfr
operator >>	mpfrc++/mpreal.h	/^    friend std::istream& operator>>(std::istream& is, mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
operator >>	mpfrc++/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const int k)$/;"	f	namespace:mpfr
operator >>	mpfrc++/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const long int k)$/;"	f	namespace:mpfr
operator >>	mpfrc++/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const unsigned int k)$/;"	f	namespace:mpfr
operator >>	mpfrc++/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const unsigned long int k)$/;"	f	namespace:mpfr
operator >>	mpfrc++/mpreal.h	/^inline std::istream& operator>>(std::istream &is, mpreal& v)$/;"	f	namespace:mpfr
operator >>=	mpfrc++/mpreal.h	/^    mpreal& operator>>=(const int u);$/;"	p	class:mpfr::mpreal	access:public
operator >>=	mpfrc++/mpreal.h	/^    mpreal& operator>>=(const long int u);$/;"	p	class:mpfr::mpreal	access:public
operator >>=	mpfrc++/mpreal.h	/^    mpreal& operator>>=(const unsigned int u);$/;"	p	class:mpfr::mpreal	access:public
operator >>=	mpfrc++/mpreal.h	/^    mpreal& operator>>=(const unsigned long int u);$/;"	p	class:mpfr::mpreal	access:public
operator >>=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator>>=(const int u)$/;"	f	class:mpfr::mpreal
operator >>=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator>>=(const long int u)$/;"	f	class:mpfr::mpreal
operator >>=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator>>=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator >>=	mpfrc++/mpreal.h	/^inline mpreal& mpreal::operator>>=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator []	densityofstate.hpp	/^    valtype operator[](const coordtype& coord) const { return DOS[coord]; };$/;"	f	class:DensityOfState	access:public
operator []	densityofstate.hpp	/^    valtype& operator[](const coordtype& coord) { return DOS[coord]; };$/;"	f	class:DensityOfState	access:public
operator []	gnarray.hpp	/^    Telem operator[](const Tcoord& coord) const {$/;"	f	class:gnarray	access:public
operator []	gnarray.hpp	/^    Telem& operator[](const Tcoord& coord) { return narr[coord]; }$/;"	f	class:gnarray	access:public
operator bool	mpfrc++/mpreal.h	/^    explicit operator bool               () const { return toBool();       }$/;"	f	class:mpfr::mpreal	access:public
operator double	mpfrc++/mpreal.h	/^    explicit operator double             () const { return toDouble();     }$/;"	f	class:mpfr::mpreal	access:public
operator float	mpfrc++/mpreal.h	/^    explicit operator float              () const { return toFloat();      }$/;"	f	class:mpfr::mpreal	access:public
operator int	mpfrc++/mpreal.h	/^    explicit operator int                () const { return toLong();       }$/;"	f	class:mpfr::mpreal	access:public
operator long	mpfrc++/mpreal.h	/^    explicit operator long               () const { return toLong();       }$/;"	f	class:mpfr::mpreal	access:public
operator long double	mpfrc++/mpreal.h	/^    explicit operator long double        () const { return toLDouble();    }$/;"	f	class:mpfr::mpreal	access:public
operator long long	mpfrc++/mpreal.h	/^    explicit operator long long          () const { return toLLong();      }$/;"	f	class:mpfr::mpreal	access:public
operator unsigned	mpfrc++/mpreal.h	/^    explicit operator unsigned           () const { return toULong();      }$/;"	f	class:mpfr::mpreal	access:public
operator unsigned long	mpfrc++/mpreal.h	/^    explicit operator unsigned long      () const { return toULong();      }$/;"	f	class:mpfr::mpreal	access:public
operator unsigned long long	mpfrc++/mpreal.h	/^    explicit operator unsigned long long () const { return toULLong();     }$/;"	f	class:mpfr::mpreal	access:public
optdata	gmxmdp.hpp	/^  T& optdata = oit->second.get();$/;"	l
oss	mpfrc++/mpreal.h	/^    std::ostringstream oss;$/;"	l
out	mpfrc++/mpreal.h	/^    std::string out;$/;"	l
out	timeseries.hpp	/^      vector<INPUT> out(colids.size(),INPUT{0});$/;"	p
output	mpfrc++/mpreal.h	/^    std::ostream& output(std::ostream& os) const;$/;"	p	class:mpfr::mpreal	access:public
output	mpfrc++/mpreal.h	/^inline std::ostream& mpreal::output(std::ostream& os) const $/;"	f	class:mpfr::mpreal
ov	gnarray.hpp	/^      const auto ov = hi.overlap(hists[j]);$/;"	l
overlap	gnarray.hpp	/^    Telem overlap(const ThisType& rhs) const;$/;"	p	class:gnarray	access:public
overlap	gnarray.hpp	/^  vector<vector<V> > overlap(hists.size(), vector<V>(hists.size(), 0));$/;"	p
overlap	gnarray.hpp	/^Telem gnarray<Tcoord,Telem,Tval>::overlap(const ThisType& rhs) const {$/;"	f	class:gnarray
overlap	gwham.cpp	/^  const auto overlap = narrayoverlap<valtype, histcounter, histogram>(hists, Nsamples);$/;"	l
overlap	gwham.hpp	/^     const vector<vector<valtype> >* const overlap;$/;"	m	class:WHAM	access:private
overlap	mc.cpp	/^  const auto overlap = narrayoverlap<valtype, histcounter, histogram>(hists, Nsamples);$/;"	l
p	minimizer/cg.hpp	/^	VecDoub p;$/;"	m	struct:Dlinemethod	access:public
p	minimizer/cg.hpp	/^	const VecDoub &p;$/;"	m	struct:Df1dim	access:public
p1	mpfrc++/mpreal.h	/^    mp_prec_t p1, p2;$/;"	l
p2	mpfrc++/mpreal.h	/^    mp_prec_t p1, p2;$/;"	l
pE0	gwham.cpp	/^    const auto pE0 = pE0s[iens];$/;"	l
pE0s	gwham.cpp	/^  auto pE0s = MDP2Ensemble(pmdp0s, pmdp2ipens0, 1);$/;"	l
pEnsemble	typedefs.hpp	/^typedef shared_ptr<Ensemble> pEnsemble;$/;"	t
pMDP	typedefs.hpp	/^typedef shared_ptr<MDP> pMDP;$/;"	t
pNPT	typedefs.hpp	/^typedef shared_ptr<NPT> pNPT;$/;"	t
pNVE	typedefs.hpp	/^typedef shared_ptr<NVE> pNVE;$/;"	t
pNVT	typedefs.hpp	/^typedef shared_ptr<NVT> pNVT;$/;"	t
packages.tex	doc/tex/packages.tex	1;"	F
params	functor.hpp	/^    Tp params;$/;"	m	class:Functor	access:protected
params	mc.cpp	/^  vector<valtype> params;$/;"	l
params	mc.hpp	/^    const vector<valtype> params;$/;"	m	class:potpoly_dblwell	access:private
partitionfunct	mc.hpp	/^    valtype partitionfunct(const valtype& kB, const valtype& T, const vector<uint>& Npts, const vector<valtype>& hv, const vector<valtype>& lv) const {$/;"	f	class:potpoly_dblwell	access:public
pch	fileio_utils.cpp	/^  char * pch = strtok(str_c, delims.c_str());$/;"	l
pens	gwham.cpp	/^  const auto pens = MDP2Ensemble(pmdps, pmdp2ipens, 1);$/;"	l
pgrp	gmxmdp.cpp	/^    const GMXPGRP& pgrp = *i;$/;"	l
pgrprst	gmxmdp.cpp	/^      const auto& pgrprst = pgrp.rstfuncts;$/;"	l
pgrps	gmxmdp.hpp	/^    vector<GMXPGRP> pgrps;$/;"	m	class:GMXMDP	access:public
pmdp0s	gwham.cpp	/^  const vector<pMDP> pmdp0s = CreateMDPs(mdp0prefixes, mdpsuffixes, suffix2MDP);$/;"	l
pmdp2ipens	gwham.cpp	/^  multimap<pMDP, uint> pmdp2ipens;$/;"	l
pmdp2ipens0	gwham.cpp	/^  multimap<pMDP, uint> pmdp2ipens0;$/;"	l
pmdps	gwham.cpp	/^  const vector<pMDP> pmdps = CreateMDPs(fnprefixes, mdpsuffixes, suffix2MDP);$/;"	l
pmf	gwham.cpp	/^      const valtype pmf = -kB*T*log(it->second\/itmax->second);$/;"	l
pmf	gwham.cpp	/^      fcout << val << pmf;$/;"	l
pmf	mc.cpp	/^    const valtype pmf = -kB*T*log(it->second\/itmax->second);$/;"	l
pmf	mc.cpp	/^    fcout << val << pmf;$/;"	l
pmf_analytic	mc.cpp	/^    const valtype pmf_analytic = potprt(val);$/;"	l
pobj	functor.hpp	/^    cpTo pobj;$/;"	m	class:Functor	access:protected
pobj	functor.hpp	/^auto Make_Functor ( Output (T::*const f)(Input...), T* pobj, Params&&... params ) $/;"	v
port	likelihoodfunc.hpp	/^          const auto& port = ports[i];$/;"	l
port	likelihoodfunc.hpp	/^      auto& port = ports[hubid];$/;"	l
ports	likelihoodfunc.hpp	/^        const auto& ports = tree.getports();$/;"	l
ports	likelihoodfunc.hpp	/^    vector<Nodes> ports;$/;"	m	class:ftree	access:public
pos	fileio.hpp	/^      auto pos = fs.tellg(); $/;"	l
pot	gwham.cpp	/^      vector<valtype> pot;$/;"	l
pot	gwham.cpp	/^  const auto& pot = *itpot;$/;"	l
pot	mc.cpp	/^  const potpoly_dblwell pot(dim,params);$/;"	p	file:
potentials	hamiltonian.hpp	/^    vFunctVV potentials;$/;"	m	class:Hamiltonian	access:private
potpoly_dblwell	mc.hpp	/^    potpoly_dblwell(const uint& _dim, const vector<valtype>& _params) : $/;"	f	class:potpoly_dblwell	access:public
potpoly_dblwell	mc.hpp	/^class potpoly_dblwell {$/;"	c
potpoly_dblwell::Npts_tot	mc.hpp	/^      ulong Npts_tot = 1;$/;"	l
potpoly_dblwell::ans	mc.hpp	/^      valtype ans = 0.0;$/;"	l
potpoly_dblwell::beta	mc.hpp	/^      const valtype beta = 1\/(kB*T);$/;"	l
potpoly_dblwell::coord	mc.hpp	/^	vector<valtype> coord;$/;"	l
potpoly_dblwell::coord2	mc.hpp	/^	const valtype coord2 = coord[i]*coord[i];$/;"	l
potpoly_dblwell::dim	mc.hpp	/^    const uint dim;$/;"	m	class:potpoly_dblwell	access:private
potpoly_dblwell::dx	mc.hpp	/^      vector<valtype> dx(dim,0.0);$/;"	p
potpoly_dblwell::dx_tot	mc.hpp	/^      valtype dx_tot = 1.0;$/;"	l
potpoly_dblwell::fx	mc.hpp	/^	const valtype fx = this->operator()(coord);$/;"	l
potpoly_dblwell::getdim	mc.hpp	/^    uint getdim() const { return dim;};$/;"	f	class:potpoly_dblwell	access:public
potpoly_dblwell::index	mc.hpp	/^	  const uint index = int( ( i%stride_array[j] ) \/ stride_array[j+1] );$/;"	l
potpoly_dblwell::intgl	mc.hpp	/^      valtype intgl = 0.0;$/;"	l
potpoly_dblwell::operator ()	mc.hpp	/^    valtype operator() (const vector<valtype>& coord) const {$/;"	f	class:potpoly_dblwell	access:public
potpoly_dblwell::params	mc.hpp	/^    const vector<valtype> params;$/;"	m	class:potpoly_dblwell	access:private
potpoly_dblwell::partitionfunct	mc.hpp	/^    valtype partitionfunct(const valtype& kB, const valtype& T, const vector<uint>& Npts, const vector<valtype>& hv, const vector<valtype>& lv) const {$/;"	f	class:potpoly_dblwell	access:public
potpoly_dblwell::potpoly_dblwell	mc.hpp	/^    potpoly_dblwell(const uint& _dim, const vector<valtype>& _params) : $/;"	f	class:potpoly_dblwell	access:public
potpoly_dblwell::setstride	mc.hpp	/^    void setstride(const vector<uint>& Npts, vector<uint>& stride_array) const {$/;"	f	class:potpoly_dblwell	access:private
potprt	mc.cpp	/^  const potpoly_dblwell potprt(dimprt.size(),params);$/;"	p	file:
pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const mpreal& a, const long int b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const mpreal& a, const mpz_t b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const mpreal& a, const unsigned long int b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const unsigned long int a, const mpreal& b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
pow	mpfrc++/mpreal.h	/^    friend const mpreal pow (const unsigned long int a, const unsigned long int b, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());    $/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const double a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()); $/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()); $/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());    $/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long double a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const long int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const mpreal& a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const mpreal& a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const mpreal& a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const mpreal& a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^const mpreal pow(const unsigned long int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const double a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long double a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const long int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const mpz_t b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const mpreal& a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	mpfrc++/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
praw	gwham.hpp	/^    const valtype praw = it->second\/sum;$/;"	l
prec	metaprog_snippets.hpp	/^    uint prec;$/;"	m	class:FormatStream	access:private
prec	mpfrc++/mpreal.h	/^     mpfr_init2(mpfr_ptr(), prec);$/;"	l
prec	mpfrc++/mpreal.h	/^    mpfr_init2  (mpfr_ptr(), prec);$/;"	l
prec	mpfrc++/mpreal.h	/^    mpfr_init2 (mpfr_ptr(), prec);$/;"	l
prec	mpfrc++/mpreal.h	/^    mpfr_init2(mpfr_ptr(), prec);$/;"	l
precision	metaprog_snippets.hpp	/^      stream.precision(prec);$/;"	p
precision	metaprog_snippets.hpp	/^    void precision(const uint _precision) { prec = _precision; }$/;"	f	class:FormatStream	access:public
precision	minimizer/cg.hpp	/^			  cout.precision(VALMAXDIGITS10); $/;"	p
precision	minimizer/cg.hpp	/^			  cout.precision(VALMAXDIGITS10);$/;"	p
precision	mpfrc++/mpreal.h	/^        format << '.' << os.precision() << "R*"$/;"	p
prepend	exception.hpp	/^    void prepend(const string& addmsg) { msg = addmsg + msg; }$/;"	f	class:General_Exception	access:public
prevts	gwham.cpp	/^    auto prevts = it;$/;"	l
print	densityofstate.hpp	/^    void print() const { DOS.print(); }$/;"	f	class:DensityOfState	access:public
print	densityofstate.hpp	/^    void print() const { DOS.print(); }$/;"	p
print	gmxmdp.cpp	/^void GMXMDP::print() const {$/;"	f	class:GMXMDP
print	gmxmdp.hpp	/^    virtual void print() const; $/;"	p	class:GMXMDP	access:public
print	gnarray.hpp	/^    void print() const;$/;"	p	class:gnarray	access:public
print	gnarray.hpp	/^    void print(const Telem& norm) const;$/;"	p	class:gnarray	access:public
print	gnarray.hpp	/^void gnarray<Tcoord,Telem,Tval>::print() const {$/;"	f	class:gnarray
print	gnarray.hpp	/^void gnarray<Tcoord,Telem,Tval>::print(const Telem& norm) const {$/;"	f	class:gnarray
print	gwham.cpp	/^    pmdp->print();$/;"	p	file:
print	gwham.cpp	/^  for(const auto& h : hists) h.print();$/;"	p	file:
print	mc.cpp	/^  dpmf_hist.print();$/;"	p	file:
print	mdp.hpp	/^    virtual void print() const = 0; $/;"	p	class:MDP	access:public
printMDPopt	gmxmdp.hpp	/^printMDPopt(const map<string, reference_wrapper<T>>& key2opt) {$/;"	f
printfree	gwham.hpp	/^    void printfree() const;$/;"	p	class:WHAM	access:public
printfree	gwham.hpp	/^void WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::printfree() const {$/;"	f	class:WHAM
pullT	gmxmdp.hpp	/^    } pullT = NPullTypes;$/;"	m	class:GMXMDP	typeref:enum:GMXMDP::PullType	access:public
pullTstr	gmxmdp.hpp	/^    string pullTstr = "pullTstr";$/;"	m	class:GMXMDP	access:public
push_back	fileio.cpp	/^    lines.push_back(line);$/;"	p	file:
push_back	fileio_utils.cpp	/^    output.push_back(iss.str());$/;"	p	file:
push_back	fileio_utils.hpp	/^    output.push_back(tmp[0]);$/;"	p
push_back	gmxmdp.cpp	/^  for(uint i = 0; i < 3; ++i) { if(dim & (i << 1)) { bits.push_back(i); } }$/;"	p	file:
push_back	gnarray.hpp	/^    binsize.push_back(_gnarr.getbinsize()[dimindex]);$/;"	p
push_back	gnarray.hpp	/^    coord.push_back(uint((vals[i]-lv[i])\/binsize[i]));$/;"	p
push_back	gnarray.hpp	/^    hv.push_back(_gnarr.gethv()[dimindex]);$/;"	p
push_back	gnarray.hpp	/^    lv.push_back(_gnarr.getlv()[dimindex]);$/;"	p
push_back	gnarray.hpp	/^    nelms.push_back(_gnarr.getnelms()[dimindex]);$/;"	p
push_back	gnarray.hpp	/^    vals.push_back(val);$/;"	p
push_back	gwham.cpp	/^      record[coord].push_back(i);$/;"	p	file:
push_back	gwham.cpp	/^  data.push_back(pot);$/;"	p	file:
push_back	gwham.hpp	/^      rhocoord.push_back(coord[_dim[i]]);$/;"	p
push_back	likelihoodfunc.hpp	/^	it->second.push_back(edgeid);$/;"	p
push_back	likelihoodfunc.hpp	/^      if(it != joints.end()) { it->second.push_back(edgeid); }$/;"	p
push_back	mc.cpp	/^      record[coord].push_back(i);$/;"	p	file:
pwham	gwham.hpp	/^    const valtype pwham = Qinv * exp(-Vi->ener(vals)) * rho[coord];$/;"	l
q	minimizer/cg.hpp	/^			Doub q=(bx-cx)*(fb-fa);$/;"	l
quiet_NaN	mpfrc++/mpreal.h	/^        inline static const mpfr::mpreal quiet_NaN()        { return mpfr::mpreal().setNan();    }$/;"	f	class:std::numeric_limits	access:public
r	mc.hpp	/^    const vector<valtype> r;$/;"	m	class:harmonic	access:private
r	minimizer/cg.hpp	/^			Doub r=(bx-ax)*(fb-fc);$/;"	l
r	mpfrc++/mpreal.h	/^            mp_rnd_t r = mpfr::mpreal::get_default_rnd();$/;"	l
r	mpfrc++/mpreal.h	/^    int r = mpfr_signbit(op.mpfr_srcptr());$/;"	l
r0	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
r0B	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
r1	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
r1B	gmxmdp.hpp	/^  valtype r0 = NaN, r0B = r0, r1 = NaN, r1B = r1, k0 = NaN, k0B = k0, k1 = k0, k1B = k1;$/;"	m	class:GMXMDP::GMXPGRP	access:public
rINPUT	timeseries.hpp	/^    typedef std::reference_wrapper<INPUT> rINPUT;$/;"	t	class:TimeSeries	access:public
radix	mpfrc++/mpreal.h	/^        static const int  radix             = 2;    $/;"	m	class:std::numeric_limits	access:public
ran2	ran2.c	/^float ran2(long *idum)$/;"	f
ran2.c	ran2.c	1;"	F
random	mpfrc++/mpreal.h	/^    friend const mpreal random(unsigned int seed);$/;"	p	class:mpfr::mpreal	access:friend
random	mpfrc++/mpreal.h	/^inline const mpreal random(unsigned int seed = 0)$/;"	f	namespace:mpfr
random2	mpfrc++/mpreal.h	/^    friend const mpreal random2 (mp_size_t size, mp_exp_t exp);$/;"	p	class:mpfr::mpreal	access:friend
random2	mpfrc++/mpreal.h	/^inline const mpreal random2 (mp_size_t size, mp_exp_t exp)$/;"	f	namespace:mpfr
rcprt	gwham.cpp	/^  const vector<uint> rcprt = split<uint>(argv[k++]);$/;"	l
rcvbegin	gwham.cpp	/^  const linecounter rcvbegin = stoul(argv[k++]);$/;"	l
rcvend	gwham.cpp	/^  const linecounter rcvend = stoul(argv[k++]); $/;"	l
rcvstride	gwham.cpp	/^  const linecounter rcvstride = stoul(argv[k++]); $/;"	l
rdev	functor.hpp	/^	const T rdev = dev - r1;$/;"	l
read	timeseries.hpp	/^    linecounter read(const string& fname, const DATAPROCESSOR& dproc) {$/;"	f	class:TimeSeries	access:public
readaline	fileio.hpp	/^    bool readaline() {$/;"	f	class:fileio	access:public
readalinenb	fileio.hpp	/^    bool readalinenb() {$/;"	f	class:fileio	access:public
readall	fileio.cpp	/^void fileio::readall() {$/;"	f	class:fileio
readall	fileio.hpp	/^    void readall();$/;"	p	class:fileio	access:public
readhist	gwham.cpp	/^histcounter readhist(const string fnhist, histogram& hist) {$/;"	f
readts	fileio.hpp	/^    bool readts() {$/;"	f	class:fileio	access:public
readtsnb	fileio.hpp	/^    bool readtsnb() {$/;"	f	class:fileio	access:public
rec_sqrt	mpfrc++/mpreal.h	/^    friend const mpreal rec_sqrt    (const mpreal& v,                       mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
rec_sqrt	mpfrc++/mpreal.h	/^inline const mpreal rec_sqrt(const mpreal& v, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
record	gwham.cpp	/^  map<coordtype, vector<uint> > record;$/;"	l
record	gwham.hpp	/^     const map<coordtype, vector<uint> >* const record;$/;"	m	class:WHAM	access:private
record	mc.cpp	/^  map<coordtype, vector<uint> > record;$/;"	l
redefcmd.tex	doc/tex/redefcmd.tex	1;"	F
ref	gmxmdp.cpp	/^	  const valtype ref = (1-L)*pgrp.init[0] + L*pgrp.initB[0];$/;"	l
rem	mpfrc++/mpreal.h	/^    friend const mpreal rem (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode); \/\/ Remainder after division$/;"	p	class:mpfr::mpreal	access:friend
rem	mpfrc++/mpreal.h	/^inline const mpreal rem (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
remainder	mpfrc++/mpreal.h	/^    friend const mpreal remainder   (         const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
remquo	mpfrc++/mpreal.h	/^    friend const mpreal remquo      (long* q, const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
reset	ensemble_factory.hpp	/^      pens.reset();$/;"	p
resetlc	fileio.cpp	/^void fileio::resetlc() { lc = 0; }$/;"	f	class:fileio
resetlc	fileio.hpp	/^    void resetlc();$/;"	p	class:fileio	access:public
resize	gmxmdp.cpp	/^	if(!L.size()) {	L.resize(NL, 0); }$/;"	p	file:
resize	gmxmdp.cpp	/^  rstfuncts.resize(Nstates);$/;"	p	file:
resize	likelihoodfunc.hpp	/^      ports.resize(edges.size());$/;"	p
resize	minimizer/cg.hpp	/^		xi.resize(n);$/;"	p
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<double>              {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<int>                 {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<long double>         {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<long int>            {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<long long>           {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpq_t>               {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpreal>              {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpz_t>               {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned int>        {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned long int>   {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned long long>  {typedef mpreal type;};    $/;"	s	namespace:mpfr::internal
result_type	mpfrc++/mpreal.h	/^    template <typename ArgumentType> struct result_type {};    $/;"	s	namespace:mpfr::internal
rho	gwham.cpp	/^    auto rho = wham.calrho(rcprt, pE0);$/;"	l
rho	gwham.hpp	/^  NARRAY rho(DOS.getdosarr(),_dim);$/;"	p
rho	mc.cpp	/^  narray rho = wham.calrho(dimprt,V0);$/;"	l
rhocoord	gwham.hpp	/^    coordtype rhocoord;$/;"	l
rhoit	gwham.hpp	/^    const typename NARRAY::iterator rhoit = rho.find(rhocoord);$/;"	l
rhonorm	gwham.cpp	/^      const valtype rhonorm = it->second\/sum;$/;"	l
rhonorm	mc.cpp	/^    const valtype rhonorm = it->second\/sum;$/;"	l
rhov	gwham.hpp	/^    const valtype rhov = DOS[coord]*weight; \/\/There should be a binsize factor here but if we only care about relative probability (density), it cancels out in the ratio$/;"	l
rhsroutes	likelihoodfunc.hpp	/^      const auto& rhsroutes = rhs.getroutes();$/;"	l
rint	mpfrc++/mpreal.h	/^    friend const mpreal rint (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
rint	mpfrc++/mpreal.h	/^inline const mpreal rint       (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint      );     }$/;"	f	namespace:mpfr
rint_ceil	mpfrc++/mpreal.h	/^    friend const mpreal rint_ceil   (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
rint_ceil	mpfrc++/mpreal.h	/^inline const mpreal rint_ceil  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_ceil );     }$/;"	f	namespace:mpfr
rint_floor	mpfrc++/mpreal.h	/^    friend const mpreal rint_floor  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
rint_floor	mpfrc++/mpreal.h	/^inline const mpreal rint_floor (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_floor);     }$/;"	f	namespace:mpfr
rint_round	mpfrc++/mpreal.h	/^    friend const mpreal rint_round  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
rint_round	mpfrc++/mpreal.h	/^inline const mpreal rint_round (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_round);     }$/;"	f	namespace:mpfr
rint_trunc	mpfrc++/mpreal.h	/^    friend const mpreal rint_trunc  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
rint_trunc	mpfrc++/mpreal.h	/^inline const mpreal rint_trunc (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_trunc);     }$/;"	f	namespace:mpfr
rnblist	likelihoodfunc.hpp	/^        const auto& rnblist = nbnodes[itr->first-headnode];$/;"	l
rnode	likelihoodfunc.hpp	/^        const auto rnode = itr->first;$/;"	l
root	likelihoodfunc.hpp	/^    auto& root = trees[i];$/;"	l
root	mpfrc++/mpreal.h	/^    friend const mpreal root(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
round	mpfrc++/mpreal.h	/^    friend const mpreal round(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
round	mpfrc++/mpreal.h	/^inline const mpreal round(const mpreal& v)$/;"	f	namespace:mpfr
round_error	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal round_error(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits	access:public
round_style	mpfrc++/mpreal.h	/^        inline static float_round_style round_style()$/;"	f	class:std::numeric_limits	access:public
round_style	mpfrc++/mpreal.h	/^        static const std::float_round_style round_style = round_to_nearest;$/;"	m	class:std::numeric_limits	access:public
routes	likelihoodfunc.hpp	/^    map<Node, vector<uint> > routes;$/;"	m	class:ftree	access:public
rowi	gwham.hpp	/^    const auto& rowi = matrix[i];$/;"	l
rroutes	likelihoodfunc.hpp	/^      auto& rroutes = root.getroutes(); $/;"	l
rroutes	likelihoodfunc.hpp	/^    auto& rroutes = root.getroutes(); $/;"	l
rstT	gmxmdp.cpp	/^    GMXPGRP::RestraintType rstT = GMXPGRP::NRestraintTypes;$/;"	l
rstT	gmxmdp.hpp	/^  enum RestraintType { Quad, QuadFlat, NRestraintTypes } rstT = NRestraintTypes;$/;"	m	class:GMXMDP::GMXPGRP	typeref:enum:GMXMDP::GMXPGRP::RestraintType	access:public
rstcenter	mc.cpp	/^    const vector<valtype> rstcenter = wincentrs[i];$/;"	l
rstfuncts	gmxmdp.hpp	/^  vFunctVV rstfuncts; $/;"	m	class:GMXMDP::GMXPGRP	access:public
rstfuncts	mdp.hpp	/^    vector<vFunctVV> rstfuncts;$/;"	m	class:MDP	access:protected
s	mpfrc++/mpreal.h	/^    char *s = NULL;$/;"	l
s	mpfrc++/mpreal.h	/^    mpfr_set_str(mpfr_ptr(), s, base, mode); $/;"	l
sec	mpfrc++/mpreal.h	/^    friend const mpreal sec(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sech	mpfrc++/mpreal.h	/^    friend const mpreal sech  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
seed	metaprog_snippets.hpp	/^  typedef I<1, 1> seed;$/;"	t	struct:ArithmeticSeq	access:public
seed	metaprog_snippets.hpp	/^  typedef I<1, 2> seed;$/;"	t	struct:Fibonacci	access:public
seed	metaprog_snippets.hpp	/^  typedef I<Ni+dN, dN> seed;$/;"	t	struct:ArithmeticSeq	access:public
seed	metaprog_snippets.hpp	/^  typedef I<Nj, Ni+Nj> seed; $/;"	t	struct:Fibonacci	access:public
seekg	fileio.hpp	/^	  fs.seekg(pos);$/;"	p
seen	gwham.hpp	/^    map<uint, bool> seen;$/;"	l
setAB	gmxmdp.cpp	/^void GMXMDP::setAB() {$/;"	f	class:GMXMDP
setAB	gmxmdp.hpp	/^    void setAB();$/;"	p	class:GMXMDP	access:private
setInf	mpfrc++/mpreal.h	/^    mpreal&        setInf  (int Sign = +1);    $/;"	p	class:mpfr::mpreal	access:public
setLs	gmxmdp.cpp	/^void GMXMDP::setLs() {$/;"	f	class:GMXMDP
setLs	gmxmdp.hpp	/^    virtual void setLs();$/;"	p	class:GMXMDP	access:private
setLs	mdp.hpp	/^    virtual void setLs() = 0;$/;"	p	class:MDP	access:private
setMDPABpair	gmxmdp.hpp	/^setMDPABpair(map<string, reference_wrapper<T>>& key2opt,$/;"	f
setMDPenum	gmxmdp.hpp	/^setMDPenum(const map<string, T>& str2enum, const string& str, T& optval) {$/;"	f
setMDPopt	gmxmdp.hpp	/^bool setMDPopt(const InIterator& itbegin, const InIterator& itend, map<string,reference_wrapper<T>>& key2opt) {$/;"	f
setMDPoptval	gmxmdp.hpp	/^setMDPoptval(const string& val, T& container) {$/;"	f
setMDPoptval	gmxmdp.hpp	/^setMDPoptval(const string& val, T& scalar) {$/;"	f
setNan	mpfrc++/mpreal.h	/^    mpreal&        setNan  ();$/;"	p	class:mpfr::mpreal	access:public
setPrecision	mpfrc++/mpreal.h	/^    inline mpreal&      setPrecision(int Precision, mp_rnd_t RoundingMode = get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
setSign	mpfrc++/mpreal.h	/^    mpreal&        setSign (int Sign, mp_rnd_t RoundingMode = get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
setSign	mpfrc++/mpreal.h	/^inline mpreal& mpreal::setSign(int sign, mp_rnd_t RoundingMode)$/;"	f	class:mpfr::mpreal
setZero	mpfrc++/mpreal.h	/^    mpreal&        setZero (int Sign = +1);$/;"	p	class:mpfr::mpreal	access:public
set_default_prec	mpfrc++/mpreal.h	/^    static void            set_default_prec(mp_prec_t prec);$/;"	p	class:mpfr::mpreal	access:public
set_default_prec	mpfrc++/mpreal.h	/^inline void mpreal::set_default_prec(mp_prec_t prec)$/;"	f	class:mpfr::mpreal
set_default_rnd	mpfrc++/mpreal.h	/^    static void            set_default_rnd(mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:public
set_default_rnd	mpfrc++/mpreal.h	/^inline void mpreal::set_default_rnd(mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
set_emax	mpfrc++/mpreal.h	/^    static int       set_emax (mp_exp_t exp);$/;"	p	class:mpfr::mpreal	access:public
set_emin	mpfrc++/mpreal.h	/^    static int       set_emin (mp_exp_t exp);$/;"	p	class:mpfr::mpreal	access:public
set_exp	mpfrc++/mpreal.h	/^    int set_exp(mp_exp_t e);$/;"	p	class:mpfr::mpreal	access:public
set_prec	mpfrc++/mpreal.h	/^    inline void         set_prec(mp_prec_t prec, mp_rnd_t rnd_mode = get_default_rnd());    \/\/ Change precision with rounding mode$/;"	p	class:mpfr::mpreal	access:public
setbinsize	gnarray.hpp	/^    void setbinsize(const vector<Tval>& _binsize) { binsize = _binsize;}$/;"	f	class:gnarray	access:public
setcntgrp	gmxmdp.hpp	/^    void setcntgrp();$/;"	p	class:GMXMDP	access:private
setdim	gnarray.hpp	/^    void setdim(const uint& _dim) { dim = _dim; }$/;"	f	class:gnarray	access:public
setenum	gmxmdp.cpp	/^void GMXMDP::setenum() {$/;"	f	class:GMXMDP
setenum	gmxmdp.hpp	/^    void setenum();$/;"	p	class:GMXMDP	access:private
setexpand	gmxmdp.cpp	/^void GMXMDP::setexpand() {$/;"	f	class:GMXMDP
setexpand	gmxmdp.hpp	/^    virtual void setexpand();$/;"	p	class:GMXMDP	access:private
setexpand	mdp.hpp	/^    virtual void setexpand() = 0;$/;"	p	class:MDP	access:private
sethv	gnarray.hpp	/^    void sethv(const vector<Tval>& _hv) { hv = _hv;}$/;"	f	class:gnarray	access:public
setlv	gnarray.hpp	/^    void setlv(const vector<Tval>& _lv) { lv = _lv;}$/;"	f	class:gnarray	access:public
setmask	gmxmdp.cpp	/^void GMXMDP::setmask() {$/;"	f	class:GMXMDP
setmask	gmxmdp.hpp	/^    void setmask();$/;"	p	class:GMXMDP	access:private
setnarr	gnarray.hpp	/^    void setnarr(const map<Tcoord,Telem>& _narr) { narr = _narr;}$/;"	f	class:gnarray	access:public
setnelms	gnarray.hpp	/^    void setnelms(const vector<uint>& _nelms) { nelms = _nelms;}$/;"	f	class:gnarray	access:public
setpgrpLrst	gmxmdp.cpp	/^void GMXMDP::setpgrpLrst() {$/;"	f	class:GMXMDP
setpgrpLrst	gmxmdp.hpp	/^    void setpgrpLrst();$/;"	p	class:GMXMDP	access:private
setpgrprstfuncts	gmxmdp.cpp	/^void GMXMDP::setpgrprstfuncts() {$/;"	f	class:GMXMDP
setpgrprstfuncts	gmxmdp.hpp	/^    void setpgrprstfuncts();$/;"	p	class:GMXMDP	access:private
setpgrps	gmxmdp.cpp	/^void GMXMDP::setpgrps() {$/;"	f	class:GMXMDP
setpgrps	gmxmdp.hpp	/^    void setpgrps();$/;"	p	class:GMXMDP	access:private
setsc	fileio_utils.hpp	/^void setsc(const string& entry, T& output) {$/;"	f
setstride	gnarray.hpp	/^    void setstride();$/;"	p	class:gnarray	access:private
setstride	gnarray.hpp	/^void gnarray<Tcoord,Telem,Tval>::setstride() {$/;"	f	class:gnarray
setstride	mc.hpp	/^    void setstride(const vector<uint>& Npts, vector<uint>& stride_array) const {$/;"	f	class:potpoly_dblwell	access:private
setvec	fileio_utils.hpp	/^void setvec(const string& entry, vector<T>& output) {$/;"	f
sgn	mpfrc++/mpreal.h	/^    friend int sgn(const mpreal& v); \/\/ returns -1 or +1$/;"	p	class:mpfr::mpreal	access:friend
sgn	mpfrc++/mpreal.h	/^    m.setSign(sgn(y)); \/\/ make sure result has the same sign as Y$/;"	p
sgn	mpfrc++/mpreal.h	/^inline int sgn(const mpreal& op)$/;"	f	namespace:mpfr
shft2	minimizer/cg.hpp	/^	inline void shft2(Doub &a, Doub &b, const Doub c)$/;"	f	struct:Bracketmethod	access:public
shft3	minimizer/cg.hpp	/^	inline void shft3(Doub &a, Doub &b, Doub &c, const Doub d)$/;"	f	struct:Bracketmethod	access:public
shift	metaprog_snippets.hpp	/^  T shift = 0;$/;"	l
shift	metaprog_snippets.hpp	/^  const T shift = CTZ(a|b);$/;"	l
shiftf	gwham.hpp	/^    void shiftf(vector<valtype>& newexpf) const;$/;"	p	class:WHAM	access:public
shiftf	gwham.hpp	/^void WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::shiftf(vector<valtype>& newexpf) const {$/;"	f	class:WHAM
signaling_NaN	mpfrc++/mpreal.h	/^        inline static const mpfr::mpreal signaling_NaN()    { return mpfr::mpreal().setNan();    }$/;"	f	class:std::numeric_limits	access:public
sin	mpfrc++/mpreal.h	/^    friend const mpreal sin(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sin_cos	mpfrc++/mpreal.h	/^    friend int sin_cos(mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sinh	mpfrc++/mpreal.h	/^    friend const mpreal sinh  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sinh_cosh	mpfrc++/mpreal.h	/^    friend int          sinh_cosh   (mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sinh_cosh	mpfrc++/mpreal.h	/^inline int sinh_cosh(mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
size	gnarray.hpp	/^    size_t size() const;$/;"	p	class:gnarray	access:public
size	gnarray.hpp	/^size_t gnarray<Tcoord,Telem,Tval>::size() const {$/;"	f	class:gnarray
size	gwham.cpp	/^    cout << " is contributed from " << histid.size() << " histograms: ";$/;"	p	file:
size	gwham.cpp	/^  fcout << "#created " << pens.size() << " ensembles\\n";$/;"	p	file:
size	gwham.cpp	/^  vector<histogram> hists{pens.size(), histogram{ndim, nbins, hv, lv}};$/;"	p	file:
size	gwham.hpp	/^  vector<NARRAY> sw{hists->size(), DOS.getdosarr()};$/;"	p
sizeof	mpfrc++/mpreal.h	/^        std::memcpy(mpfr_ptr(), u, sizeof(mpfr_t));$/;"	p
skip	ensemble_factory.hpp	/^	bool skip = false;$/;"	l
skipemptylns	fileio.hpp	/^    void skipemptylns() {$/;"	f	class:fileio	access:public
skipemptylns	gwham.cpp	/^  fio_hist.skipemptylns();$/;"	p	file:
skipemptylns	timeseries.hpp	/^        fio.skipemptylns();$/;"	p
split	fileio_utils.cpp	/^void split<string>(vector<string>& output, const string& str, string delims) {$/;"	f
split	fileio_utils.hpp	/^vector<Tp> split(const string& str, string delims=" \\t") {$/;"	f
split	fileio_utils.hpp	/^void split(vector<Tp>& output, const string& str) {$/;"	f
split	fileio_utils.hpp	/^void split(vector<Tp>& output, const string& str, string delims) {$/;"	f
split	fileio_utils.hpp	/^void split<string>(vector<string>& output, const string& str, string delims);$/;"	p
spring	mc.cpp	/^  const valtype spring = 0.2;$/;"	l
sqr	mpfrc++/mpreal.h	/^    friend const mpreal sqr (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sqrt	mpfrc++/mpreal.h	/^    friend const mpreal sqrt(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sqrt	mpfrc++/mpreal.h	/^    friend const mpreal sqrt(const unsigned long int v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const double v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const long double v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const long int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
sqrt	mpfrc++/mpreal.h	/^const mpreal sqrt(const unsigned int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());$/;"	p	namespace:mpfr
srcedges	likelihoodfunc.hpp	/^      const auto& srcedges = src.getedges();$/;"	l
srcjoints	likelihoodfunc.hpp	/^      const auto& srcjoints = src.getjoints();$/;"	l
srcpots	hamiltonian.cpp	/^  const auto& srcpots = src.getPotentialFuncts();$/;"	l
ss	fileio_utils.hpp	/^  stringstream ss(entry);$/;"	p
ss	fileio_utils.hpp	/^  stringstream ss(input);$/;"	p
ss	fileio_utils.hpp	/^  stringstream ss;$/;"	l
state	gwham.cpp	/^  const auto& state = *itstate;$/;"	l
state	mpfrc++/mpreal.h	/^    static gmp_randstate_t state;$/;"	l
states	gwham.cpp	/^      vector<uint> states;$/;"	l
static_assert	metaprog_snippets.hpp	/^  static_assert(N <= sizeof...(T), "Extract_One_Type<T..., N> index out of bound");$/;"	p	struct:Extract_One_Type	access:public
static_cast	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
static_cast	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
static_cast	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),static_cast<long int>(u),mpreal::get_default_rnd());$/;"	p
static_cast	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),static_cast<unsigned long int>(u),mpreal::get_default_rnd());$/;"	p
std	functor.hpp	/^namespace std {$/;"	n
std	metaprog_snippets.hpp	/^namespace std {$/;"	n
std	mpfrc++/mpreal.h	/^namespace std$/;"	n
std::is_floating_point	mpfrc++/mpreal.h	/^    struct is_floating_point<mpfr::mpreal> : public std::true_type {};$/;"	s	namespace:std	inherits:std::true_type
std::is_placeholder	functor.hpp	/^  struct is_placeholder< ::myplaceholder<i> > : public integral_constant<size_t, i>{};$/;"	s	namespace:std	inherits:integral_constant
std::is_pointer	metaprog_snippets.hpp	/^struct is_pointer<std::shared_ptr<T>> : std::true_type {};$/;"	s	namespace:std	inherits:std::true_type
std::isnan	mpfrc++/mpreal.h	/^    inline bool isnan    (const mpfr::mpreal& op){    return (mpfr_nan_p    (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:std
std::numeric_limits	mpfrc++/mpreal.h	/^    class numeric_limits<mpfr::mpreal>$/;"	c	namespace:std
std::numeric_limits::denorm_min	mpfrc++/mpreal.h	/^        inline static const mpfr::mpreal denorm_min()       { return (min)();                    }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::digits	mpfrc++/mpreal.h	/^        inline static int digits()                        {    return int(mpfr::mpreal::get_default_prec());    }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::digits	mpfrc++/mpreal.h	/^        inline static int digits(const mpfr::mpreal& x)   {    return x.getPrecision();                         }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::digits	mpfrc++/mpreal.h	/^        static const int digits       = 53;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits10	mpfrc++/mpreal.h	/^        inline static int digits10(const mpfr::mpreal& x)$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::digits10	mpfrc++/mpreal.h	/^        inline static int digits10(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::digits10	mpfrc++/mpreal.h	/^        static const int digits10     = 15;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::epsilon	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal epsilon(const mpfr::mpreal& x) {  return mpfr::machine_epsilon(x);  }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::epsilon	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal epsilon(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::machine_epsilon(precision); }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm	mpfrc++/mpreal.h	/^        static const float_denorm_style has_denorm  = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_infinity	mpfrc++/mpreal.h	/^        static const bool has_infinity      = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_quiet_NaN	mpfrc++/mpreal.h	/^        static const bool has_quiet_NaN     = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_signaling_NaN	mpfrc++/mpreal.h	/^        static const bool has_signaling_NaN = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::infinity	mpfrc++/mpreal.h	/^        inline static const mpfr::mpreal infinity()         { return mpfr::const_infinity();     }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::is_bounded	mpfrc++/mpreal.h	/^        static const bool is_bounded        = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	mpfrc++/mpreal.h	/^        static const bool is_exact          = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_iec559	mpfrc++/mpreal.h	/^        static const bool is_iec559         = true;        \/\/ = IEEE 754$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	mpfrc++/mpreal.h	/^        static const bool is_integer        = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_modulo	mpfrc++/mpreal.h	/^        static const bool is_modulo         = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_signed	mpfrc++/mpreal.h	/^        static const bool is_signed         = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_specialized	mpfrc++/mpreal.h	/^        static const bool is_specialized    = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::lowest	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal lowest   (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return -mpfr::maxval(precision);  }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	mpfrc++/mpreal.h	/^        inline static int max_digits10(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	mpfrc++/mpreal.h	/^        static const int max_digits10 = 16;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent	mpfrc++/mpreal.h	/^        static const int max_exponent = MPFR_EMAX_DEFAULT;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent10	mpfrc++/mpreal.h	/^        MPREAL_PERMISSIVE_EXPR static const int max_exponent10 = (int) (MPFR_EMAX_DEFAULT * 0.3010299956639811); $/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent	mpfrc++/mpreal.h	/^        static const int min_exponent = MPFR_EMIN_DEFAULT;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent10	mpfrc++/mpreal.h	/^        MPREAL_PERMISSIVE_EXPR static const int min_exponent10 = (int) (MPFR_EMIN_DEFAULT * 0.3010299956639811); $/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::mpfr::max	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal (max)    (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::maxval(precision);  }$/;"	f	class:std::numeric_limits::mpfr	access:public
std::numeric_limits::mpfr::min	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal (min)    (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::minval(precision);  }$/;"	f	class:std::numeric_limits::mpfr	access:public
std::numeric_limits::quiet_NaN	mpfrc++/mpreal.h	/^        inline static const mpfr::mpreal quiet_NaN()        { return mpfr::mpreal().setNan();    }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::r	mpfrc++/mpreal.h	/^            mp_rnd_t r = mpfr::mpreal::get_default_rnd();$/;"	l
std::numeric_limits::radix	mpfrc++/mpreal.h	/^        static const int  radix             = 2;    $/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::round_error	mpfrc++/mpreal.h	/^        inline static mpfr::mpreal round_error(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::round_style	mpfrc++/mpreal.h	/^        inline static float_round_style round_style()$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::round_style	mpfrc++/mpreal.h	/^        static const std::float_round_style round_style = round_to_nearest;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::signaling_NaN	mpfrc++/mpreal.h	/^        inline static const mpfr::mpreal signaling_NaN()    { return mpfr::mpreal().setNan();    }$/;"	f	class:std::numeric_limits	access:public
std::numeric_limits::tinyness_before	mpfrc++/mpreal.h	/^        static const bool tinyness_before   = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::traps	mpfrc++/mpreal.h	/^        static const bool traps             = true;$/;"	m	class:std::numeric_limits	access:public
std::swap	metaprog_snippets.hpp	/^    if(a>b) { std::swap(a,b); }$/;"	p	class:std
std::swap	mpfrc++/mpreal.h	/^    inline void swap(mpfr::mpreal& x, mpfr::mpreal& y) $/;"	f	namespace:std
stephalf	mc.hpp	/^      const valtype stephalf = stepsize\/2;$/;"	l
stepsize	mc.cpp	/^  const valtype stepsize = atof(argv[7]);$/;"	l
stepsize	mc.hpp	/^    const valtype stepsize;$/;"	m	class:MC	access:private
stosc	fileio_utils.hpp	/^T stosc(const string& input) {$/;"	f
stosc	gmxmdp.hpp	/^  container.emplace_back(stosc<value_type>(val));$/;"	p
str2PT	gmxmdp.cpp	/^const map<string, GMXMDP::PType> GMXMDP::str2PT =$/;"	m	class:GMXMDP	file:
str2PT	gmxmdp.hpp	/^    static const map<string, PType> str2PT; $/;"	m	class:GMXMDP	access:public
str2TT	gmxmdp.cpp	/^const map<string, GMXMDP::TType> GMXMDP::str2TT =$/;"	m	class:GMXMDP	file:
str2TT	gmxmdp.hpp	/^    static const map<string, TType> str2TT; $/;"	m	class:GMXMDP	access:public
str2dim	gmxmdp.cpp	/^const map<string, bool> GMXMDP::str2dim = $/;"	m	class:GMXMDP	file:
str2dim	gmxmdp.hpp	/^    static const map<string, bool> str2dim;$/;"	m	class:GMXMDP	access:public
str2fepT	gmxmdp.cpp	/^const map<string, GMXMDP::FEPType> GMXMDP::str2fepT = $/;"	m	class:GMXMDP	file:
str2fepT	gmxmdp.hpp	/^    static const map<string, FEPType> str2fepT; $/;"	m	class:GMXMDP	access:public
str2geomT	gmxmdp.cpp	/^const map<string, GMXMDP::PullGeom> GMXMDP::str2geomT = $/;"	m	class:GMXMDP	file:
str2geomT	gmxmdp.hpp	/^    static const map<string, PullGeom> str2geomT;$/;"	m	class:GMXMDP	access:public
str2pullT	gmxmdp.cpp	/^const map<string, GMXMDP::PullType> GMXMDP::str2pullT = $/;"	m	class:GMXMDP	file:
str2pullT	gmxmdp.hpp	/^    static const map<string, PullType> str2pullT; $/;"	m	class:GMXMDP	access:public
str_c	fileio_utils.cpp	/^  char * str_c = new char[str.size()+1];$/;"	l
stream	metaprog_snippets.hpp	/^    S& stream;$/;"	m	class:FormatStream	access:private
stride_array	gnarray.hpp	/^    vector<uint> stride_array;$/;"	m	class:gnarray	access:private
string	mpfrc++/mpreal.h	/^        os << std::string(s);$/;"	p	class:mpfr::std
stropts	gmxmdp.hpp	/^    typedef map<string, strref> stropts;$/;"	t	class:GMXMDP	access:public
strref	gmxmdp.hpp	/^    typedef rw<string> strref;$/;"	t	class:GMXMDP	access:public
strto	fileio_utils.hpp	/^void strto(vector<Tp>& output, const vector<string>& input) {$/;"	f
subnormalize	mpfrc++/mpreal.h	/^    int subnormalize (int t, mp_rnd_t rnd_mode = get_default_rnd());$/;"	p	class:mpfr::mpreal	access:public
sum	gnarray.hpp	/^    Telem sum() const;$/;"	p	class:gnarray	access:public
sum	gnarray.hpp	/^Telem gnarray<Tcoord,Telem,Tval>::sum() const {$/;"	f	class:gnarray
sum	gwham.cpp	/^    valtype sum = 0.0;$/;"	l
sum	gwham.hpp	/^  const valtype sum = hist.sum();$/;"	l
sum	mc.cpp	/^  valtype sum = 0.0;$/;"	l
sum	mpfrc++/mpreal.h	/^    friend const mpreal sum      (const mpreal tab[], unsigned long int n, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
sum	mpfrc++/mpreal.h	/^inline const mpreal sum (const mpreal tab[], unsigned long int n, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
swap	metaprog_snippets.hpp	/^    if(a>b) { std::swap(a,b); }$/;"	p	class:std
swap	mpfrc++/mpreal.h	/^    friend void swap(mpreal& x, mpreal& y);$/;"	p	class:mpfr::mpreal	access:friend
swap	mpfrc++/mpreal.h	/^    inline void swap(mpfr::mpreal& x, mpfr::mpreal& y) $/;"	f	namespace:std
swap	mpfrc++/mpreal.h	/^inline void         swap (mpreal& a, mpreal& b)            {    mpfr_swap(a.mp,b.mp);   }$/;"	f	namespace:mpfr
sysname	gwham.cpp	/^  const string sysname = string(argv[k++]); $/;"	l
t	mpfrc++/mpreal.h	/^        mpfr_set(mpfr_ptr(), t, mpreal::get_default_rnd()); $/;"	l
t	mpfrc++/mpreal.h	/^    double t;$/;"	l
t	mpfrc++/mpreal.h	/^    mpfr_ptr* t;$/;"	l
t	mpfrc++/mpreal.h	/^    mpfr_t t;$/;"	l
t	mpfrc++/mpreal.h	/^    oss << f << t;$/;"	l
tail	likelihoodfunc.hpp	/^      const auto tail = edge[1];$/;"	l
tan	mpfrc++/mpreal.h	/^    friend const mpreal tan(const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
tanh	mpfrc++/mpreal.h	/^    friend const mpreal tanh  (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
temp	minimizer/cg.hpp	/^				Doub temp=abs(xi[j])*MAX(abs(p[j]),Doub{1.0})\/den;$/;"	l
temp	ran2.c	/^	float temp;$/;"	l
test	minimizer/cg.hpp	/^			Doub test=0.0;$/;"	l
theory.tex	doc/tex/theory.tex	1;"	F
time	mc.hpp	/^      srandom(time(NULL));$/;"	p
timeseries.hpp	timeseries.hpp	1;"	F
tinyness_before	mpfrc++/mpreal.h	/^        static const bool tinyness_before   = true;$/;"	m	class:std::numeric_limits	access:public
titlecovermisc.tex	doc/tex/titlecovermisc.tex	1;"	F
tmp	fileio_utils.hpp	/^  vector<string> tmp;$/;"	l
tmp	mpfrc++/mpreal.h	/^    is >> tmp;$/;"	l
tmp	mpfrc++/mpreal.h	/^    std::string tmp;$/;"	l
toBool	mpfrc++/mpreal.h	/^    bool               toBool      (                        )    const;$/;"	p	class:mpfr::mpreal	access:public
toBool	mpfrc++/mpreal.h	/^inline bool               mpreal::toBool   (             )  const    {    return  mpfr_zero_p (mpfr_srcptr()) == 0;     }$/;"	f	class:mpfr::mpreal
toDouble	mpfrc++/mpreal.h	/^    double             toDouble    (mp_rnd_t mode = GMP_RNDN)    const;$/;"	p	class:mpfr::mpreal	access:public
toDouble	mpfrc++/mpreal.h	/^inline double             mpreal::toDouble (mp_rnd_t mode)  const    {    return  mpfr_get_d  (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toFloat	mpfrc++/mpreal.h	/^    float              toFloat     (mp_rnd_t mode = GMP_RNDN)    const;$/;"	p	class:mpfr::mpreal	access:public
toFloat	mpfrc++/mpreal.h	/^inline float              mpreal::toFloat  (mp_rnd_t mode)  const    {    return  mpfr_get_flt(mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toLDouble	mpfrc++/mpreal.h	/^    long double        toLDouble   (mp_rnd_t mode = GMP_RNDN)    const;$/;"	p	class:mpfr::mpreal	access:public
toLDouble	mpfrc++/mpreal.h	/^inline long double        mpreal::toLDouble(mp_rnd_t mode)  const    {    return  mpfr_get_ld (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toLLong	mpfrc++/mpreal.h	/^    long long          toLLong     (mp_rnd_t mode = GMP_RNDZ)    const;$/;"	p	class:mpfr::mpreal	access:public
toLLong	mpfrc++/mpreal.h	/^inline long long          mpreal::toLLong  (mp_rnd_t mode)  const    {    return  mpfr_get_sj (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toLong	mpfrc++/mpreal.h	/^    long               toLong      (mp_rnd_t mode = GMP_RNDZ)    const;$/;"	p	class:mpfr::mpreal	access:public
toLong	mpfrc++/mpreal.h	/^inline long               mpreal::toLong   (mp_rnd_t mode)  const    {    return  mpfr_get_si (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toString	mpfrc++/mpreal.h	/^    std::string toString(const std::string& format) const;$/;"	p	class:mpfr::mpreal	access:public
toString	mpfrc++/mpreal.h	/^    std::string toString(int n = -1, int b = 10, mp_rnd_t mode = mpreal::get_default_rnd()) const;$/;"	p	class:mpfr::mpreal	access:public
toString	mpfrc++/mpreal.h	/^inline std::string mpreal::toString(const std::string& format) const$/;"	f	class:mpfr::mpreal
toString	mpfrc++/mpreal.h	/^inline std::string mpreal::toString(int n, int b, mp_rnd_t mode) const$/;"	f	class:mpfr::mpreal
toString	mpfrc++/mpreal.h	/^inline std::string toString(T t, std::ios_base & (*f)(std::ios_base&))$/;"	f	namespace:mpfr
toULLong	mpfrc++/mpreal.h	/^    unsigned long long toULLong    (mp_rnd_t mode = GMP_RNDZ)    const;$/;"	p	class:mpfr::mpreal	access:public
toULLong	mpfrc++/mpreal.h	/^inline unsigned long long mpreal::toULLong (mp_rnd_t mode)  const    {    return  mpfr_get_uj (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toULong	mpfrc++/mpreal.h	/^    unsigned long      toULong     (mp_rnd_t mode = GMP_RNDZ)    const;$/;"	p	class:mpfr::mpreal	access:public
toULong	mpfrc++/mpreal.h	/^inline unsigned long      mpreal::toULong  (mp_rnd_t mode)  const    {    return  mpfr_get_ui (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
tol	gwham.cpp	/^  const valtype tol = atof(argv[k++]);$/;"	l
tol	gwham.hpp	/^     const valtype tol;$/;"	m	class:WHAM	access:private
tol	mc.cpp	/^  const valtype tol = atof(argv[8]);$/;"	l
tol	minimizer/cg.hpp	/^	const Doub tol;$/;"	m	struct:Dbrent	access:public
tol1	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
tol2	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
tostr	fileio_utils.hpp	/^string tostr(const T& input) {$/;"	f
tp	mpfrc++/mpreal.h	/^		mp_prec_t tp = mpfr_get_prec(  mpfr_srcptr());$/;"	l
tperline	gwham.cpp	/^	const auto& tperline = ts.nst;$/;"	l
traps	mpfrc++/mpreal.h	/^        static const bool traps             = true;$/;"	m	class:std::numeric_limits	access:public
tree	gwham.hpp	/^    auto& tree = ftrees[0];$/;"	l
tree	likelihoodfunc.hpp	/^    FTree& tree;$/;"	m	class:LikeliHoodFunc	access:private
treei	likelihoodfunc.hpp	/^    const auto treei = ans[i];$/;"	l
true_type	metaprog_snippets.hpp	/^      std::true_type() $/;"	p	class:check_if::std	access:public
trunc	mpfrc++/mpreal.h	/^    friend const mpreal trunc(const mpreal& v);$/;"	p	class:mpfr::mpreal	access:friend
trunc	mpfrc++/mpreal.h	/^inline const mpreal trunc(const mpreal& v)$/;"	f	namespace:mpfr
ts	gwham.cpp	/^  auto& ts = *it;$/;"	l
tsprefix	gwham.cpp	/^      const auto tsprefix = getfnfixes(pmdp->fname)[0];$/;"	l
type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:can_be_const_iterate	access:public
type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:can_be_get	access:public
type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:has_memfn_emplace_back	access:public
type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:has_memfn_get	access:public
type	metaprog_snippets.hpp	/^  struct type {};$/;"	s	struct:has_memfn_size	access:public
type	metaprog_snippets.hpp	/^  typedef I<0> type;$/;"	t	struct:ArithmeticSeq	access:public
type	metaprog_snippets.hpp	/^  typedef I<indices..., Ni+Nj> type;$/;"	t	struct:Fibonacci	access:public
type	metaprog_snippets.hpp	/^  typedef I<indices..., Ni+dN> type;$/;"	t	struct:ArithmeticSeq	access:public
type	metaprog_snippets.hpp	/^  typedef I<output...> type;  $/;"	t	struct:Extract_Indices	access:public
type	metaprog_snippets.hpp	/^  typedef Indices type;$/;"	t	struct:make_index_seq	access:public
type	metaprog_snippets.hpp	/^  typedef T1 type;$/;"	t	struct:Extract_One_Type	access:public
type	metaprog_snippets.hpp	/^  typedef typename Extract_Indices<Superset, I<subsetids...>, I<output..., newelement> >::type type;  $/;"	t	struct:Extract_Indices	access:public
type	metaprog_snippets.hpp	/^  typedef typename Fibonacci<I<1, 1>, I<1,1> >::type type;$/;"	t	struct:Fibonacci	access:public
type	metaprog_snippets.hpp	/^  typedef typename NextIteration::type type;$/;"	t	struct:Extract_One_Type	access:public
type	metaprog_snippets.hpp	/^  typedef typename make_index_seq<newdecision, newIndices, newPropagator, newTerminator>::type type; $/;"	t	struct:make_index_seq	access:public
type	metaprog_snippets.hpp	/^  typedef void type;$/;"	t	struct:Extract_One_Type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<double>              {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<int>                 {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<long double>         {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<long int>            {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<long long>           {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpq_t>               {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpreal>              {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<mpz_t>               {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned int>        {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned long int>   {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
type	mpfrc++/mpreal.h	/^    template <> struct result_type<unsigned long long>  {typedef mpreal type;};    $/;"	t	struct:mpfr::internal::result_type	access:public
typedefs.hpp	typedefs.hpp	1;"	F
u	minimizer/cg.hpp	/^			Doub u=bx-((bx-cx)*q-(bx-ax)*r)\/$/;"	l
u	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
u	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(), u, mode);$/;"	l
u	mpfrc++/mpreal.h	/^	mpfr_set_d(mpfr_ptr(), u, mode);$/;"	l
u	mpfrc++/mpreal.h	/^        mpfr_set  (mpfr_ptr(), u, mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^        std::memcpy(mpfr_ptr(), u, sizeof(mpfr_t));$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_add_d(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_add_q(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_add_si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_add_ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_add_z(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_div_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_div_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_mul_2si(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_mul_2ui(mpfr_ptr(),mpfr_srcptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(),u,mpreal::get_default_rnd());$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), u, mode);$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), u, mode);$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), u, mode);$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_set_sj(mpfr_ptr(), u, mode); $/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), u, mode);$/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_set_uj(mpfr_ptr(), u, mode); $/;"	l
u	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), u, mode);$/;"	l
u1	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
u2	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
uint	likelihoodfunc.hpp	/^  typedef unsigned int uint;$/;"	t	class:LikeliHoodFunc	access:private
uint	typedefs.hpp	/^typedef unsigned int uint;$/;"	t
ulim	minimizer/cg.hpp	/^			Doub ulim=bx+GLIMIT*(cx-bx);$/;"	l
ulong	likelihoodfunc.hpp	/^  typedef unsigned long ulong;$/;"	t	class:LikeliHoodFunc	access:private
ulong	typedefs.hpp	/^typedef unsigned long ulong;$/;"	t
update	likelihoodfunc.hpp	/^      const bool update = (deltaf != x);$/;"	l
urandom	mpfrc++/mpreal.h	/^    friend const mpreal urandom (gmp_randstate_t& state, mp_rnd_t rnd_mode);     \/\/ use gmp_randinit_default() to init state, gmp_randclear() to clear$/;"	p	class:mpfr::mpreal	access:friend
urandom	mpfrc++/mpreal.h	/^inline const mpreal urandom (gmp_randstate_t& state, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
urandomb	mpfrc++/mpreal.h	/^    friend const mpreal urandomb (gmp_randstate_t& state); $/;"	p	class:mpfr::mpreal	access:friend
urandomb	mpfrc++/mpreal.h	/^inline const mpreal urandomb (gmp_randstate_t& state)$/;"	f	namespace:mpfr
usage.tex	doc/tex/usage.tex	1;"	F
utils.hpp	minimizer/utils.hpp	1;"	F
v	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
v	mpfrc++/mpreal.h	/^		mpfr_set_d(mpfr_ptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_div_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_div_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_div_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_div_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_div_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_mul_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_mul_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_mul_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_mul_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_mul_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_set_f(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_set_ld(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_set_q(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_set_si(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_set_ui(mpfr_ptr(), v, mpreal::get_default_rnd());    $/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_set_z(mpfr_ptr(), v, mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_sub_d(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_sub_q(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_sub_si(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_sub_ui(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
v	mpfrc++/mpreal.h	/^    mpfr_sub_z(mpfr_ptr(),mpfr_srcptr(),v,mpreal::get_default_rnd());$/;"	l
vFunctVV	typedefs.hpp	/^typedef vector< FunctVV > vFunctVV;$/;"	t
val	fileio_utils.hpp	/^  Tp val;$/;"	l
val	gmxmdp.hpp	/^    auto& val = it->second.get();$/;"	l
val	gnarray.hpp	/^    const auto& val = it->second;$/;"	l
val	gnarray.hpp	/^    vector<Tval> val = coord2val(coord);$/;"	l
val	gwham.cpp	/^      const vector<valtype> val = rho.coord2val(bin);$/;"	l
val	mc.cpp	/^    const vector<valtype> val = rho.coord2val(bin);$/;"	l
val2coord	gnarray.hpp	/^    const Tcoord val2coord(const vector<Tval>& vals) const;$/;"	p	class:gnarray	access:public
val2coord	gnarray.hpp	/^const Tcoord gnarray<Tcoord,Telem,Tval>::val2coord(const vector<Tval>& vals) const {$/;"	f	class:gnarray
valref	gmxmdp.hpp	/^    typedef rw<valtype> valref;$/;"	t	class:GMXMDP	access:public
valrhs	gnarray.hpp	/^    const auto& valrhs = itrhs->second;$/;"	l
vals	gnarray.hpp	/^    const vector<Tval> vals = coord2val(coord);$/;"	l
vals	gnarray.hpp	/^  vector<Tval> vals;$/;"	l
vals	gnarray.hpp	/^  vector<vector<Tval> > vals;$/;"	l
vals	gwham.cpp	/^    const auto& vals = hists[histid[0]].coord2val(coord);$/;"	l
vals	gwham.cpp	/^    fcout << vals; $/;"	l
vals	gwham.hpp	/^    const vector<valtype> vals = coord2val(coord);$/;"	l
vals	gwham.hpp	/^    const vector<valtype> vals = hist.coord2val(coord);$/;"	l
vals	gwham.hpp	/^  vector<valtype> vals;$/;"	l
valtype	likelihoodfunc.hpp	/^  typedef decltype( declval<narrit>()->second ) valtype; $/;"	t	class:LikeliHoodFunc	access:private
valtype	typedefs.hpp	/^typedef double valtype; \/\/the data type we histogram$/;"	t
valtype	typedefs.hpp	/^typedef mpreal valtype;$/;"	t
valtypename	gwham.cpp	/^    const string valtypename = typeid(valtype).name();$/;"	l
value	metaprog_snippets.hpp	/^  Des value;$/;"	m	struct:ContainerCopier	access:public
value	metaprog_snippets.hpp	/^  constexpr static bool value = decltype(f<T>(0))::value;$/;"	m	struct:check_if	access:public
value	metaprog_snippets.hpp	/^  constexpr static size_t value = Extract_One_Index<I<indices...>, N-1>::value;$/;"	m	struct:Extract_One_Index	access:public
value	metaprog_snippets.hpp	/^  constexpr static size_t value = Last_Index<rest...>::value;$/;"	m	struct:Last_Index	access:public
value	metaprog_snippets.hpp	/^  constexpr static size_t value = n;$/;"	m	struct:Extract_One_Index	access:public
value	metaprog_snippets.hpp	/^  constexpr static size_t value = z;$/;"	m	struct:Last_Index	access:public
value_type	gmxmdp.hpp	/^  typedef typename T::value_type value_type;$/;"	t
vec	gmxmdp.hpp	/^  vector<valtype> vec;$/;"	m	class:GMXMDP::GMXPGRP	access:public
vecfromTS	gwham.cpp	/^void vecfromTS(vector<T>& ans, TS& ts, uint nrun, string fnprefix) {$/;"	f
vecopts	gmxmdp.hpp	/^    typedef map<string, vvref> vecopts;$/;"	t	class:GMXMDP	access:public
vecstropts	gmxmdp.hpp	/^    typedef map<string, vsref> vecstropts;$/;"	t	class:GMXMDP	access:public
vector	fileio_utils.hpp	/^    vector<Tp> tmp((istream_iterator<Tp>(iss)), istream_iterator<Tp>());$/;"	p
vp	mpfrc++/mpreal.h	/^			mpfr_init2(mpfr_ptr(), vp);$/;"	l
vp	mpfrc++/mpreal.h	/^		mp_prec_t vp = mpfr_get_prec(v.mpfr_srcptr());$/;"	l
vpEnsemble	typedefs.hpp	/^typedef vector<pEnsemble> vpEnsemble;$/;"	t
vpMDP	typedefs.hpp	/^typedef vector<pMDP> vpMDP;$/;"	t
vsref	gmxmdp.hpp	/^    typedef rw<vector<string> > vsref;$/;"	t	class:GMXMDP	access:public
vts	gwham.cpp	/^      auto vts = pmdp->CreateTimeSeries(needpotential);$/;"	l
vvref	gmxmdp.hpp	/^    typedef rw<vector<valtype> > vvref;$/;"	t	class:GMXMDP	access:public
w	metaprog_snippets.hpp	/^    uint w;$/;"	m	class:FormatStream	access:private
w	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
weight	gwham.hpp	/^    const valtype weight = exp(exparg);$/;"	l
wham	gwham.cpp	/^  WHAM<pEnsemble, histogram, narray> wham(record, hists, pens, Nsamples, tol, fseeds, vector<narray>(0), ifmin, overlap);$/;"	p	file:
wham	mc.cpp	/^  WHAM<pEnsemble,histogram,narray> wham(record,hists,V,Nsamples,tol,vector<valtype>(0), vector<narray>(0), true, overlap);$/;"	p	file:
whamvsraw	gwham.hpp	/^    vector<valtype> whamvsraw(const NARRAY& rho) const;$/;"	p	class:WHAM	access:public
whamvsraw	gwham.hpp	/^vector<valtype> WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::whamvsraw(const NARRAY& rho) const {$/;"	f	class:WHAM
whamvsrawi	gwham.hpp	/^    etas.push_back(whamvsrawi(i, rho));$/;"	p
whamvsrawi	gwham.hpp	/^    valtype whamvsrawi(const uint& i, const NARRAY& rho) const;$/;"	p	class:WHAM	access:public
whamvsrawi	gwham.hpp	/^valtype WHAM<PENSEMBLE,HISTOGRAM,NARRAY>::whamvsrawi(const uint& i, const NARRAY& rho) const {$/;"	f	class:WHAM
what	exception.hpp	/^    virtual const char* what() const throw() { return msg.c_str(); }$/;"	f	class:General_Exception	access:public
why	mpfrc++/mpreal.h	/^    std::string why() { return "inexact conversion from floating point"; }$/;"	f	class:mpfr::conversion_overflow	access:public
width	metaprog_snippets.hpp	/^      stream.width(w);$/;"	p
width	metaprog_snippets.hpp	/^    void width(const uint _width) { w = _width; }$/;"	f	class:FormatStream	access:public
wincentr	mc.cpp	/^    const vector<valtype> wincentr = wincentrs[i];$/;"	l
wincentrs	mc.cpp	/^  const vector<vector<valtype> > wincentrs = windows.canonical_valseries();$/;"	l
windows	mc.cpp	/^  narray windows(dim,nwins,hv,lv);$/;"	p	file:
x	gmxmdp.cpp	/^	fcout << x;$/;"	l
x	likelihoodfunc.hpp	/^    vector<valtype> x;$/;"	m	class:LikeliHoodFunc	access:private
x	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
x	mpfrc++/mpreal.h	/^    mpreal x(a);$/;"	p
x	mpfrc++/mpreal.h	/^    mpreal x(v);$/;"	p
x	mpfrc++/mpreal.h	/^    mpreal x;$/;"	l
xi	minimizer/cg.hpp	/^	VecDoub xi;$/;"	m	struct:Dlinemethod	access:public
xi	minimizer/cg.hpp	/^	const VecDoub &xi;$/;"	m	struct:Df1dim	access:public
xm	minimizer/cg.hpp	/^		Doub fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm;$/;"	l
xmin	minimizer/cg.hpp	/^		Doub ax,xx,xmin;$/;"	l
xmin	minimizer/cg.hpp	/^	Doub xmin,fmin;$/;"	m	struct:Dbrent	access:public
xp	mpfrc++/mpreal.h	/^    mp_prec_t yp, xp;$/;"	l
xt	minimizer/cg.hpp	/^	VecDoub xt;$/;"	m	struct:Df1dim	access:public
xx	minimizer/cg.hpp	/^		Doub ax,xx,xmin;$/;"	l
yp	mpfrc++/mpreal.h	/^    mp_prec_t yp, xp;$/;"	l
zero	metaprog_snippets.hpp	/^  const T zero = T(0);$/;"	l
zeta	mpfrc++/mpreal.h	/^    friend const mpreal zeta     (const mpreal& v, mp_rnd_t rnd_mode);$/;"	p	class:mpfr::mpreal	access:friend
~Ensemble	ensemble.hpp	/^    virtual ~Ensemble() {};$/;"	f	class:Ensemble	access:public
~General_Exception	exception.hpp	/^    virtual ~General_Exception() throw() {};$/;"	f	class:General_Exception	access:public
~NPT	ensemble.hpp	/^    virtual ~NPT() {};$/;"	f	class:NPT	access:public
~NVE	ensemble.hpp	/^    virtual ~NVE() {};$/;"	f	class:NVE	access:public
~NVT	ensemble.hpp	/^    virtual ~NVT() {};$/;"	f	class:NVT	access:public
~mpreal	mpfrc++/mpreal.h	/^    ~mpreal();                           $/;"	p	class:mpfr::mpreal	access:public
~mpreal	mpfrc++/mpreal.h	/^inline mpreal::~mpreal() $/;"	f	class:mpfr::mpreal
